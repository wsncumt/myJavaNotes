\documentclass[a4paper]{report}
\usepackage[space,fancyhdr,fntef]{ctexcap}
\usepackage{fontspec}
\fontspec{宋体}
\setmainfont{Times New Roman}
%\fontsize{50pt}{50pt}\selectfont
\renewcommand{\rmdefault}{ptm}
\usepackage[namelimits,sumlimits,nointlimits]{amsmath}
\usepackage[text={169mm,250mm},bottom=20mm,top=25mm,left=25mm,right=15mm,centering]{geometry}
\usepackage{color}
\usepackage{CJKfntef}%下划线宏包160页
\usepackage{xcolor}
\usepackage{arydshln}%234页，虚线表格宏包
\pagestyle{fancy} \fancyhf{}
\fancyhead[OC]{\color{gray}\rightmark}

\fancyhead[EC]{\color{gray}\leftmark}
\fancyfoot[C]{\color{gray}\thepage}
\renewcommand{\headrule}{\color{gray}\hrule width\headwidth}
%\renewcommand{\footrulewidth}{0.4pt}%改为0pt即可去掉页脚上面的横线
%\usepackage{parskip}
%\usepackage{indentfirst}
\usepackage{graphicx}%插图宏包，参见手册318页
\definecolor{dkgreen}{RGB}{106,135,89}
\definecolor{dkblue}{RGB}{103,150,163}
\definecolor{wgray}{RGB}{248,248,248}
\definecolor{WGRAY}{RGB}{248,248,248}
\usepackage{listings}
\lstset{language=Java,
backgroundcolor=\color{wgray},
rulesepcolor=\color{red!20!green!20!blue!20},%代码块边框为淡青色
%lablestep=1,
%lablesep=5pt,
%lablestyle=\tiny,
%tablesize=4,
%captionpos=b,
basicstyle=\ttfamily\small,
keywordstyle=\color{orange},
commentstyle=\color{gray},
stringstyle=\color{dkgreen},
numberstyle=\tiny,
numbersep=8pt,
frame=single,%topline.bottomline,lines,single,leftline
identifierstyle=\color{dkblue},
numbers=left,
stepnumber=1,
xleftmargin=2em,xrightmargin=2em, aboveskip=1em,
breaklines=true
}
\usepackage[xetex,colorlinks]{hyperref}%394页  \href{网址}{文本}
\hypersetup{urlcolor=blue}
%\linebreak[2]%换行，152页
\usepackage{fancybox}%盒子宏包55页
\setcounter{secnumdepth}{4}
\CTEXoptions[contentsname={目\hspace{15pt}录}]
\CTEXsetup[beforeskip={-40pt},afterskip={20pt plus 2pt minus 2pt}]{chapter}

%目录设置
\usepackage{titletoc}
\usepackage[toc]{multitoc}
\titlecontents{chapter}[4em]{\addvspace{2.3mm}\bf}{\contentslabel{4.0em}}{}{\titlerule*[5pt]{$\cdot$}\contentspage}
\titlecontents{section}[4em]{}{\contentslabel{2.5em}}{}{\titlerule*[5pt]{$\cdot$}\contentspage}
\titlecontents{subsection}[7.2em]{}{\contentslabel{3.3em}}{}{\titlerule*[5pt]{$\cdot$}\contentspage}
\usepackage{fancyvrb}%75页抄录宏包
\begin{document}
\flushbottom%版心底部对齐
\newcommand{\dm}[1]{\colorbox{wgray}{\lstinline`#1`}}
\newcommand{\myroman}[1]{\uppercase\expandafter{\romannumeral#1}}
\newcounter{num}[section] \renewcommand{\thenum}{\arabic{num}.} \newcommand{\num}{\refstepcounter{num}\text{\thenum}}

\newenvironment{tips}{\kaishu\zihao{-6}\color{blue}{\noindent\rule[-3pt]{\textwidth}{0.5pt}\par \em \noindent {\zihao{-5} \textcolor[rgb]{1.00,0.00,0.00}{Tips}}}\par}{\\ \rule[3mm]{\textwidth}{0.5pt}\par}

\newenvironment{zhengming}{\kaishu\zihao{-5}\color{blue}{\noindent\em 证明：}\par}{\hfill $\diamondsuit$\par}

\tableofcontents
\pagenumbering{Roman}%设置目录页码
\clearpage
\pagenumbering{arabic}%设置正文页码

\chapter{线程概述}
\section{线程相关概念}
\subsection{进程}
进程(Process)：计算机中的程序关于某数据集合上的一次运行活动，是操作系统进行资源分配与调度的基本单位。

可以简单的理解为正在操作系统中运行的一个程序。

\subsection{线程}
线程(Thread)是进程的一个执行单元。

一个线程就是进程中一个单一顺序的控制流，一个线程就是进程的一个执行分支。

进程是线程的容器，一个进程至少有一个线程。一个进程中也可以有多个线程。

操作系统中是以进程为单位分配资源，如虚拟存储空间，文件描述符等。每个线程都有各自的线程栈，自己的寄存器环境，自己的线程本地存储。

\subsection{主线程和子线程}
JVM启动时会创建一个主线程，该主线程负责执行main()方法，主线程就是运行main方法的线程。

Java中的线程不是孤立的，线程之间存在一些联系。如果在A线程中创建了B线程，称B线程为A线程的子线程，相应的A线程就是B线程的父线程。
\subsection{串行、并发和并行}
\subsubsection{串行}
串行(Sequential)：对于多个任务，在执行完一个任务后再去做下一个任务。缺点：耗时。

\subsubsection{并发}

并发(Concurrent)：对于多个任务，先做其中一个任务，在该任务进入等待状态时（例如等待用户的输入）就开始做下一个任务。

\subsubsection{并行}
并行(Parallel)：多个任务同时开始，总耗时取决于所需时间最长的那个任务。
\subsubsection{对比}
并发可以提高事物的处理效率，即一段时间内可以处理或者完成更多的事情。

并行是一种更为严格的，理想的并发。

从硬件角度来说，如果是单核CPU，一个处理器只能执行一个线程的情况下，处理器可以使用时间片轮转技术，可以让CPU在各个线程间进行切换。对于用户来说，感觉是多个线程在同时执行。

如果是多核CPU，可以为不同的线程分配不同的CPU内核。
\section{线程的创建与启动}
在Java中，创建一个线程，就是创建一个\dm{Thread}类（子类）的对象（实例）。

\dm{Thread}类有两个常用的构造方法：\dm{Thread()}与\dm{Thread(Runnable)}，对应的创建线程的两种方式：
\begin{itemize}
  \item 定义\dm{Thread}类的子类
  \item 定义一个\dm{Runnable}接口的实现类
\end{itemize}
这两种创建线程得到方式没有本质的区别。

\begin{lstlisting}[title=创建线程方式一]
//1.定义类继承Thread
public class MyThread extends Thread{
    //2.重写父类中的run方法

    //run()方法体中的代码就是子线程要执行的任务
    @Override
    public void run() {
//        super.run();
        System.out.println("这是子线程打印的内容！");
    }
}

public class Test {
    public static void main(String[] args)  {
        System.out.println("Java虚拟机启动main线程，该线程执行main方法");
        //3.创建子线程对象
        MyThread myThread = new MyThread();

        //4.启动线程
        //调用线程的start()方法来启动线程
        //启动线程的实质就是请求JVM运行相应的线程
        //这个线程具体在什么时候运行由线程调度器(Scheduler)决定
        //注意：start()方法的调用结束并不意味着子线程开始运行，只是通知JVM该线程准备好了
        //      新开启的线程会执行run()方法
        //      如果开启了多个线程，start()调用得到顺序不一定就是线程启动的顺序
        //      多线程运行结果与代码顺序或调用顺序无关
        myThread.start();
        try{
            Thread.sleep(1000);//线程休眠，单位是毫秒
        }catch(Exception e){
            System.out.println(e.getMessage());
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[title=创建线程方式二]
/**
 * 当线程类已经有父类，就不能用继承Thread类的形式来创建线程
 * 可以使用实现Runnable接口的形式来实现
 * 1.定义类实现Runnable接口
 */
public class MyRunnable implements Runnable{
    //2.重写Runnable接口中的抽象方法run
    //run()就是子线程要执行的代码
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("sub thread-->" + i);
        }
    }
}

public class test {
    public static void main(String[] args) {
        //3.创建Runnable接口的实现类对象
        MyRunnable myRunnable = new MyRunnable();
        //4.创建线程对象
        //Thread的一个构造方法参数类型为实现Runnable接口的对象
        //使用该构造方法创建一个线程对象
        Thread thread = new Thread(myRunnable);
        //5.开启线程
        thread.start();
        //main线程
        for (int i = 0; i < 100; i++) {
            System.out.println("main thread-->" + i);
        }

        //有时候调用Thread(Runnable)构造方法时，实参也会传递匿名内部类对象
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    System.out.println("匿名内部内子线程 thread-->" + i);
                }
            }
        });
        thread1.start();
    }
}
\end{lstlisting}
\section{线程的常用方法}
\subsection{\dm{currentThread()}方法}
\dm{Thread.currentThread()}（类方法）：可以获得当前线程

Java中的任何一段代码都是执行在某个线程当中的，执行当前代码的线程就是当前线程。

同一段代码可能被不同的线程执行，因此当前线程是相对的。

该方法的返回值是在代码实际运行时的线程对象。

\begin{lstlisting}
public class SubThread extends Thread{
    public SubThread(){
        System.out.println("构造方法打印当前线程名称：" + Thread.currentThread().getName());
    }
    @Override
    public void run() {
        System.out.println("run方法打印当前线程名称：" + Thread.currentThread().getName());
    }
}

public class Test01CurrentThread {
    public static void main(String[] args) {
        System.out.println("main方法打印当前线程名称：" + Thread.currentThread().getName());
        //创建子线程,调用SubThread构造方法
        //在main线程中调用构造方法，所以构造方法中的当前线程就是main线程
        SubThread subThread = new SubThread();
        subThread.start();//启动子线程，子线程会调用run方法，所以run()当前线程就是Thread-0子线程。
        subThread.run();//在main方法中直接调用run()方法，没有开启新的线程，所以run()方法所在的当前线程就是main方法
    }
}
\end{lstlisting}
当前线程就是调用该方法的线程。


\begin{lstlisting}[title=复杂一点的代码]（视频2-5）
public class SubThread1 extends Thread {
    public SubThread1() {
        System.out.println("构造方法中，Thread.currentThread().getName():" + Thread.currentThread().getName());
        System.out.println("构造方法中：this.getName()：" + this.getName());
    }

    @Override
    public void run() {
        System.out.println("run方法中，Thread.currentThread().getName():" + Thread.currentThread().getName());
        System.out.println("run方法中：this.getName()：" + this.getName());

    }
}

public class Test02CurrentThread {
    public static void main(String[] args) throws InterruptedException {

        //创建子线程对象
        SubThread1 subThread1 = new SubThread1();
        subThread1.setName("st1");//设置线程名称
        subThread1.start();
        Thread.sleep(500);//main线程睡眠500毫秒
        Thread thread = new Thread(subThread1);
        thread.setName("st2");
        thread.start();
    }
}
\end{lstlisting}

\begin{lstlisting}[title = 运行结果]
构造方法中，Thread.currentThread().getName():main //new该对象是由main调用的，来到SubThread1的构造方法，Thread.currentThread()获得当前线程
构造方法中：this.getName()：Thread-0 //this.getName()中this代表当前对象，在构造方法中，当前对象是new出来的对象，new出来的SubThread1对象的线程就是thread-0
run方法中，Thread.currentThread().getName():st1 //启动线程后，就会执行run方法，当前线程和this是同一线程，都是st1
run方法中：this.getName()：st1

//new Thread(subThread1)创建新的线程，Thread是父类，不会执行子类的构造方法
//thread.start()启动线程执行run方法，现在是st2线程在执行run方法，所以currentThread()得到的是st2线程
run方法中，Thread.currentThread().getName():st2
//创建Thread实例时，给它传递了一个Runnable接口实现的对象subThread1,run方法中的this指的就是subThread1
run方法中：this.getName()：st1
\end{lstlisting}
\subsection{\dm{setName()/getName()}}
这两个方法是实例方法.

\begin{lstlisting}
Thread thread = new Thread();

thread.setName("t1");//设置线程名称
thread.getName();
\end{lstlisting}
通过设置线程名称有助于程序调试，提高程序的可读性，建议为每个线程都设置一个能够体现线程功能的名称。
\subsection{\dm{isAlive()}}
\dm{thread.isAlive()}判断当前进程是否处于活动状态。

活动状态：线程已启动并且尚未终止。

\subsection{\dm{sleep()}}
\dm{Thread.sleep(millis)}:让当前线程休眠指定的毫秒数

当前线程指的是\dm{Thread.currentThread()}返回的线程
\subsection{\dm{getId()}}
\dm{thread.getId()}:获得并返回线程的唯一标识。

某个编号的线程运行结束后，该编号可能被后续创建的线程使用。

重启JVM后，同一个线程的编号可能不一样。

\subsection{\dm{yield()}}
\dm{Thread.yield()}：放弃当前的CPU资源。
\subsection{\dm{setPriority()}}
\dm{thread.setPriority(num)}：设置线程的优先级

Java线程的优先级的取值范围是1-10,超出该范围就会抛出异常\dm{IllegalArgumentException}。

在操作系统中，优先级较高的线程获得的CPU资源越多。

线程优先级本质上是只是给线程调度器一个提示信息，以便于调度器决定调度哪些线程，并不能保证优先级高的线程线运行。

Java优先级设之不当或者滥用可能导致某些线程永远无法得到运行，即产生了线程饥饿。

线程优先级并不是设置的越高越好，一般情况下使用普通的优先级即可，即在开发时不必设置线程的优先级，采用默认值即可。

线程的优先级具有继承性，在A线程中创建了B线程，则B线程的优先级与A线程一致。
\subsection{\dm{interrupt()}}
\dm{thread.interrupt()}：中断线程

调用该方法仅仅是在当前线程打一个停止标志，并不是真正的停止线程。

\dm{thread.isInterrupted()}返回线程的中断标志

可以使用中断标志来结束线程，即
\begin{lstlisting}
\\在run方法中
if(this.isInterrupted()){
    return;
}
\end{lstlisting}
\subsection{\dm{setDaemon()}}
\dm{thread.setDaemon(true)}：将某个线程设置为守护线程,设置守护线程的代码应在线程的启动前。

Java中的线程分为用户线程和守护线程，守护线程是为其他线程提供服务的线程，如垃圾回收器就是一个典型的守护线程。

守护线程不能单独运行，当JVM中没有其他用户线程，只有守护线程时，守护线程自动销毁，JVM就会退出。
\section{线程的生命周期}
可以通过\dm{getState()}方法来获得，线程状态是\dm{Thread.State}枚举类型定义的。有以下几种
\begin{itemize}
  \item \dm{NEW}：新建状态，创建了线程对象，在调用\dm{start}启动之前的状态。
  \item \dm{RUNNABLE}：可运行状态，是一个复合状态，包括\dm{READY}和\dm{RUNNING}两个状态。\dm{READY}状态表示该线程可以被线程调度器进行调度使它处于\dm{RUNNING}状态。\dm{RUNNING}状态表示线程正在执行，\dm{Thread.yield()}方法可以把线程由\dm{RUNNING}状态转换为\dm{READY}状态。
  \item \dm{BLOCKED}：阻塞状态，线程发起阻塞的I/O操作，或者申请由其他线程占用的独占资源，线程会转为\dm{BLOCKED}，处于阻塞状态的线程不会占用CPU资源，当阻塞I/O操作执行完或者线程获得了其申请的资源，线程可以转化为\dm{RUNNABLE}。
  \item \dm{WAITING}：等待状态，线程执行了\dm{object.wait()}方法或\dm{thread.join()}方法，会把线程转换为\dm{WAITING}等待状态，执行\dm{object.notify()}方法，或者加入的线程执行完毕，当前的线程会转换为\dm{RUNNABLE}。
  \item \dm{TIME_WAITING}：与\dm{WAITING}类似，都是等待状态，也可调用\dm{Thread.sleep()}方法将其转换为\dm{TIME_WAITING}状态，区别在于处于该状态的线程不会无限的等待。如果线程没有在指定的时间范围内完成期望操作，该线程就会自动转换为\dm{RUNNABLE}。
  \item \dm{TERMINATED}：终止状态，线程结束处于终止状态。
\end{itemize}
\section{多线程编程的优势与存在的风险}
\subsection{优势}
\begin{itemize}
  \item 提高系统的吞吐率（Throughout），多线程编程编程可以使一个进程有多个并发（concurrent,即同时进行）的操作。
  \item 提高响应性（Responsiveness）。例如Web服务器会采用一些专门的线程负责用户的请求处理，缩短了用户的等待时间。
  \item 充分利用多核（Multicore）处理器资源。通过多线程充分的利用CPU资源。
\end{itemize}
\subsection{风险}
\begin{itemize}
  \item 线程安全(Thread safe)问题，多个线程共享数据时，如果没有采取正确的并发访问控制措施，就会产生数据一致性问题。如读取脏数据（过期的数据），如丢失数据更新。
  \item 线程活性(Thread liveness)问题。由于程序自身的缺陷或资源的稀缺性导致线程一直处于非\dm{RUNNABLE}状态。常见的活性故障有：
      \begin{itemize}
        \item 死锁(Deadlock)：类似于鹬蚌相争。
        \item 锁死(Lockout)：类似于睡美人故事中的王子挂了
        \item 活锁(Livelock)：类似于小猫咬自己的尾巴。
        \item 饥饿(Starvation)：类似于健壮的雏鸟总是从母鸟嘴中抢到食物，弱小的雏鸟总是挨饿。
      \end{itemize}
  \item 上下文切换(Context Switch)：处理器从执行一个线程切换到执行另外一个线程需要性能消耗
  \item 可靠性：可能会有一个线程导致JVM意外终止，其他线程也无法执行。
\end{itemize}
\chapter{线程安全问题}
非线程安全主要指多个线程对同一个对象的实例变量进行操作时，会出现值被更改，值不同步的情况。

线程安全问题表现为三个方面：原子性，可见性和有序性。
\section{原子性}
原子(Atomic)就是不可分割的意思，原子操作得到不可分割有两层含义
\begin{itemize}
  \item 访问（读、写）某个共享变量的操作从其他线程来看，该操作要么已经执行完毕，要么尚未发生，即其他线程看不到当前操作的中间结果。
  \item 访问同一组共享变量的原子操作是不能够交错的。
\end{itemize}

Java有两种方式实现原子性：一是使用锁，另一种是使用处理器的CAS(Compare and Swap)指令。

锁具有排他性，可以保证共享变量在某一时刻只能被一个线程访问。

CAS指令直接在硬件（处理器和内存）上实现原子操作，看做是硬件锁。

Java中提供了一个线程安全\dm{AtomicInteger}类，保证了操作的原子性。
\section{可见性}
在多线程环境中，一个线程对某个共享变量进行更新后，后续的其他线程可能无法立即读取到这个更新的结果。

如果一个线程对共享变量更新后，后续访问该变量的其他线程可以读到更新的结果，称这个线程对共享变量的更新对其他线程可见。否则称这个线程对共享变量的更新对其他线程不可见。

多线程程序因为可见性问题可能会导致其他线程读取到旧数据。
\section{有序性}
有序性（Ordering）是指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作在另一个处理器运行的其他线程看来是乱序（Out of Order）的。

乱序是指内存访问操作的顺序看起来发生了变化。
\subsection{重排序}
在多核处理器环境下，编写的顺序结构这种操作执行得到顺序可能是没有保障的：
\begin{itemize}
  \item 编译器可能会改变两个操作的先后顺序。
  \item 处理器也可能不会按照目标代码的顺序执行。
\end{itemize}

一个处理器上执行的多个操作，在其他处理器看来它的顺序与目标代码指定的顺序可能不一样，这种现象称为重排序。

重排序是对内存访问有关操作的一种优化，可以在不影响单线程程序正确的情况下提升程序的性能。但是可能会对多线程程序的正确性产生影响，可能导致线程安全问题。

一组概念：
\begin{itemize}
  \item 程序顺序：处理器上运行的目标代码所指定的内存访问顺序。
  \item 执行顺序：内存访问操作在处理器上实际执行的顺序。
  \item 感知顺序：给定处理器所感知到的该处理器及其他处理器的内存访问操作顺序。
\end{itemize}

可以把重排序指令分为两种：
\begin{itemize}
  \item 指令重排序：由JIT编译器处理器引起的，指程序顺序与执行顺序不一样。
  \item 存储子系统重排序是由高速缓存，写缓冲器引起的。感知顺序与执行顺序不一致。
\end{itemize}
\subsection{指令重排序}
在源码顺序与程序顺序不一致或程序顺序与执行顺序不一致的情况下，我们就说发生了指令重排序（Instruction Reorder）。

指令重排是一种动作，确实对指令顺序做了调整，重排序了对象指令。javac编译器一般不会执行指令重排序，而JIT编译器可能执行指令重排序。

处理器也可能执行指令重排序，使得执行顺序与程序顺序不一致。
\subsubsection{存储子系统重排序}
存储子系统是指写缓冲器与高速缓存。

写缓冲器（Store buffer,Write buffer）用来提高写高速缓存操作的操作效率的。

即使处理器严格按照程序执行顺序执行两个内存访问操作，在存储子系统的作用下，其他处理器对这两个操作的感知顺序也可能与程序顺序不一致。即这两个操作顺序看起来像是发生了变化，这种现象称为存储子系统重排序。

存储子系统重排序并没有真正的对指令执行顺序进行调整，而是造成一种指令执行顺序被调整的假相。

存储子系统重排序对象是内存操作的结果。

从处理器角度来看，读内存就是从指定的RAM地址中加载数据到寄存器，称为Load操作。写内存就是把数据存储到指定的地址表示的RAM存储单元VS，称为Store操作。内存重排序有以下四种可能：
\begin{itemize}
  \item LoadLoad重排序。一个处理器上先后执行两个读操作L1和L2，其他处理器对这两个内存操作的感知顺序可能是L2，L1（顺序反了）。
  \item StoreStore重排序。
  \item LoadStore重排序。
  \item StoreLoad重排序。
\end{itemize}

高速缓存(Cache)是CPU中为了匹配与主内存处理速度不匹配而设计的一个高速缓存。
\subsection{貌似串行语义}
JIT编译器，处理器，存储子系统是按照一定的规则对指令，内存操作的结果进行重排序。给单线程程序造成一种假象--指令是按照源码的顺序执行的，这种假象称为貌似串行语义。并不能保证多线程环境程序的正确性。

为了保证貌似串行语义，有数据依赖关系的语句不会被重排序。
\section{Java内存模型}
每个线程都有独立的栈空间，在每个栈空间中每个方法都有独立的一块空间。

每个线程都可以访问堆内存。

计算机的凑不直接从主内存读取数据，CPU读取数据时，先把主内存的数据读入cache中，再把Cache的数据读到Register寄存器中（寄存器在CPU内）。

JVM中的共享数据可能会被分配到寄存器，每个CPU都有自己的寄存器，一个CPU不能读取其他CPU的寄存器内容。如果两个线程分别运行在不同的处理器上，而共享的数据被分配到寄存器上，就会产生可见性问题。即使JVM中的共享数据分配到主内存中，也不能保证数据的可见性。也可能分配到Cache中，也可能分配到主内存中。

一个处理器上运行的线程对数据的更新可能只是更新到处理器的写缓冲器上，还未到达Cache缓存，更不用说到达主内存，一个处理器不能读取到另一个处理器写缓冲器上的内容，会产生另一个处理器上的线程无法看到该处理器对共享数据的更新。

一个处理器的Cache不能读取另一个处理器的Cache，但是一个处理器可以通过缓存一致性协议来读取其他处理器缓存中的数据，并将读到的数据更新到该处理的Cache中，该过程称为缓存同步。缓存同步使得一个处理器上运行的线程可以读取到另外一个处理器上运行的的线程对共享数据的所做的更新，保障了可见性。为了保证可见性，必须使一个处理器对共享数据的更新最终被写入高处理器的Cache中，这个过程称为冲刷处理器缓存。

规定：每个线程之间的共享数据都存储在主内存中，每个线程都有一个私有的本地（工作）内存。线程的工作内存是抽象的概念，不是真实存在的，它涵盖写缓冲器、寄存器还有其他硬件的优化。每个线程从主内存中把数据读取到本地工作内存中，在工作内存中保存共享数据的副本。线程在自己的工作内存中处理数据，仅对当前线程课件，对其他线程是不可见的。
\chapter{线程同步}
\section{线程同步机制简介}
线程同步机制是一套用于协调线程之间的数据访问机制。该机制可以保障线程安全。

Java平台提供的线程同步机制包括：锁，\dm{volatile}关键字，\dm{final}关键字，\dm{static}关键字以及相关的API，如\dm{Object.wait()}，\dm{Object.notify()}等。
\section{锁}
线程安全问题是多个线程并发访问共享数据。

将多个线程对共享数据的并发访问转换为串行访问，即一个共享数据一次只能被一个线程访问。锁就是利用这种思路来保证线程安全的。

锁(Lock)可以理解为对共享数据进行保护的一个许可证，对于同一个许可证保护的共享数据来说，任何线程想要访问这个共享数据，必须先持有该许可证。一个线程只有在持有许可证的情况下才能对这些共享数据进行访问，并且一个许可证一次只能被一个线程持有。许可证线程在结束对共享数据的访问后必须释放其持有的许可证。

一个线程在访问共享数据前必须先获得锁，获得锁的线程称为锁的持有线程，一个锁一次只能被一个线程持有。锁的持有线程在获得锁之后和释放锁之前这段时间所执行的代码称为临界区（Critical Section）。

锁具有排他性：一个锁一次只能被一个线程持有。这种锁称为互斥锁，排它锁。

JVM把锁分为内部锁和显示锁。内部锁通过\dm{synchronized}关键字实现；显示锁通过\\
\dm{java.concurrent.locks.Lock}接口的实现类实现的.

\subsection{锁的作用}
锁可以实现对共享数据的安全访问。保障线程的原子性、可见性、与有序性。

锁是通过互斥保障原子性。

可见性的保障是通过写线程冲刷处理器的缓存和读线程刷新处理器缓存两个动作实现的。在Java平台中，锁的获得隐含着刷新处理器缓存的动作。锁的释放隐含着冲刷处理器缓存的动作。

锁能够保障有序性。写线程在临界区执行的操作在读线程所执行的临界区看来像是完全按照源码顺序执行的。

使用锁保障线程的安全性，必须满足以下条件：
\begin{itemize}
  \item 这些线程在访问共享数据时必须使用同一个锁。
  \item 即使是读取共享数据的线程也需要使用同步锁。
\end{itemize}
\subsection{锁相关的概念}
\begin{itemize}
  \item 可重入性：一个线程持有该锁的时候能再次（多次）申请该锁。如果一个线程持有一个锁的时候还能够继续成功申请该锁，称该锁是可重入的，否则就称该锁为不可重入的。
  \item 锁的争用与调度：Java平台中内部锁属于非公平锁，显式Lock锁既支持公平锁又支持非公平锁。
  \item 锁的粒度：一个锁可以保护的共享数据的数量大小称为锁的粒度。锁保护的共享数据量大，称该锁的粒度粗，否则就称该锁的粒度细。锁的粒度过粗会导致线程在申请锁的时候进行不必要的等待。锁的粒度过细会增加锁调度的开销。
\end{itemize}
\section{内部锁：\dm{synchronized}关键字}
Java中的每个对象都有一个与之关联的内部锁(Intrinsic lock)，这种锁也称为监视器(Monitor)。这种内部锁是一种排它锁，可以保障原子性、可见性、有序性。

内部锁是通过\dm{synchronized}关键字实现的。\dm{synchronized}关键字可以修饰代码块，修饰方法。

修饰代码块语法：
\begin{lstlisting}
synchronized( 对象锁 ){
    同步代码块，可以在同步代码块中访问共享数据
}
\end{lstlisting}

修饰实例方法就称为同步实例方法。

修饰类方法就称为同步类方法。
\subsection{\dm{synchronized}同步代码块}
\begin{lstlisting}
/**
 * synchronized 同步代码块
 */
public class Test01 {
    public static void main(String[] args) {
        //创建两个线程分别调用mm方法
        //先创建一个Test01对象，通过对象名调用mm()
        Test01 test01 = new Test01();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test01.mm();//使用的锁对象this就是test01对象
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test01.mm();//使用的锁对象this也是test01对象
            }
        }).start();
    }
    /**
     * 打印100行字符串
     */
    public  void mm(){
        synchronized (this) {//经常使用当前对象作为锁对象
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + "--->" + (i + 1));
            }
        }
    }
}
\end{lstlisting}

对于不同的锁则不能实现同步
\begin{lstlisting}
/**
 * synchronized 同步代码块
 * 如果线程的锁不同，则不能实现同步。
 * 想要同步必须使用同一个锁对象
 */
public class Test02 {
    public static void main(String[] args) {
        //创建两个线程分别调用mm方法
        //先创建一个Test01对象，通过对象名调用mm()
        Test02 test01 = new Test02();
        Test02 test02 = new Test02();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test01.mm();//使用的锁对象this就是test01对象
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test02.mm();//使用的锁对象this就是test02对象
            }
        }).start();
    }
    /**
     * 打印100行字符串
     */
    public  void mm(){
        synchronized (this) {//经常使用当前对象作为锁对象
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + "--->" + (i + 1));
            }
        }
    }
}
\end{lstlisting}
\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
/**
 * synchronized 同步代码块
 * 锁对象也可以是常量
 */
public class Test03 {
    public static void main(String[] args) {
        //创建两个线程分别调用mm方法
        //先创建一个Test01对象，通过对象名调用mm()
        Test03 test01 = new Test03();
        Test03 test02 = new Test03();


        new Thread(new Runnable() {
            @Override
            public void run() {
                test01.mm();//使用的锁对象是常量对象OBJ
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test02.mm();//使用的锁对象是常量对象OBJ
            }
        }).start();
    }
    public static final Object OBJ = new Object();//定义一个常量
    /**
     * 打印100行字符串
     */
    public  void mm(){
        synchronized (OBJ) {//可以使用常量对象作为锁对象
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + "--->"
                 + (i + 1));
            }
        }
    }
}
\end{Verbatim}

不管是实例方法还是类方法，只要是同一个锁对象都能实现线程同步。

\subsection{\dm{synchronized}修饰实例方法}
\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
/**
 * synchronized 同步实例方法
 * 把整个方法体作为同步代码块
 * 默认的锁对象是this对象
 */
public class Test05 {
    public static void main(String[] args) {
        //创建两个线程分别调用mm方法
        //先创建一个Test01对象，通过对象名调用mm()
        Test05 test01 = new Test05();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test01.mm();//使用的锁对象this就是test01对象
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test01.mm1();//使用的锁对象this也是test01对象
            }
        }).start();
    }

    /**
     * 打印100行字符串
     */
    public void mm() {
        synchronized (this) {//经常使用当前对象作为锁对象
            System.out.println("修饰代码块");
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + "--->"
                + (i + 1));
            }
        }
    }
    //使用synchronized修饰实例方法，同步实例方法，默认this作为锁对象
    public synchronized void mm1() {
        System.out.println("修饰方法");
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "--->"
            + (i + 1));
        }
    }
}
\end{Verbatim}
\subsection{\dm{synchronized}修饰类方法}
\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
/**
 * synchronized 同步类方法
 * 把整个方法体作为同步代码块
 * 默认的锁对象是当前类的运行时类对象，又称之为类锁
 */
public class Test06 {
    public static void main(String[] args) {
        //创建两个线程分别调用mm方法
        //先创建一个Test01对象，通过对象名调用mm()
        Test06 test01 = new Test06();
        Test06 test02 = new Test06();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test01.mm();//使用当前类的运行时类作为锁对象
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test02.sm1();//使用当前类的运行时类作为锁对象
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                sm();
            }
        }).start();
    }

    public static final Object OBJ = new Object();//定义一个常量

    /**
     * 打印100行字符串
     */
    public void mm() {
        synchronized (Test06.class) {//可以使用使用当前类的运行时类作为锁对象
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() +
                "--->" + (i + 1));
            }
        }
    }

    public static void sm() {
        synchronized (Test06.class) {//可以使用当前类的运行时类作为锁对象。
            System.out.println("静态方法");
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() +
                "--->" + (i + 1));
            }
        }
    }

    public synchronized static void sm1() {
//         synchronized (OBJ) {//可以使用常量对象作为锁对象
        System.out.println("修饰静态方法");
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() +
            "--->" + (i + 1));
//            }
        }
    }
}
\end{Verbatim}
\subsection{线程异常}
同步时，若线程出现异常，则会自动释放锁。
\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
/**
 * synchronized 同步类方法
 * 同步时，某个线程出现异常，则该线程会释放锁
 */
public class Test08 {
    public static void main(String[] args) {
        //创建两个线程分别调用mm方法
        //先创建一个Test01对象，通过对象名调用mm()
        Test08 test01 = new Test08();
        Test08 test02 = new Test08();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test01.mm();//使用当前类的运行时类作为锁对象
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test02.sm1();//使用当前类的运行时类作为锁对象
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                sm();
            }
        }).start();
    }

    public static final Object OBJ = new Object();//定义一个常量

    /**
     * 打印100行字符串
     */
    public void mm() {
        synchronized (Test08.class) {//可以使用使用当前类的运行时类作为锁对象
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() +
                "--->" + (i + 1));
                if (i == 20) {
                    System.out.println(Integer.parseInt("a"));//产生异常的语句
                }
            }

        }
    }

    public static void sm() {
        synchronized (Test08.class) {//可以使用当前类的运行时类作为锁对象。
            System.out.println("静态方法");
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() +
                "--->" + (i + 1));
            }
        }
    }

    public synchronized static void sm1() {
//         synchronized (OBJ) {//可以使用常量对象作为锁对象
        System.out.println("修饰静态方法");
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() +
             "--->" + (i + 1));
//            }
        }
    }
}
\end{Verbatim}
\subsection{死锁}
\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
/**
 * @program: DataStructures
 * @description
 *  死锁演示
 *      多线程中，同步可能需要多个锁，如果获得锁的顺序不一致，可能会导致死锁
 * @author:戛剑生
 * @creat: 2021-03-05 08:35:48
 **/
public class Test09 {
    public static void main(String[] args) {
        SubThread subThread1 = new SubThread();
        subThread1.setName("a");
        subThread1.start();
        SubThread subThread2 = new SubThread();
        subThread2.setName("b");
        subThread2.start();
    }
    static class SubThread extends Thread{
        private static final Object LOCK1 = new Object();
        private static final Object LOCK2 = new Object();
        @Override
        public void run() {
            if ("a".equals(Thread.currentThread().getName())){
                synchronized (LOCK1){
                    System.out.println
                        ("a线程获得LOCK1锁，还需要获得LOCK2锁！");
                    synchronized (LOCK2){
                        System.out.println
                            ("a线程获得LOCK1锁后获得LOCK2锁！");
                    }
                }
            }

            if ("b".equals(Thread.currentThread().getName())){
                synchronized (LOCK2){
                    System.out.println
                        ("b线程获得LOCK2锁，还需要获得LOCK1锁！");
                    synchronized (LOCK1){
                        System.out.println
                            ("b线程获得LOCK2锁后获得LOCK1锁！");
                    }
                }
            }
        }
    }
}
\end{Verbatim}

上述代码中，如果线程a启动，同时线程b启动，线程a拿到\dm{LOCK1}，线程b拿到\dm{LOCK2}，线程a若要执行完临界区代码，则需拿到\dm{LOCK2}，而线程b若要执行完临界区代码，则需拿到\dm{LOCK1}，由于\dm{LOCK2}被线程b占用，线程a则需等待，无法继续执行，则无法释放锁\dm{LOCK1}，同理线程b也无法释放锁\dm{LOCK2}，造成死锁。

如何避免死锁？

当需要获得多个锁时，所有线程锁的获得顺序保持一致即可。
\section{轻量级同步机制\dm{volative}关键字}
\subsection{\dm{volative}的作用}
该关键字的作用是使变量在多个线程之间可见。

解决变量的可见性：\dm{volative}关键字强制线程从公共内存中读取变量的值而不是从工作内存中读取。
\subsubsection{\dm{volative}与\dm{synchronize}关键字比较}
1.\dm{volative}关键字是线程同步的一个轻量级实现，性能好于\dm{synchronize}。

2.\dm{volative}只能修饰变量，\dm{synchronize}可以修饰方法、代码块，随着JDK新版本的发布，\\ \dm{synchronize}的执行效率也有较大的提升。在开发中使用\dm{synchronize}的比率还是很大的。

3.多线程访问\dm{volative}变量不会发生阻塞，而\dm{synchronize}可能会阻塞。

4.\dm{volative}能保证数据的可见性，但不能保证原子性。而\dm{synchronize}可以保证原子性，也可以保证可见性。

5.\dm{volative}解决的是变量在多个线程的可见性，\dm{synchronize}解决多个线程访问公共资源的同步性。
\subsection{\dm{volative}的非原子特性}
\dm{volative}增加了实例变量在多个线程的可见性，但是不具备原子性。
\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
public class Test03 {
    public static void main(String[] args) {
//        SubThread subThread = new SubThread();
        for (int i = 0; i < 10; i++) {
            new SubThread().start();
        }
    }
    static class SubThread extends Thread{
        //volatile关键字仅仅是表示所有线程从主内存中读取count变量的值
        //某个线程未运行结束，其他线程可能会抢到CPU执行权，无法保证原子性
        public  volatile static int count;
        public static void addCount(){
            for (int i = 0; i < 1000; i++) {
                count++;
            }
            System.out.println(Thread.currentThread().getName()
            + "count" + count);
        }
        //必须使用synchronized保证原子性
        public synchronized static void addCount1(){
            for (int i = 0; i < 1000; i++) {
                count++;
            }
            System.out.println(Thread.currentThread().getName()
            + "count" + count);
        }
        @Override
        public void run() {
            addCount1();
        }
    }
}
\end{Verbatim}
\subsection{常用的原子类进行自增自减操作}
\dm{i++}操作不是原子操作，除了使用\dm{synchronize}进行同步外，也可以使用\dm{AtomicInteger}和\\ \dm{AtomicLong}原子类进行实现。
\begin{lstlisting}
//使用AtomicInteger对象
static private AtomicInteger count = new AtomicInteger();
count.getAndIncrement();//相当于++count;
count.incrementAndGet();//相当于count++;
\end{lstlisting}
\section{CAS}
CAS(Compare And Swap)是由硬件实现的。

CAS可以将read-modify-write这类操作转换为原子操作。

\dm{i++}自增操作包括三个子操作:
\begin{itemize}
  \item 读取\dm{i}变量值
  \item 对\dm{i}的值+1
  \item 把\dm{i}加1之后的值保存到主内存
\end{itemize}
CAS原理：在把数据更新到主内存时，再次读取主内存变量的值\dm{value}，如果现在变量的值\dm{value}与期望的值（操作起始时读取的值\dm{expectedValue}）一样就更新。
\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
public class CASTest {
    public static void main(String[] args) {
        CASCounter casCounter = new CASCounter();
        for (int i = 0; i < 100; i++) {
            new Thread(new Runnable(){
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName()
                        + "count" + casCounter.incrementAndGet());
                }
            }).start();

        }
        //System.out.println(casCounter.getValue());
    }
}

class CASCounter {
    //使用volatile修饰value值，使线程可见
    volatile private long value;

    public long getValue() {
        return value;
    }

    //定义一个compare and swap方法

    /**
     *
     * @param expectValue   是自增前主内存的值
     * @param newValue  自增后的值
     * @return
     */
    private boolean compareAndSwap(long expectValue, long newValue) {
        //如果value的值与期望的expectedValue值一样
        //就把当前的value字段替换为newValue值
        synchronized (this) {
            if (value == expectValue){
                this.value = newValue;
                return true;
            }
            return false;
        }
    }

    //定义自增的方法
    public long incrementAndGet(){
        long oldValue;
        long newValue;
        do {
            oldValue = value;
            newValue = oldValue + 1;
        }while (!compareAndSwap(oldValue,newValue));
        return newValue;
    }
}
\end{Verbatim}

CAS 实现原子操作背后有一个假设：共享变量的当前值与当前线程提供的期望值相同，就认为这个变量没有被其他线程修改过。实际上该假设不一定总是成立。
\subsection{ABA问题}
ABA问题是CAS机制中出现的一个问题：一个线程把数据A变为B然后又重新变为A，此时另外一个线程读取时，发现仍然是A，就误以为该数据没有改变过。

规避方法：为共享变量引入一个修订号（时间戳），每次修改共享变量时，相应的修订号就会增加1。通过对修订号就可以准确的判断变量是否被其他线程修改过。\dm{AtomicStampedReference}类就是基于这种思想实现的。
\section{原子变量类}
原子变量类是基于CAS实现的，当对共享变量进行read-modify-write更新操作时，通过原子变量类可以保障操作的原子性与可见性。对变量进行read-modify-write更新操作是指当前的操作不是一个简单的操作，而是变量的新值依赖变量的旧值。如自增自减操作。\dm{volatile}只能保证可见性，无法保证原子性，原子变量类内部就是借助一个\dm{volatile}变量，并且保证了该变量的read-modify-write操作的原子性，有时把原子变量看作增强的\dm{volatile}变量。

原子变量类有12个：
\begin{itemize}
  \item 基础数据型：\dm{AtomicInteger},\dm{AtomicLong},\dm{AtomicBoolean}
  \item 数组型：\dm{AtomicIntegerArray},\dm{AtomicLongArray},\dm{AtomicReferenceArray}
  \item 字段更新器：\dm{AtomicIntegerFieldUpdater},\dm{AtomicLongFieldUpdater},\dm{AtomicReferenceFieldUpdater}
  \item 引用型：\dm{AtomicReference}，\dm{AtomicStampedReference}，\dm{AtomicMarkableReference}
\end{itemize}
\subsection{\dm{AtomicLong}}
代码如下：

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
import java.util.concurrent.atomic.AtomicLong;

/**
 * @program: DataStructures
 * @description 使用原子变量类定义一个计数器
 * 该计数器在整个程序中都可以使用，所有的地方都使用这一个计数器
 * 这个计数器就可以设计为单例
 * @author:戛剑生
 * @creat: 2021-03-05 14:38:30
 **/
public class Indicator {
    //构造方法私有化
    private Indicator() {
    }

    //定义一个私有的本类静态的对象
    private static final Indicator INSTANCE = new Indicator();

    //提供一个公共静态的方法返回该类唯一实例
    public static Indicator getInstance() {
        return INSTANCE;
    }

    //使用源自变量类保存请求总数
    private final AtomicLong requestCount = new AtomicLong(0);//记录请求总数
    private final AtomicLong successCount = new AtomicLong(0);//记录处理成功总数
    private final AtomicLong failCount = new AtomicLong(0);//记录处理失败总数

    //有新的请求
    public void newRequestReceive() {
        requestCount.incrementAndGet();
    }

    //处理成功的
    public void requestProcessSuccess() {
        successCount.incrementAndGet();
    }

    //处理失败的
    public void requestProcessFail() {
        failCount.incrementAndGet();
    }

    //查看总数，成功数，失败数
    public long getRequestCount() {
        return requestCount.get();
    }

    public long getSuccessCount() {
        return successCount.get();
    }

    public long getFailCount() {
        return failCount.get();
    }
}

import java.util.Random;

/**
 * @program: DataStructures
 * @description
 *      模拟服务器的请求总数，处理成功数，处理失败数
 * @author:戛剑生
 * @creat: 2021-03-05 14:35:15
 **/
public class Test {
    public static void main(String[] args) {
        //通过线程模拟请求
        //在实际应用中可以在ServletFilter中调用Indicator计数器相关方法
        for (int i = 0; i < 10000; i++) {
            int finalI = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    //每个线程就是一个请求
                    //请求总数要加1
                    Indicator.getInstance().newRequestReceive();
                int num = new Random().nextInt( );
                if (num % 2 == 0){//用随机数模拟请求成功或失败，
                    //偶数表示成功
                    Indicator.getInstance().requestProcessSuccess();
                }else{
                    Indicator.getInstance().requestProcessFail();
                }
                }
            }).start();
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            System.out.println(e.getMessage());
        }
        System.out.println("发起的总请求数：" +
            Indicator.getInstance().getRequestCount());
        System.out.println("发起的成功请求数：" +
            Indicator.getInstance().getSuccessCount());
        System.out.println("发起的失败请求数：" +
            Indicator.getInstance().getFailCount());
    }
}
\end{Verbatim}
\subsection{\dm{AtomicIntegerArray}}
原子更新数组。

代码如下：
\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
import java.util.concurrent.atomic.AtomicIntegerArray;

/**
 * @program: DataStructures
 * @description
 *      在多线程中使用AtomicIntegerArray原子数组
 * @author:戛剑生
 * @creat: 2021-03-05 15:33:14
 **/
public class Test02 {
    //定义原子数组
    static AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(10);
    public static void main(String[] args) {
        //定义线程数组
        Thread[] threads = new Thread[10];
        //给线程数组的每个线程赋值
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new AddThread();
        }
        //开启子线程
        for (Thread thread:
             threads) {
            thread.start();
        }

        //在所有子线程执行完后查看原子数组中各个元素的值
        //把所有的子线程合并到当前的主线程中
        for (Thread thread:
                threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(atomicIntegerArray);
    }
    //定义一个线程类，在线程类中修改原子数组
    static class AddThread extends Thread{

        @Override
        public void run() {
            //把原子数组的每个元素自增1000次
            for (int i = 0; i < 1000; i++) {
                for (int j = 0; j < atomicIntegerArray.length(); j++) {
                    atomicIntegerArray.getAndIncrement(j);
                }
            }

        }
    }
}
\end{Verbatim}
\subsection{\dm{AtomicIntegerFieldUpdater}}
\dm{AtomicIntegerFieldUpdater}可以对原子整数字段进行更新。要求：
\begin{itemize}
  \item 字符必须使用\dm{volatile}修饰,使得线程之间可见。
  \item 只能是实例变量不能是静态变量，也不能使用\dm{final}修饰。
\end{itemize}

代码实现

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
public class User {
    int id;
    volatile int age;

    public User(int id, int age) {
        this.id = id;
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", age=" + age +
                '}';
    }
}

public class SubThread extends Thread{
    private User user;//要更新的User对象
    //创建一个AtomicIntegerFieldUpdater更新器
    //AtomicIntegerFieldUpdater是抽象类，不能直接创建对象
    private AtomicIntegerFieldUpdater<User> updater =
            AtomicIntegerFieldUpdater.newUpdater(User.class,"age");

    public SubThread(User user) {
        this.user = user;
    }

    @Override
    public void run() {
        //在子线程中对user对象的age字段自增
        for (int i = 0; i < 10; i++) {
            System.out.println(updater.getAndIncrement(user));
        }
    }
}

public class Test {
    public static void main(String[] args) {
        User user = new User(12, 10);
        //开启十个线程
        for (int i = 0; i < 10; i++) {
            new SubThread(user).start();
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(user);
    }
}
\end{Verbatim}
\subsection{\dm{AtomicReference}}
可以原子读写一个引用类型的数据。

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
import java.util.concurrent.atomic.AtomicReference;

public class Test01 {
    public static void main(String[] args) {
        //创建100个子线程修改字符串
        for (int i = 0; i < 100; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    if (atomicReference.compareAndSet("abcd", "def")) {
                        System.out.println(Thread.currentThread().getName()
                            + "把字符串更改为def");
                    }
                }
            }).start();
        }
        //创建100个子线程修改字符串
        for (int i = 0; i < 100; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    if (atomicReference.compareAndSet("def", "abcd")) {
                        System.out.println(Thread.currentThread().getName()
                            + "把字符串更改为abcd");
                    }
                }
            }).start();
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(atomicReference.get());
    }

    //创建一个AtomicReference对象
    static AtomicReference<String> atomicReference =
        new AtomicReference<>("abcd");
}\end{Verbatim}

ABA问题

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
package com.atWSN.atomics.atomicReference;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

/**
 * @program: DataStructures
 * @description 演示AtomicReference的ABA问题
 * @author:戛剑生
 * @creat: 2021-03-05 16:38:25
 **/
public class Test02 {
    private static AtomicReference<String> atomicReference
            = new AtomicReference<>("abc");

    public static void main(String[] args) {
        //创建第一个线程，先把abc字符串改为def再把字符串还原为abc
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                atomicReference.compareAndSet("abc", "def");
                System.out.println(Thread.currentThread().getName() +
                        "---->" + atomicReference.get());
                atomicReference.compareAndSet("def", "abc");
            }
        });
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    TimeUnit.SECONDS.sleep(1l);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(atomicReference.compareAndSet
                        ("abc", "xyz"));
            }
        });
        t1.setName("t1");
        t2.setName("t2");
        t1.start();
        t2.start();

        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(atomicReference.get());
    }
}
\end{Verbatim}

使用时间戳解决ABA问题

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicStampedReference;

/**
 * @program: DataStructures
 * @description 使用AtomicStampedReference解决ABA问题
 * 在AtomicStampedReference有一个整数标记值stamp
 * 每次执行CAS操作时，都要对比它的版本，即比较stamp的值
 * @author:戛剑生
 * @creat: 2021-03-05 17:03:16
 **/
public class Test03 {
    //    private static AtomicReference<String> atomicReference
//            = new AtomicReference<>("abc");
    //定义AtomicStampedReference引用操作"abc"字符串，指定初始化版本号为0
    private static AtomicStampedReference<String> atomicStampedReference
            = new AtomicStampedReference<>("abc", 0);

    public static void main(String[] args) {
//创建第一个线程，先把abc字符串改为def再把字符串还原为abc
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                //每次修改，版本号加1
                atomicStampedReference.compareAndSet
                        ("abc", "def",
                                atomicStampedReference.getStamp(),
                        atomicStampedReference.getStamp() + 1);
                System.out.println(Thread.currentThread().getName()
                        + "--" + atomicStampedReference.getReference());
                atomicStampedReference.compareAndSet("def",
                        "abc", atomicStampedReference.getStamp(),
                        atomicStampedReference.getStamp() + 1);
            }
        });
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                int stamp = atomicStampedReference.getStamp();//获得版本号
                try {
                    TimeUnit.SECONDS.sleep(1l);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println(atomicStampedReference.
                        compareAndSet("abc",
                                "xyz",stamp,stamp+1));
            }
        });
        t1.setName("t1");
        t2.setName("t2");
        t1.start();
        t2.start();

        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(atomicStampedReference.getReference());
    }
}\end{Verbatim}
\chapter{线程间通信}
\section{等待/通知机制}
\subsection{什么是等待/通知机制}
在单线程编程中，要执行的操作需要满足一定条件才能执行，可以把这个操作放在\dm{if}语句块中。

在多线程编程中，可能某一线程A条件没有满足，只是暂时的，稍后其他线程B可能会更新该条件使得A线程的条件得到满足。可以将A线程暂停，直到它的条件得到满足后，再将A线程唤醒。伪代码：
\begin{lstlisting}
atomics{    //原子操作
    while(条件不成立){
        等待；
    }

    当前线程被唤醒条件满足后，继续执行下面的操作
}
\end{lstlisting}
\subsection{等待/通知机制的实现}
\subsubsection{\dm{wait()}方法}
\dm{Object}类中的\dm{wait()}方法可以使执行当前代码的线程等待，暂停执行，直到接到通知或被中断为止。

注意：
\begin{itemize}
  \item \dm{wait()}方法只能在同步代码块中由锁对象调用。
  \item 调用\dm{wait()}方法后，当前线程会暂停并立即释放锁。
\end{itemize}
\begin{lstlisting}
//在调用wait()方法前获得对象的内部锁
synchronized(锁对象){
    while(条件){//该条件不成立
        //通过锁对象调用wait()方法暂停线程
        锁对象.wait()
    }
    //线程的条件满足了继续向下执行
}
\end{lstlisting}

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
/**
 * @program: DataStructures
 * @description
 *      wait()会使线程等待
 *      需要放在同步代码块中通过锁对象调用
 * @author:戛剑生
 * @creat: 2021-03-05 21:07:28
 **/
public class Test02 {
    public static void main(String[] args) {
        try {
            String test  = "aaa";
            System.out.println("同步前");
            synchronized (test){
                System.out.println("同步代码块开始！");
                //需要通过锁对象调用
                //不是锁对象调用会产生ILegalMonitorStateException异常
                test.wait();    // 调用wait方法后当前线程就会等待同时释放锁对象
                //当前线程需要被唤醒
                //如果没有唤醒就会一直等待
                System.out.println("wait后边的代码！");
            }
            System.out.println("同步代码块后边的代码");
        }catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("main后边的其他代码……");
    }
}\end{Verbatim}
\subsubsection{\dm{notify()}方法}
\dm{Object}类中的\dm{notify()}方法可以唤醒线程，该方法也必须在同步代码块中由锁对象调用，没有使用锁对象调用\dm{wait()}/\dm{notify()}会抛出\dm{ILegalMonitorStateException}异常。如果有多个等待的线程，\dm{notify()}需要等当前同步代码块执行完后才会释放锁对象，所以一般将\dm{noyify()}方法放在同步代码块的最后。它的伪代码如下
\begin{lstlisting}
synchronized(锁对象){
    //执行修改保护条件的代码
    //唤醒其他线程
    锁对象.notify();
}
\end{lstlisting}

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
/**
 * @program: DataStructures
 * @description 需要通过notify()唤醒等待的线程
 * @author:戛剑生
 * @creat: 2021-03-05 21:18:43
 **/
public class Test03 {
    public static void main(String[] args) {
        final String LOCK = "lock";//定义一个字符串作为锁对象
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (LOCK) {
                    System.out.println(Thread.currentThread().getName() 
                        + "开始等待" + System.currentTimeMillis());
                    try {
                        LOCK.wait();//线程等待，会释放锁对象
                                    //当前线程转入WAITING等待状态
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() 
                        + "结束等待" + System.currentTimeMillis());
                }
            }
        });
        t1.setName("t1");

        //定义第二个线程负责唤醒第一个线程
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                //notify()方法也需要在同步代码块中由锁对象调用
                synchronized (LOCK) {
                    System.out.println(Thread.currentThread().getName() 
                        + "开始唤醒" + System.currentTimeMillis());

                    LOCK.notify();//唤醒在LOCK锁对象上等待的某一个线程
                    //
                    System.out.println(Thread.currentThread().getName() 
                        + "结束唤醒" + System.currentTimeMillis());
                }
            }
        });
        t2.setName("t2");

        t1.start();//开启t1线程，t1线程等待
        try {
            Thread.sleep(3000);//为了确保等待，让主线程睡3s
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t2.start();//t1线程开启3秒后，再开启t2线程唤醒t1线程
    }
}\end{Verbatim}

\dm{notify()}不会立即释放锁对象

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
import java.util.ArrayList;
import java.util.List;

/**
 * @program: DataStructures
 * @description notify()不会立即释放锁对象
 * @author:戛剑生
 * @creat: 2021-03-05 21:18:43
 **/
public class Test04 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
//        final String list = "lock";//定义一个字符串作为锁对象
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (list) {
                    System.out.println(Thread.currentThread().getName() 
                        + "开始运行" + System.currentTimeMillis());
                    try {
                        if (list.size() != 5) {
                            list.wait();
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() 
                        + "结束运行" + System.currentTimeMillis());
                }
            }
        });
        t1.setName("t1");

        //定义第二个线程负责唤醒第一个线程
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                //notify()方法也需要在同步代码块中由锁对象调用
                synchronized (list) {
                    System.out.println(Thread.currentThread().getName() 
                        + "运行开始" + System.currentTimeMillis());
                    for (int i = 0; i < 10; i++) {
                        System.out.println(Thread.currentThread().getName() 
                            + "添加第" + (i + 1) + "个数据");
                        list.add("data -- " + (i + 1));
                        if (list.size() == 5) {
                            list.notify();
                            System.out.println
                                (Thread.currentThread().getName() 
                                    + "已发出唤醒通知");
                        }
                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                    }

                    //
                    System.out.println(Thread.currentThread().getName() 
                        + "运行结束" + System.currentTimeMillis());
                }
            }
        });
        t2.setName("t2");

        t1.start();//开启t1线程，t1线程等待
        try {
            Thread.sleep(3000);//为了确保等待，让主线程睡3s
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t2.start();//t1线程开启3秒后，再开启t2线程唤醒t1线程
    }
}
\end{Verbatim}
\subsection{\dm{interrupt()}方法会中断\dm{wait()}}
当线程处于\dm{wait()}等待状态时，调用线程对象的\dm{interrupt()}方法会中断线程的等待状态。\dm{wait()}被中断会产生\dm{InterruptException}。

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
package com.atWSN.thread.wait;

/**
 * @program: DataStructures
 * @description
 *      中断线程会唤醒线程的等待
 * @author:戛剑生
 * @creat: 2021-03-06 08:26:07
 **/
public class Test05 {
    public static void main(String[] args) {
        SubThread subThread = new SubThread();
        subThread.setName("t");
        subThread.start();

        try {
            Thread.sleep(2000);//主线程睡眠2秒，确保子线程处于wait()状态
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        subThread.interrupt();
    }

    static private final Object OBJ = new Object();

    static class SubThread extends Thread {
        @Override
        public void run() {
            synchronized (OBJ) {
                try {
                    System.out.println(Thread.currentThread().getName() 
                        + "开始等待");
                    OBJ.wait();
                    System.out.println(Thread.currentThread().getName() 
                        + "结束等待");
                } catch (InterruptedException e) {
//                    e.printStackTrace();
                    System.out.println("wait等待被中断了");
                    System.out.println(e.getMessage());
                }
            }
        }
    }
}\end{Verbatim}
\subsection{\dm{notify()}与\dm{notifyAll()}}
\dm{notify()}一次只能唤醒一个线程，如果有多个等待的线程，只能随机的唤醒其中的某一个；想要唤醒所有等待的线程，需要调用\dm{notifyAll()}

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
/**
 * @program: DataStructures
 * @description
 *      notifyAll唤醒所有等待的线程
 * @author:戛剑生
 * @creat: 2021-03-06 08:47:17
 **/
public class Test06 {
    public static void main(String[] args) {
        Object LOCK = new Object();
        SubThread t1 = new SubThread(LOCK);
        t1.setName("t1");
        SubThread t2 = new SubThread(LOCK);
        t2.setName("t2");
        SubThread t3 = new SubThread(LOCK);
        t3.setName("t3");
        SubThread t4 = new SubThread(LOCK);
        t4.setName("t4");

        t1.start();
        t2.start();
        t3.start();
        t4.start();

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //唤醒子线程
        synchronized (LOCK){
            LOCK.notify();//调用一次notify只能随机唤醒其中一个线程
            //其他等待的线程依然处于等待状态
            //对于处于等待状态的线程来说，错过了通知信号，这种现象也称为信号丢失
        }
        //唤醒全部子线程
        synchronized (LOCK){
            LOCK.notifyAll();//调用一次notifyAll唤醒其中所有线程
        }
    }
    static class SubThread extends Thread{
        private Object LOCK;

        public SubThread(Object LOCK) {
            this.LOCK = LOCK;
        }

        @Override
        public void run() {
            synchronized (LOCK){
                try {
                    System.out.println(Thread.currentThread().getName() 
                        + "开始等待！");
                    LOCK.wait();
                    System.out.println(Thread.currentThread().getName() 
                        + "结束等待！");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }
    }
}\end{Verbatim}
\subsection{\dm{wait(long)}的使用}
\dm{wait(long)}是带有\dm{long}类型参数的\dm{wait()}等待，如果在参数指定的时间内没有被唤醒。超时后会自动唤醒。

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
/**
 * @program: DataStructures
 * @description
 *      wait(long)
 * @author:戛剑生
 * @creat: 2021-03-06 19:35:45
 **/
public class Test07 {
    public static void main(String[] args) {
        final Object LOCK = new Object();
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (LOCK){
                    System.out.println(Thread.currentThread().getName() 
                        + "开始等待！");
                    try {
                        LOCK.wait(5000);//如果5秒内没有被唤醒，会自动唤醒
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() 
                        + "结束等待！");
                }
            }
        });
        thread.setName("t1");
        thread.start();
    }
}
\end{Verbatim}
\subsection{通知过早}
线程\dm{wait()}后，可以调用\dm{notify()}唤醒线程，如果\dm{notify()}唤醒的过早，在等待之前就调用了\dm{notify()}，可能会打乱程序正常的执行逻辑。
\subsection{\dm{wait()}等待的条件发生了变化}
在使用\dm{wait}/\dm{notify()}模式时，注意\dm{wait}条件发生了变化，也可能会造成程序的逻辑混乱。

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
import java.util.ArrayList;
import java.util.List;

/**
 * @program: DataStructures
 * @description 定义一个集合
 * 定义一个线程向集合中添加数据，添加完数据后通知另外的线程从集合中取数据
 * 定义一个线程从集合中取数据，如果集合中没有数据就等待
 * @author:戛剑生
 * @creat: 2021-03-06 20:24:49
 **/
public class Test10 {
    public static final Object LOCK = new Object();
    //定义一个List集合
    static List list = new ArrayList<>();

    public static void main(String[] args) {
        Thread t1 = new Subtract();
        t1.setName("取数据的线程1");
        Thread t2 = new Add();
        t2.setName("添加数据的线程");
        //测1：先开启添加数据的线程，再开启一个取数据的线程
        //大多数情况下会正常取数据
//        t2.start();
//        t1.start();
        //测2：先开启取数据的线程，再开启添加数据的线程
        //取数据的线程会先等待，等到添加数据之后，再取数据
//        t1.start();
//        t2.start();
        //测3：开启两个取数据的线程，再开启添加数据的线程
        Thread t3 = new Subtract();
        t3.setName("取数据的线程2");
        t1.start();
        t3.start();
        t2.start();
        /**
         * 某次的执行结果如下
         * 取数据的线程1开始等待！
         * 取数据的线程2开始等待！
         * 添加数据的线程添加数据！
         * 添加数据的线程完成添加数据！
         * 取数据的线程2结束等待！
         * 取数据的线程2从集合中取了x后，集合中剩余的数据数量：0
         * 取数据的线程1结束等待！
         * Exception in thread "取数据的线程1" 
         * java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
         *
         * 出现异常的原因：向集合中添加了一次数据，但取了两次
         * 解决方案：等待的线程被唤醒后，再判断一次集合中是否有数据可取
         * 需要把subtract方法中的if改为while
         */
    }

    //定义方法从集合中取数据
    public static void subtract() {
        synchronized (LOCK) {
//            if (list.isEmpty()) {
            while (list.isEmpty()) {
                System.out.println(Thread.currentThread().getName() 
                    + "开始等待！");
                try {
                    LOCK.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() 
                    + "结束等待！");
            }
            Object data = list.remove(0);
            System.out.println(Thread.currentThread().getName() 
                + "从集合中取了" + data + "后，集合中剩余的数据数量：" 
                    + list.size());
        }
    }

    //向集合中添加数据
    //添加完2数据后，通知等待的线程取数据
    public static void add() {
        synchronized (LOCK) {
            System.out.println(Thread.currentThread().getName() 
                + "添加数据！");
            list.add("x");
            LOCK.notifyAll();
            System.out.println(Thread.currentThread().getName() 
                + "完成添加数据！");
        }
    }

    //定义线程类调用subtract
    static class Subtract extends Thread {
        @Override
        public void run() {
            subtract();
        }
    }

    //定义线程类调用add
    static class Add extends Thread {
        @Override
        public void run() {
            add();
        }
    }
}\end{Verbatim}
\subsection{生产者消费者模式}
Java中，负责生产数据的模块是生产者，负责使用数据的模块是消费者。生产者消费者解决数据的平衡问题，即先有数据，然后才能使用，没有数据时，消费者需要等待。
\subsubsection{生产者-消费者：操作数据}
\begin{lstlisting}[title=操作数据的类]
/**
 * @program: DataStructures
 * @description
 *      定义一个操作数据的类
 * @author:戛剑生
 * @creat: 2021-03-06 21:33:03
 **/
public class ValueOP {
    private String  value = "";
    //定义方法修改value字段的值
    public void setValue(){
        //如果value不是空串""，就等待
        synchronized (this){
            while (!value .equals("")){
                try {
                    System.out.println("当前有数据，无需生产");
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //如果是空串，就设置value字段的值
            String value = System.currentTimeMillis()+" - "+System.nanoTime();
            this.value = value;
            System.out.println("set设置的值是：" + value);
            System.out.println("生产成功");
            System.out.println();
            this.notifyAll();
        }
    }
    //定义方法读取value字段的值
    public void getValue(){
        synchronized (this){
            //如果字符串是空串就等待
            while (value .equals("")){
                System.out.println("没有数据可以取" + Thread.currentThread().getName() + "等待");
                System.out.println();
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //不是空串，读取字段的值
            System.out.println("get的值是：" + this.value);
            System.out.println("取数据结束");
            System.out.println();
            this.value = "";
            this.notifyAll();
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[title = 生产者]
/**
 * @program: DataStructures
 * @description
 *      生产者
 * @author:戛剑生
 * @creat: 2021-03-06 21:44:04
 **/
public class ProducerThread extends Thread{
    private ValueOP obj;

    public ProducerThread(ValueOP obj) {
        this.obj = obj;
    }

    @Override
    public void run() {
        while (true){
            System.out.println(Thread.currentThread().getName() + "正在生产");
            obj.setValue();
        }
    }
}
\end{lstlisting}
\begin{lstlisting}[title=消费者]
/**
 * @program: DataStructures
 * @description
 *      消费者
 * @author:戛剑生
 * @creat: 2021-03-06 21:44:04
 **/
public class ConsumerThread extends Thread{
    //消费者使用数据，就是使用ValueOP类的value字段值
    private ValueOP obj;

    public ConsumerThread(ValueOP obj) {
        this.obj = obj;
    }

    @Override
    public void run() {
        while (true){
            System.out.println(Thread.currentThread().getName() + "正在消费");
            obj.getValue();
        }
    }
}
\end{lstlisting}
\begin{lstlisting}[title=多生产者多消费者模型]
/**
 * @program: DataStructures
 * @description 测试多生产，多消费的情况
 * @author:戛剑生
 * @creat: 2021-03-06 21:32:37
 **/
public class Test02 {
    public static void main(String[] args) {
        ValueOP obj = new ValueOP();

        Thread producer1 = new ProducerThread(obj);
        Thread producer2 = new ProducerThread(obj);
        Thread producer3 = new ProducerThread(obj);
        Thread producer4 = new ProducerThread(obj);

        Thread consumer1 = new ConsumerThread(obj);
        Thread consumer2 = new ConsumerThread(obj);
        Thread consumer3 = new ConsumerThread(obj);
        Thread consumer4 = new ConsumerThread(obj);
        Thread consumer5 = new ConsumerThread(obj);
        Thread consumer6 = new ConsumerThread(obj);

        producer1.setName("生产者线程1");
        producer2.setName("生产者线程2");
        producer3.setName("生产者线程3");
        producer4.setName("生产者线程4");
        consumer1.setName("消费者线程1");
        consumer2.setName("消费者线程2");
        consumer3.setName("消费者线程3");
        consumer4.setName("消费者线程4");
        consumer5.setName("消费者线程5");
        consumer6.setName("消费者线程6");
        producer1.start();
        producer2.start();
        producer3.start();
        producer4.start();
        consumer1.start();
        consumer2.start();
        consumer3.start();
        consumer4.start();
        consumer5.start();
        consumer6.start();
        //结果：生产与消费交替运行
    }
}
\end{lstlisting}
\subsubsection{操作集合}
使生产者把数据存储到\dm{List}集合中，消费者从\dm{List}集合中取数据，使用\dm{List}集合模拟栈。
\begin{lstlisting}[title = 操作栈的类]
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * @program: DataStructures
 * @description
 * @author:戛剑生
 * @creat: 2021-03-07 08:08:29
 **/
public class MyStack {
    private List<String> list = new ArrayList<>();//定义一个集合模拟栈
    private static final int capacity = 2;//定义集合的最大容量
    private int size = 0;

    //定义方法模拟入栈
    public synchronized void push() {
        //栈中的数据已满，就等待
        while (list.size() >= capacity) {
            System.out.println("数据栈容量已满，无法存入数据，请等待！");
            System.out.println(Thread.currentThread().getName() + "开始等待！");
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "结束等待！");
        }
        String data = "data:" + new Random().nextInt(101);
        list.add(data);
        size++;
        System.out.println(Thread.currentThread().getName() + "添加了数据：" + data);
        this.notifyAll();
    }

    public synchronized void pop() {
        while (list.isEmpty()) {
            System.out.println("当前数据栈为空，无法取出数据！进入等待");
            System.out.println(Thread.currentThread().getName() + "开始等待");
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "结束等待");
        }
        String data = list.remove(size - 1);
        size--;
        System.out.println(Thread.currentThread().getName() + "取出了数据：" + data);
        this.notifyAll();
    }
}
\end{lstlisting}
\begin{lstlisting}[title = 生产者]
/**
 * @program: DataStructures
 * @description 生产者
 * @author:戛剑生
 * @creat: 2021-03-07 08:22:10
 **/
public class ProducerThread extends Thread{
    private MyStack myStack;
    public ProducerThread(MyStack myStack){
        this.myStack = myStack;
    }
    @Override
    public void run() {
        while (true){
            myStack.push();
        }
    }
}
\end{lstlisting}
\begin{lstlisting}[title = 消费者]
/**
 * @program: DataStructures
 * @description 消费者
 * @author:戛剑生
 * @creat: 2021-03-07 08:22:10
 **/
public class ConsumerThread extends Thread{
    private MyStack myStack;
    public ConsumerThread(MyStack myStack){
        this.myStack = myStack;
    }
    @Override
    public void run() {
        while (true){
            myStack.pop();
        }
    }
}
\end{lstlisting}
\begin{lstlisting}[title=多生产者多消费者模型测试]
public class Test02 {
    public static void main(String[] args) {
        MyStack obj = new MyStack();

        Thread producer1 = new ProducerThread(obj);
        Thread producer2 = new ProducerThread(obj);
        Thread producer3 = new ProducerThread(obj);
        Thread producer4 = new ProducerThread(obj);

        Thread consumer1 = new ConsumerThread(obj);
        Thread consumer2 = new ConsumerThread(obj);
        Thread consumer3 = new ConsumerThread(obj);
        Thread consumer4 = new ConsumerThread(obj);
        Thread consumer5 = new ConsumerThread(obj);
        Thread consumer6 = new ConsumerThread(obj);

        producer1.setName("生产者线程1");
        producer2.setName("生产者线程2");
        producer3.setName("生产者线程3");
        producer4.setName("生产者线程4");
        consumer1.setName("消费者线程1");
        consumer2.setName("消费者线程2");
        consumer3.setName("消费者线程3");
        consumer4.setName("消费者线程4");
        consumer5.setName("消费者线程5");
        consumer6.setName("消费者线程6");
        producer1.start();
        producer2.start();
        producer3.start();
        producer4.start();
        consumer1.start();
        consumer2.start();
        consumer3.start();
        consumer4.start();
        consumer5.start();
        consumer6.start();
        //结果：生产与消费交替运行
    }
}
\end{lstlisting}
\section{通过管道流实现线程间的通信}
在\dm{java.io}包中的\dm{PipeStream}管道流用于在线程之间传送数据，一个线程发送数据到输出管道，另一个线程从输入管道中读取数据。

相关的类包括：字节流\dm{PipedInputStream}和\dm{PipedOutputStream}，字符流\dm{PipedReader}和\dm{PipedWriter}.
\begin{lstlisting}
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;

/**
 * @program: DataStructures
 * @description：使用PipedInputStream和PipedOutputStream管道字节流在线程之间传递数据
 * @author:戛剑生
 * @creat: 2021-03-07 08:58:15
 **/
public class Test01 {
    public static void main(String[] args) {
        //定义管道字节流
        PipedInputStream pipedInputStream = new PipedInputStream();
        PipedOutputStream pipedOutputStream = new PipedOutputStream();
        try{
            pipedInputStream.connect(pipedOutputStream);
            //创造线程向管道流中写入数据
            new Thread(new Runnable(){
                @Override
                public void run() {
                    writeData(pipedOutputStream);
                }
            }).start();
            //创造线程从管道流中读取数据
            new Thread(new Runnable(){
                @Override
                public void run() {
                    readData(pipedInputStream);
                }
            }).start();
        }catch (Exception e){
            System.out.println(e.getMessage());
        }
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try {
                pipedOutputStream.close();
                pipedInputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
    }

    //定义方法向管道流中写入数据
    //从线程中把数据写入管道，需要一个输出流管道用于接收
    public static void writeData(PipedOutputStream out) {
        //分别把0~100之间的数写入管道中
        try {
            for (int i = 0; i < 100; i++) {
                String data = "" + (i + 1);
                out.write(data.getBytes());//把字节数组写入到输出管道流中
            }

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                out.close();//关闭管道流
            } catch (IOException e1) {
                e1.printStackTrace();
            }
        }
    }

    //定义方法从管道流中读取数据
    public static void readData(PipedInputStream in) {
        try {
            byte[] bytes = new byte[1024 * 4];
            int len = 0;
            while (true) {
                len = in.read(bytes);
                if (len == -1){
                    break;
                }
                System.out.println(new String(bytes,0,len));
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (IOException e1) {
                e1.printStackTrace();
            }
        }
    }
}
\end{lstlisting}
\section{\dm{ThreadLocal}的使用}
除了控制资源的访问外，还可以通过增加资源来保证线程安全，\dm{ThreadLocal}主要是解决为每个线程绑定自己的值。
\begin{lstlisting}
/**
 * @program: DataStructures
 * @description：ThreadLocal的使用
 * @author:戛剑生
 * @creat: 2021-03-07 09:47:26
 **/
public class Test {
    //定义一个ThreadLocal对象
    static ThreadLocal threadLocal = new ThreadLocal();

    //定义线程类
    static class SubThread extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 20; i++) {
                //设置线程关联的值
                threadLocal.set(Thread.currentThread().getName() + "-" + (i + 1));
                //调用get方法读取关联的值
                System.out.println(Thread.currentThread().getName() + " value = " + threadLocal.get());
            }
        }
    }

    public static void main(String[] args) {
        SubThread t1 = new SubThread();
        SubThread t2 = new SubThread();
        t1.setName("t1");
        t2.setName("t2");
        t1.start();
        t2.start();
    }
}
\end{lstlisting}
\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * @program: DataStructures
 * @description：在多线程环境中，把字符串转换为日期对象 
 * 多个线程使用同一个SimpleDateFormat对象可能会产生线程安全问题
 * 为每一个线程指定自己的SimpleDateFormat对象，使用ThreadLocal
 * @author:戛剑生
 * @creat: 2021-03-07 09:56:11
 **/
public class Test02 {
    //定义SimpleDateFormat对象，该对象可以字符串转换为日期
    private static SimpleDateFormat sdf = 
        new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
    static ThreadLocal<SimpleDateFormat> threadLocal = new ThreadLocal<>();

    static class ParseDate implements Runnable {
        private int i = 0;

        public ParseDate(int i) {
            this.i = i;
        }

        @Override
        public void run() {
            try {
                String str = (i % 60 < 10 ? ("0" + i % 60) : ("" + i % 60));
                String text = "2021年03月07日 09:56:" + str;//构建日期字符串
//                Date date = sdf.parse(text);//把字符串转换为日期
//                System.out.println(i + "-" + date);
                //先判断当前线程是否有SimpleDateFormat对象，
                //如果当前线程没有SimpleDateFormat对象就创建一个
                //如果有就直接使用
                if (threadLocal.get() == null) {
                    threadLocal.set
                        (new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss"));
                }
                Date date =threadLocal.get().parse(text);
                System.out.println(i + "-" + date);
            } catch (ParseException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        //创建100个线程
        for (int i = 0; i < 100; i++) {
            new Thread(new ParseDate(i)).start();
        }
    }
}
\end{Verbatim}
\subsection{初始化\dm{ThreadLocal}的值}
定义\dm{ThreadLocal}子类，在子类中重写\dm{initialValue()}为其指定初始值

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
import java.util.Date;
import java.util.Random;

/**
 * @program: DataStructures
 * @description ThreadLocal初始值:定义一个子类
 *              在子类中重写initialValue()为其指定初始值
 * @author:戛剑生
 * @creat: 2021-03-07 10:49:32
 **/
public class Test03 {
    //定义ThreadLocal的子类
    static class SubThreadLocal extends ThreadLocal<Date> {
        //重写initialValue()，设置初始值
        @Override
        protected Date initialValue() {
//            return new Date();//把当前日期设置为初始值
            return new Date(System.currentTimeMillis() - 1000 * 60 * 15);
            //把15分钟之前设置为初始值
        }
    }

    //    //定义ThreadLocal对象
//    static ThreadLocal threadLocal = new ThreadLocal();
    //定义ThreadLocal对象
    static SubThreadLocal threadLocal = new SubThreadLocal();

    //定义线程类
    static class SubThread extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                //第一次调用ThreadLocal的get方法会返回null
                System.out.println(i + 1 + "---" 
                    + Thread.currentThread().getName() 
                         + " value = " + threadLocal.get());
                //如果没有初始值就设置:这里设置一个日期
                if (threadLocal.get() == null) {
                    threadLocal.set(new Date());
                }
                try {
                    Thread.sleep(new Random().nextInt(2000) + 1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        SubThread t1 = new SubThread();
        SubThread t2 = new SubThread();
        t1.setName("t1");
        t2.setName("t2");
        t1.start();
        t2.start();
    }
}\end{Verbatim}
\chapter{\dm{Lock}显示锁}
在JDK5中增加了\dm{Lock}锁接口。

有\dm{ReentrantLock}实现类，该锁称为可重入锁，它功能要比\dm{synchronized}多。
\section{锁的可重入性}
锁的可重入是指一个线程获得一个对象锁后，再次请求该对象锁时是可以获得该对象锁的。
\begin{lstlisting}
/**
 * @program: DataStructures
 * @description ：演示锁的可重入性
 * @author:戛剑生
 * @creat: 2021-03-07 15:11:04
 **/
public class Test01 {
    public  synchronized void sm1(){
        System.out.println("同步方法1：");
        //线程执行sm1方法，默认this作为锁对象，在sm1()方法中调用了sm2方法，当前线程还是持有this锁对象的
        //sm2同步方法默认的锁对象是this对象，要执行sm2必须先获得this对象，当前this对象被当前线程持有，可以再次获得this对象，这就是锁的可重入性。
        sm2();
    }

    private  synchronized void sm2() {
        System.out.println("同步方法2：");
        sm3();
    }

    private  synchronized void sm3() {
        System.out.println("同步方法3：");
    }

    public static void main(String[] args) {
        Test01 t = new Test01();
        new Thread(new Runnable(){
            @Override
            public void run() {
                t.sm1();
            }
        }).start();
    }
}
\end{lstlisting}
\section{\dm{ReentrantLock}}
\subsection{\dm{ReentrantLock}的基本使用}
调用\dm{lock}方法获得锁，调用\dm{unlock()}方法释放锁
\subsubsection{\dm{Lock}锁的基本使用}
\begin{lstlisting}[title=lock的基本使用]
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: DataStructures
 * @description ：Lock锁的基本使用
 * @author:戛剑生
 * @creat: 2021-03-07 15:25:38
 **/
public class Test02 {
    //定义显示锁
    static Lock lock = new ReentrantLock();

    //定义方法
    public static void sm() {
        //先获得锁
        lock.lock();
        //下边这部分就是同步代码块
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "--" + (i + 1));
        }
        //释放锁
        lock.unlock();
    }

    public static void main(String[] args) {
        Runnable r = new Runnable() {
            @Override
            public void run() {
                sm();
            }
        };
        for (int i = 0; i < 3; i++) {
            new Thread(r).start();
        }
    }
}
\end{lstlisting}

\subsubsection{使用\dm{Lock}锁同步不同方法中的同步代码块}

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
import java.util.Random;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: DataStructures
 * @description ：使用Lock锁同步不同方法中的同步代码块
 * @author:戛剑生
 * @creat: 2021-03-07 15:25:38
 **/
public class Test03 {
    //定义显示锁
    static Lock lock = new ReentrantLock();

    //定义方法1
    public static void sm() {
        //经常在try代码块中获得锁，在finally子句中释放锁
        try {
            //先获得锁
            lock.lock();
            System.out.println(Thread.currentThread().getName() + " -- method1 -- " + System.currentTimeMillis());
            Thread.sleep(new Random().nextInt(1000) + 1);
            System.out.println(Thread.currentThread().getName() + " -- method1 -- " + System.currentTimeMillis());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        } finally {
            //释放锁
            lock.unlock();
        }
    }

    //定义方法2
    public static void sm1() {
        //经常在try代码块中获得锁，在finally子句中释放锁
        try {
            //先获得锁
            lock.lock();
            System.out.println(Thread.currentThread().getName() + " -- method2 -- " + System.currentTimeMillis());
            Thread.sleep(new Random().nextInt(1000) + 1);
            System.out.println(Thread.currentThread().getName() + " -- method2 -- " + System.currentTimeMillis());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        } finally {
            //释放锁
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        Runnable r1 = new Runnable() {
            @Override
            public void run() {
                sm();
            }
        };
        Runnable r2 = new Runnable() {
            @Override
            public void run() {
                sm1();
            }
        };
        for (int i = 0; i < 3; i++) {
            new Thread(r1).start();
        }
        for (int i = 0; i < 3; i++) {
            new Thread(r2).start();
        }
    }
}
\end{Verbatim}
\subsubsection{锁的可重入性}
\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: DataStructures
 * @description：ReentrantLock锁的可重入性
 * @author:戛剑生
 * @creat: 2021-03-07 15:47:24
 **/
public class Test04 {
    static class SubThread extends Thread {
        //定义锁
        private static Lock lock = new ReentrantLock();
        public static int num = 0;

        @Override
        public void run() {
            for (int i = 0; i < 10000; i++) {
                try {
                    lock.lock();
                    //可重入锁是指可以反复获得该锁
                    lock.lock();
                    num++;
                } catch (Exception e) {
                    System.out.println(e.getMessage());
                } finally {
                    lock.unlock();
                    //上边使用几次锁这里就要释放几次
                    lock.unlock();
                }
            }
        }
    }

    public static void main(String[] args) {
        SubThread t1 = new SubThread();
        t1.setName("t1");
        SubThread t2 = new SubThread();
        t2.setName("t2");

        t1.start();
        t2.start();
        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(SubThread.num);
    }
}
\end{Verbatim}
\subsection{\dm{lockInterruptibly()}}
\dm{lockInterruptibly()}作用：如果当前线程未被中断则获得锁，如果当前线程被中断则抛出异常。
\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
package com.atWSN.thread.lock.reentrant;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: DataStructures
 * @description：演示lockInterruptibly()方法
 * @author:戛剑生
 * @creat: 2021-03-07 16:31:47
 **/
public class Test05 {
    public static void main(String[] args) {
        Service service = new Service();
        Runnable r = new Runnable() {
            @Override
            public void run() {
                service.serviceMethod();
            }
        };

        Thread t1 = new Thread(r);
        t1.setName("t1");
        t1.start();
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Thread t2 = new Thread(r);
        t2.setName("t2");
        t2.start();
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t2.interrupt();//t2中断

        /**
         * 程序运行结果：
         * t1 -- 获得锁！
         * null
         * t2 -- 释放锁！
         * Exception in thread "t2" java.lang.IllegalMonitorStateException
         * 	at java.util.concurrent.locks.
         *       ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)
         * 	at java.util.concurrent.
         *      locks.AbstractQueuedSynchronizer.
         *          release(AbstractQueuedSynchronizer.java:1261)
         * 	at java.util.concurrent.locks.ReentrantLock.
         *      unlock(ReentrantLock.java:457)
         * 	at com.atWSN.thread.lock.reentrant.
         *      Test05$Service.serviceMethod(Test05.java:57)
         * 	at com.atWSN.thread.lock.reentrant.Test05$1.
         *      run(Test05.java:18)
         * 	at java.lang.Thread.run(Thread.java:748)
         * t1 -- 释放锁！
         */
    }

    static class Service {
        private Lock lock = new ReentrantLock();

        public void serviceMethod() {
            try {
//                lock.lock();//获得锁定，即使调用了现成的interrupt()方法
                              //也没有真正中断线程
                lock.lockInterruptibly();//如果线程被中断了，不会获得锁，会抛出异常
                System.out.println(Thread.currentThread().getName() 
                    + " -- 获得锁！");
                //模拟执行一段耗时的操作
                for (int i = 0; i < Integer.MAX_VALUE >>> 2; i++) {
                    new StringBuilder();
                }
            } catch (Exception e) {
                System.out.println(e.getMessage());
            } finally {
                System.out.println(Thread.currentThread().getName() 
                    + " -- 释放锁！");
                lock.unlock();
            }
        }
    }
}
\end{Verbatim}

对于\dm{synchronized}内部锁来说，如果一个线程在等待锁，只有两个结果：要么该线程获得锁继续执行，要么就保持等待。

对于\dm{ReentrantLock()}可重入锁来说，提供另外一种可能。在等待锁的过程中，程序可以根据需要取消对锁的请求。

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
import java.util.Random;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: DataStructures
 * @description：通过ReentrantLock的lockInterruptibly()方法避免死锁问题
 * @author:戛剑生
 * @creat: 2021-03-07 20:25:02
 **/
public class Test06 {
    static class IntLock implements Runnable {
        //创建两个ReentrantLock对象
        public static ReentrantLock lock1 = new ReentrantLock();
        public static ReentrantLock lock2 = new ReentrantLock();
        int lockNumber;//定义整数变量决定使用哪个锁

        public IntLock(int lockNumber) {
            this.lockNumber = lockNumber;
        }

        @Override
        public void run() {
            try {
                if (lockNumber % 2 == 1) {
                    lock1.lockInterruptibly();
                    System.out.println(Thread.currentThread().getName() 
                        + "获得锁" + lockNumber % 2 + "还需要获得锁" 
                            + (lockNumber % 2 + 1));
                    Thread.sleep(new Random().nextInt(1000));
                    lock2.lockInterruptibly();
                    System.out.println(Thread.currentThread().getName() 
                        + "同时获得锁" + lockNumber % 2 
                            + "和锁" + (lockNumber % 2 + 1));
                } else {
                    lock2.lockInterruptibly();
                    System.out.println(Thread.currentThread().getName() 
                        + "获得锁" + (lockNumber % 2 + 2) 
                            + "还需要获得锁" + (lockNumber % 2 + 1));
                    Thread.sleep(new Random().nextInt(1000));
                    lock1.lockInterruptibly();
                    System.out.println(Thread.currentThread().getName() 
                        + "同时获得锁" + (lockNumber % 2 + 2) 
                            + "和锁" + (lockNumber % 2 + 1));
                }
            } catch (Exception e) {
                System.out.println(e.getMessage());
            } finally {
                if (lock1.isHeldByCurrentThread()) {//锁被当前线程持有就会释放
                    lock1.unlock();
                }
                if (lock2.isHeldByCurrentThread()) {//锁被当前线程持有就会释放
                    lock2.unlock();
                }
                System.out.println(Thread.currentThread().getName() 
                    + "线程退出！");
            }
        }
    }

    public static void main(String[] args) {
        IntLock intLock1 = new IntLock(11);
        IntLock intLock2 = new IntLock(22);
        Thread t1 = new Thread(intLock1);
        Thread t2 = new Thread(intLock2);
        t1.setName("t1");
        t2.setName("t2");
        t1.start();
        t2.start();

        //在main线程中等待3000秒，如果还有线程没有结束就中断该线程
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        //可以中断任何一个线程来解决死锁
        if (t2.isAlive()) {
            t2.interrupt();//t2线程会放弃对锁1的申请，同时释放锁2
        }
//        try {
//            Thread.sleep(3000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//        if (t2.isAlive()) {
//            t2.interrupt();
//        }
    }
}\end{Verbatim}
\subsection{\dm{tryLock()}方法}
\subsubsection{\dm{tryLock(long time,TimeUnit unit)}}
\dm{tryLock(long time,TimeUnit unit)}的作用在给定等待时长内锁没有被其他线程持有，并且当前线程也没有被中断，则获得该锁。

通过该方法获得锁的限时等待。

\begin{Verbatim}[frame=single,numbersep=5pt,xleftmargin=1.5em,xrightmargin=1.5em]
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: DataStructures
 * @description：tryLock(long time, TimeUnit unit)的基本使用
 * @author:戛剑生
 * @creat: 2021-03-07 21:36:23
 **/
public class Test07 {
    static class TimeLock implements Runnable {
        private static ReentrantLock lock = new ReentrantLock();//定义一个锁对象

        @Override
        public void run() {
            try {
                if (lock.tryLock(4, TimeUnit.SECONDS)) {//获得锁返回true
                    System.out.println(Thread.currentThread().getName() + "获得锁");
                    System.out.println("执行相应的任务");
                    Thread.sleep(3000);//一个线程1获得锁并执行耗时任务，该任务需要3秒钟
                    // 另一个线程2尝试获得锁，线程2两秒内还没获得锁的话就会放弃
                } else {//没有获得锁
                    System.out.println(Thread.currentThread().getName() + "没有获得锁！");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                if (lock.isHeldByCurrentThread()) {
                    lock.unlock();
                    System.out.println(Thread.currentThread().getName() + "释放锁！");
                }
            }
        }
    }

    public static void main(String[] args) {
        TimeLock timeLock = new TimeLock();
        Thread t1 = new Thread(timeLock);
        t1.setName("t1");
        Thread t2 = new Thread(timeLock);
        t2.setName("t2");
        Thread t3 = new Thread(timeLock);
        t3.setName("t3");
        t1.start();
        t2.start();
        t3.start();

    }
}\end{Verbatim}
\subsubsection{\dm{tryLock()}方法}
仅在调用时锁定未被其他线程持有的锁。如果调用该方法时，锁对象被其他线程持有，则放弃。

调用该方法尝试获得锁，如果该锁没有被其他线程占用则返回\dm{true}表示锁定成功。如果锁被其他线程占用则返回\dm{false}，不等待
\section{\dm{ReentrantReadWriteLock}}


\subsection{\dm{ReentrantReadWriteLock.ReadLock}}


\subsection{\dm{ReentrantReadWriteLock.WriteLock}}
\end{document} 