\contentsline {chapter}{\numberline {第一章\hspace {.3em}}线程概述}{1}{chapter.1}% 
\contentsline {section}{\numberline {1.1}线程相关概念}{1}{section.1.1}% 
\contentsline {subsection}{\numberline {1.1.1}进程}{1}{subsection.1.1.1}% 
\contentsline {subsection}{\numberline {1.1.2}线程}{1}{subsection.1.1.2}% 
\contentsline {subsection}{\numberline {1.1.3}主线程和子线程}{1}{subsection.1.1.3}% 
\contentsline {subsection}{\numberline {1.1.4}串行、并发和并行}{1}{subsection.1.1.4}% 
\contentsline {subsubsection}{\numberline {1.1.4.1}串行}{1}{subsubsection.1.1.4.1}% 
\contentsline {subsubsection}{\numberline {1.1.4.2}并发}{1}{subsubsection.1.1.4.2}% 
\contentsline {subsubsection}{\numberline {1.1.4.3}并行}{1}{subsubsection.1.1.4.3}% 
\contentsline {subsubsection}{\numberline {1.1.4.4}对比}{1}{subsubsection.1.1.4.4}% 
\contentsline {section}{\numberline {1.2}线程的创建与启动}{2}{section.1.2}% 
\contentsline {section}{\numberline {1.3}线程的常用方法}{3}{section.1.3}% 
\contentsline {subsection}{\numberline {1.3.1}\color@box {}{wgray}{\lstinline `currentThread()`}方法}{3}{subsection.1.3.1}% 
\contentsline {subsection}{\numberline {1.3.2}\color@box {}{wgray}{\lstinline `setName()/getName()`}}{5}{subsection.1.3.2}% 
\contentsline {subsection}{\numberline {1.3.3}\color@box {}{wgray}{\lstinline `isAlive()`}}{5}{subsection.1.3.3}% 
\contentsline {subsection}{\numberline {1.3.4}\color@box {}{wgray}{\lstinline `sleep()`}}{5}{subsection.1.3.4}% 
\contentsline {subsection}{\numberline {1.3.5}\color@box {}{wgray}{\lstinline `getId()`}}{6}{subsection.1.3.5}% 
\contentsline {subsection}{\numberline {1.3.6}\color@box {}{wgray}{\lstinline `yield()`}}{6}{subsection.1.3.6}% 
\contentsline {subsection}{\numberline {1.3.7}\color@box {}{wgray}{\lstinline `setPriority()`}}{6}{subsection.1.3.7}% 
\contentsline {subsection}{\numberline {1.3.8}\color@box {}{wgray}{\lstinline `interrupt()`}}{6}{subsection.1.3.8}% 
\contentsline {subsection}{\numberline {1.3.9}\color@box {}{wgray}{\lstinline `setDaemon()`}}{6}{subsection.1.3.9}% 
\contentsline {section}{\numberline {1.4}线程的生命周期}{6}{section.1.4}% 
\contentsline {section}{\numberline {1.5}多线程编程的优势与存在的风险}{7}{section.1.5}% 
\contentsline {subsection}{\numberline {1.5.1}优势}{7}{subsection.1.5.1}% 
\contentsline {subsection}{\numberline {1.5.2}风险}{7}{subsection.1.5.2}% 
\contentsline {chapter}{\numberline {第二章\hspace {.3em}}线程安全问题}{8}{chapter.2}% 
\contentsline {section}{\numberline {2.1}原子性}{8}{section.2.1}% 
\contentsline {section}{\numberline {2.2}可见性}{8}{section.2.2}% 
\contentsline {section}{\numberline {2.3}有序性}{8}{section.2.3}% 
\contentsline {subsection}{\numberline {2.3.1}重排序}{8}{subsection.2.3.1}% 
\contentsline {subsection}{\numberline {2.3.2}指令重排序}{9}{subsection.2.3.2}% 
\contentsline {subsubsection}{\numberline {2.3.2.1}存储子系统重排序}{9}{subsubsection.2.3.2.1}% 
\contentsline {subsection}{\numberline {2.3.3}貌似串行语义}{9}{subsection.2.3.3}% 
\contentsline {section}{\numberline {2.4}Java内存模型}{10}{section.2.4}% 
\contentsline {chapter}{\numberline {第三章\hspace {.3em}}线程同步}{11}{chapter.3}% 
\contentsline {section}{\numberline {3.1}线程同步机制简介}{11}{section.3.1}% 
\contentsline {section}{\numberline {3.2}锁}{11}{section.3.2}% 
\contentsline {subsection}{\numberline {3.2.1}锁的作用}{11}{subsection.3.2.1}% 
\contentsline {subsection}{\numberline {3.2.2}锁相关的概念}{11}{subsection.3.2.2}% 
\contentsline {section}{\numberline {3.3}内部锁：\color@box {}{wgray}{\lstinline `synchronized`}关键字}{12}{section.3.3}% 
\contentsline {subsection}{\numberline {3.3.1}\color@box {}{wgray}{\lstinline `synchronized`}同步代码块}{12}{subsection.3.3.1}% 
\contentsline {subsection}{\numberline {3.3.2}\color@box {}{wgray}{\lstinline `synchronized`}修饰实例方法}{14}{subsection.3.3.2}% 
\contentsline {subsection}{\numberline {3.3.3}\color@box {}{wgray}{\lstinline `synchronized`}修饰类方法}{15}{subsection.3.3.3}% 
\contentsline {subsection}{\numberline {3.3.4}线程异常}{17}{subsection.3.3.4}% 
\contentsline {subsection}{\numberline {3.3.5}死锁}{19}{subsection.3.3.5}% 
\contentsline {section}{\numberline {3.4}轻量级同步机制\color@box {}{wgray}{\lstinline `volative`}关键字}{20}{section.3.4}% 
\contentsline {subsection}{\numberline {3.4.1}\color@box {}{wgray}{\lstinline `volative`}的作用}{20}{subsection.3.4.1}% 
\contentsline {subsubsection}{\numberline {3.4.1.1}\color@box {}{wgray}{\lstinline `volative`}与\color@box {}{wgray}{\lstinline `synchronize`}关键字比较}{20}{subsubsection.3.4.1.1}% 
\contentsline {subsection}{\numberline {3.4.2}\color@box {}{wgray}{\lstinline `volative`}的非原子特性}{20}{subsection.3.4.2}% 
\contentsline {subsection}{\numberline {3.4.3}常用的原子类进行自增自减操作}{21}{subsection.3.4.3}% 
\contentsline {section}{\numberline {3.5}CAS}{21}{section.3.5}% 
\contentsline {subsection}{\numberline {3.5.1}ABA问题}{23}{subsection.3.5.1}% 
\contentsline {section}{\numberline {3.6}原子变量类}{23}{section.3.6}% 
\contentsline {subsection}{\numberline {3.6.1}\color@box {}{wgray}{\lstinline `AtomicLong`}}{23}{subsection.3.6.1}% 
\contentsline {subsection}{\numberline {3.6.2}\color@box {}{wgray}{\lstinline `AtomicIntegerArray`}}{26}{subsection.3.6.2}% 
\contentsline {subsection}{\numberline {3.6.3}\color@box {}{wgray}{\lstinline `AtomicIntegerFieldUpdater`}}{27}{subsection.3.6.3}% 
\contentsline {subsection}{\numberline {3.6.4}\color@box {}{wgray}{\lstinline `AtomicReference`}}{29}{subsection.3.6.4}% 
\contentsline {chapter}{\numberline {第四章\hspace {.3em}}线程间通信}{33}{chapter.4}% 
\contentsline {section}{\numberline {4.1}等待/通知机制}{33}{section.4.1}% 
\contentsline {subsection}{\numberline {4.1.1}什么是等待/通知机制}{33}{subsection.4.1.1}% 
\contentsline {subsection}{\numberline {4.1.2}等待/通知机制的实现}{33}{subsection.4.1.2}% 
\contentsline {subsubsection}{\numberline {4.1.2.1}\color@box {}{wgray}{\lstinline `wait()`}方法}{33}{subsubsection.4.1.2.1}% 
\contentsline {subsubsection}{\numberline {4.1.2.2}\color@box {}{wgray}{\lstinline `notify()`}方法}{34}{subsubsection.4.1.2.2}% 
\contentsline {subsection}{\numberline {4.1.3}\color@box {}{wgray}{\lstinline `interrupt()`}方法会中断\color@box {}{wgray}{\lstinline `wait()`}}{37}{subsection.4.1.3}% 
\contentsline {subsection}{\numberline {4.1.4}\color@box {}{wgray}{\lstinline `notify()`}与\color@box {}{wgray}{\lstinline `notifyAll()`}}{38}{subsection.4.1.4}% 
\contentsline {subsection}{\numberline {4.1.5}\color@box {}{wgray}{\lstinline `wait(long)`}的使用}{40}{subsection.4.1.5}% 
\contentsline {subsection}{\numberline {4.1.6}通知过早}{41}{subsection.4.1.6}% 
\contentsline {subsection}{\numberline {4.1.7}\color@box {}{wgray}{\lstinline `wait()`}等待的条件发生了变化}{41}{subsection.4.1.7}% 
\contentsline {subsection}{\numberline {4.1.8}生产者消费者模式}{43}{subsection.4.1.8}% 
\contentsline {subsubsection}{\numberline {4.1.8.1}生产者-消费者：操作数据}{44}{subsubsection.4.1.8.1}% 
\contentsline {subsubsection}{\numberline {4.1.8.2}操作集合}{47}{subsubsection.4.1.8.2}% 
\contentsline {section}{\numberline {4.2}通过管道流实现线程间的通信}{50}{section.4.2}% 
\contentsline {section}{\numberline {4.3}\color@box {}{wgray}{\lstinline `ThreadLocal`}的使用}{52}{section.4.3}% 
\contentsline {subsection}{\numberline {4.3.1}初始化\color@box {}{wgray}{\lstinline `ThreadLocal`}的值}{54}{subsection.4.3.1}% 
\contentsline {chapter}{\numberline {第五章\hspace {.3em}}\color@box {}{wgray}{\lstinline `Lock`}显示锁}{56}{chapter.5}% 
\contentsline {section}{\numberline {5.1}锁的可重入性}{56}{section.5.1}% 
\contentsline {section}{\numberline {5.2}\color@box {}{wgray}{\lstinline `ReentrantLock`}}{57}{section.5.2}% 
\contentsline {subsection}{\numberline {5.2.1}\color@box {}{wgray}{\lstinline `ReentrantLock`}的基本使用}{57}{subsection.5.2.1}% 
\contentsline {subsubsection}{\numberline {5.2.1.1}\color@box {}{wgray}{\lstinline `Lock`}锁的基本使用}{57}{subsubsection.5.2.1.1}% 
\contentsline {subsubsection}{\numberline {5.2.1.2}使用\color@box {}{wgray}{\lstinline `Lock`}锁同步不同方法中的同步代码块}{58}{subsubsection.5.2.1.2}% 
\contentsline {subsubsection}{\numberline {5.2.1.3}锁的可重入性}{59}{subsubsection.5.2.1.3}% 
\contentsline {subsection}{\numberline {5.2.2}\color@box {}{wgray}{\lstinline `lockInterruptibly()`}}{61}{subsection.5.2.2}% 
\contentsline {subsection}{\numberline {5.2.3}\color@box {}{wgray}{\lstinline `tryLock()`}方法}{65}{subsection.5.2.3}% 
\contentsline {subsubsection}{\numberline {5.2.3.1}\color@box {}{wgray}{\lstinline `tryLock(long time,TimeUnit unit)`}}{65}{subsubsection.5.2.3.1}% 
\contentsline {subsubsection}{\numberline {5.2.3.2}\color@box {}{wgray}{\lstinline `tryLock()`}方法}{66}{subsubsection.5.2.3.2}% 
\contentsline {subsubsection}{\numberline {5.2.3.3}\color@box {}{wgray}{\lstinline `tryLock`}不会造成死锁}{68}{subsubsection.5.2.3.3}% 
\contentsline {subsubsection}{\numberline {5.2.3.4}\color@box {}{wgray}{\lstinline `newCondition()`}}{70}{subsubsection.5.2.3.4}% 
\contentsline {subsubsection}{\numberline {5.2.3.5}多个\color@box {}{wgray}{\lstinline `Condition`}实现通知部分线程}{71}{subsubsection.5.2.3.5}% 
\contentsline {subsubsection}{\numberline {5.2.3.6}实现生产者/消费者设计模式，两个线程交替打印}{74}{subsubsection.5.2.3.6}% 
\contentsline {subsubsection}{\numberline {5.2.3.7}生产者/消费者设计模式-多对多}{76}{subsubsection.5.2.3.7}% 
\contentsline {subsection}{\numberline {5.2.4}公平锁与非公平锁}{78}{subsection.5.2.4}% 
\contentsline {subsection}{\numberline {5.2.5}几个常用的方法}{79}{subsection.5.2.5}% 
\contentsline {subsubsection}{\numberline {5.2.5.1}\color@box {}{wgray}{\lstinline `int getHoldCount()`}}{79}{subsubsection.5.2.5.1}% 
\contentsline {subsubsection}{\numberline {5.2.5.2}\color@box {}{wgray}{\lstinline `int getQueueLength()`}}{80}{subsubsection.5.2.5.2}% 
\contentsline {subsubsection}{\numberline {5.2.5.3}\color@box {}{wgray}{\lstinline `int getWaitQueueLength(Condition condition)`}}{81}{subsubsection.5.2.5.3}% 
\contentsline {subsubsection}{\numberline {5.2.5.4}\color@box {}{wgray}{\lstinline `boolean hasQueuedThread(Thread thread)`}}{83}{subsubsection.5.2.5.4}% 
\contentsline {subsubsection}{\numberline {5.2.5.5}\color@box {}{wgray}{\lstinline `boolean hasQueuedThreads()`}}{83}{subsubsection.5.2.5.5}% 
\contentsline {subsubsection}{\numberline {5.2.5.6}\color@box {}{wgray}{\lstinline `boolean hasWaiters(Condition condition)`}}{85}{subsubsection.5.2.5.6}% 
\contentsline {subsubsection}{\numberline {5.2.5.7}\color@box {}{wgray}{\lstinline `boolean isFair()`}}{86}{subsubsection.5.2.5.7}% 
\contentsline {subsubsection}{\numberline {5.2.5.8}\color@box {}{wgray}{\lstinline `boolean isHeldByCurrentThread()`}}{86}{subsubsection.5.2.5.8}% 
\contentsline {subsubsection}{\numberline {5.2.5.9}\color@box {}{wgray}{\lstinline `boolean isLocked()`}}{87}{subsubsection.5.2.5.9}% 
\contentsline {section}{\numberline {5.3}\color@box {}{wgray}{\lstinline `ReentrantReadWriteLock`}读写锁}{89}{section.5.3}% 
\contentsline {subsection}{\numberline {5.3.1}读锁}{89}{subsection.5.3.1}% 
\contentsline {subsection}{\numberline {5.3.2}写锁}{89}{subsection.5.3.2}% 
\contentsline {subsection}{\numberline {5.3.3}\color@box {}{wgray}{\lstinline `ReadWriteLock`}接口}{89}{subsection.5.3.3}% 
\contentsline {subsection}{\numberline {5.3.4}读写锁的基本使用方法}{89}{subsection.5.3.4}% 
\contentsline {subsubsection}{\numberline {5.3.4.1}读读共享}{90}{subsubsection.5.3.4.1}% 
\contentsline {subsubsection}{\numberline {5.3.4.2}写写互斥}{91}{subsubsection.5.3.4.2}% 
\contentsline {subsubsection}{\numberline {5.3.4.3}读写互斥}{92}{subsubsection.5.3.4.3}% 
\contentsline {chapter}{\numberline {第六章\hspace {.3em}}线程管理}{95}{chapter.6}% 
\contentsline {section}{\numberline {6.1}线程组}{95}{section.6.1}% 
\contentsline {subsection}{\numberline {6.1.1}设置守护线程组}{95}{subsection.6.1.1}% 
\contentsline {section}{\numberline {6.2}捕获线程的执行异常}{95}{section.6.2}% 
\contentsline {section}{\numberline {6.3}注入Hook钩子线程}{97}{section.6.3}% 
\contentsline {section}{\numberline {6.4}线程池}{97}{section.6.4}% 
\contentsline {subsection}{\numberline {6.4.1}线程池的定义}{97}{subsection.6.4.1}% 
\contentsline {subsection}{\numberline {6.4.2}JDK对线程池的支持}{97}{subsection.6.4.2}% 
\contentsline {subsection}{\numberline {6.4.3}线程池的基本使用}{97}{subsection.6.4.3}% 
\contentsline {subsection}{\numberline {6.4.4}核心线程池的底层实现}{100}{subsection.6.4.4}% 
\contentsline {subsection}{\numberline {6.4.5}拒绝策略}{101}{subsection.6.4.5}% 
\contentsline {subsection}{\numberline {6.4.6}\color@box {}{wgray}{\lstinline `ThreadFactory`}}{103}{subsection.6.4.6}% 
\contentsline {subsection}{\numberline {6.4.7}监控线程池}{104}{subsection.6.4.7}% 
\contentsline {subsection}{\numberline {6.4.8}扩展线程池}{106}{subsection.6.4.8}% 
\contentsline {subsection}{\numberline {6.4.9}优化线程池数量}{108}{subsection.6.4.9}% 
\contentsline {subsection}{\numberline {6.4.10}线程池死锁}{108}{subsection.6.4.10}% 
\contentsline {subsection}{\numberline {6.4.11}线程池中的异常处理}{108}{subsection.6.4.11}% 
\contentsline {subsection}{\numberline {6.4.12}\color@box {}{wgray}{\lstinline `ForkJoinPool`}线程池}{112}{subsection.6.4.12}% 
\contentsline {chapter}{\numberline {第七章\hspace {.3em}}保障线程安全的设计技术}{115}{chapter.7}% 
\contentsline {section}{\numberline {7.1}Java运行时存储空间}{115}{section.7.1}% 
\contentsline {section}{\numberline {7.2}无状态对象}{115}{section.7.2}% 
\contentsline {section}{\numberline {7.3}不可变对象}{115}{section.7.3}% 
\contentsline {section}{\numberline {7.4}线程特有对象}{116}{section.7.4}% 
\contentsline {section}{\numberline {7.5}装饰器模式}{116}{section.7.5}% 
\contentsfinish 
