\documentclass[a4paper]{report}
\usepackage[space,fancyhdr,fntef]{ctexcap}
\usepackage{array}
\usepackage{fontspec}
\fontspec{宋体}
\setmainfont{Times New Roman}
%\fontsize{50pt}{50pt}\selectfont
\renewcommand{\rmdefault}{ptm}
\usepackage[namelimits,sumlimits,nointlimits]{amsmath}
\usepackage[text={169mm,250mm},bottom=20mm,top=25mm,left=25mm,right=15mm,centering]{geometry}
\usepackage{color}
\usepackage{CJKfntef}%下划线宏包160页
\usepackage{xcolor}
\usepackage{arydshln}%234页，虚线表格宏包
\pagestyle{fancy} \fancyhf{}
\fancyhead[OC]{\color{gray}\rightmark}

\fancyhead[EC]{\color{gray}\leftmark}
\fancyfoot[C]{\color{gray}\thepage}
\renewcommand{\headrule}{\color{gray}\hrule width\headwidth}
%\renewcommand{\footrulewidth}{0.4pt}%改为0pt即可去掉页脚上面的横线
%\usepackage{parskip}
%\usepackage{indentfirst}
\usepackage{graphicx}%插图宏包，参见手册318页
\definecolor{dkgreen}{RGB}{106,135,89}
\definecolor{dkblue}{RGB}{103,150,163}
\definecolor{wgray}{RGB}{248,248,248}
\definecolor{WGRAY}{RGB}{248,248,248}
\usepackage{listings}
\lstset{language=Java,
backgroundcolor=\color{wgray},
rulesepcolor=\color{red!20!green!20!blue!20},%代码块边框为淡青色
%lablestep=1,
%lablesep=5pt,
%lablestyle=\tiny,
%tablesize=4,
%captionpos=b,
basicstyle=\ttfamily\small,
keywordstyle=\color{orange},
commentstyle=\color{gray},
stringstyle=\color{dkgreen},
numberstyle=\tiny,
numbersep=8pt,
frame=single,%topline.bottomline,lines,single,leftline
identifierstyle=\color{dkblue},
numbers=left,
stepnumber=1,
xleftmargin=2em,xrightmargin=2em, aboveskip=1em,
breaklines=true
}
\usepackage[xetex,colorlinks]{hyperref}%394页  \href{网址}{文本}
\hypersetup{urlcolor=blue}
%\linebreak[2]%换行，152页
\usepackage{fancybox}%盒子宏包55页
\setcounter{secnumdepth}{4}
\CTEXoptions[contentsname={目\hspace{15pt}录}]
\CTEXsetup[beforeskip={-40pt},afterskip={20pt plus 2pt minus 2pt}]{chapter}

%目录设置
\usepackage{titletoc}
\usepackage[toc]{multitoc}
\titlecontents{chapter}[4em]{\addvspace{2.3mm}\bf}{\contentslabel{4.0em}}{}{\titlerule*[5pt]{$\cdot$}\contentspage}
\titlecontents{section}[4em]{}{\contentslabel{2.5em}}{}{\titlerule*[5pt]{$\cdot$}\contentspage}
\titlecontents{subsection}[7.2em]{}{\contentslabel{3.3em}}{}{\titlerule*[5pt]{$\cdot$}\contentspage}
\usepackage{fancyvrb}%75页抄录宏包
\begin{document}
\flushbottom%版心底部对齐
\newcommand{\dm}[1]{\colorbox{wgray}{\lstinline`#1`}}
\newcommand{\myroman}[1]{\uppercase\expandafter{\romannumeral#1}}
\newcounter{num}[section] \renewcommand{\thenum}{\arabic{num}.} \newcommand{\num}{\refstepcounter{num}\text{\thenum}}

\newenvironment{tips}{\kaishu\zihao{-6}\color{blue}{\noindent\rule[-3pt]{\textwidth}{0.5pt}\par \em \noindent {\zihao{-5} \textcolor[rgb]{1.00,0.00,0.00}{Tips}}}\par}{\\ \rule[1mm]{\textwidth}{0.5pt}\par}

\newenvironment{zhengming}{\kaishu\zihao{-5}\color{blue}{\noindent\em 证明：}\par}{\hfill $\diamondsuit$\par}

\tableofcontents
\pagenumbering{Roman}%设置目录页码
\clearpage
\pagenumbering{arabic}%设置正文页码
\chapter{内容介绍和授课方式}
\section{数据结构和算法内容介绍}
\subsection{经典算法面试题}
1.字符串匹配问题：KMP算法

2.汉诺塔移动问题：分治思想。

3.八皇后问题：回溯算法、分治算法。

4.马踏棋盘：深度优化遍历算法（DFS）+贪心算法

\chapter{稀疏sparsearray数组和队列}
\section{稀疏数组}
\subsection{应用场景}

编写的五子棋程序中，有存盘退出和续上盘的功能

该二维数组很多值为默认值0，记录了很多没有意义的数据，使用稀疏数组。

\subsection{稀疏数组的处理方法}

（1）第一行记录数组一共有几行几列，有多少个不同的值

（2）把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。

\subsection{二维数组转稀疏数组}

1.遍历原始数组，得到有效数据的个数\dm{sum}.

2.根据\dm{sum}就可以创建稀疏数组\dm{sparseArr}，其规模为\dm{int[sum + 1][3]}

3.稀疏数组的第一行存入原始数组的行数、列数、有效数据个数。

4.将二维数组的有效数据存入到稀疏数组其余行中。

\subsection{稀疏数组转二维数组}
1.先读取稀疏数组的首行，根据该数据创建原始数组。

2.在读取稀疏数组后几行的数据，并赋给原始的二维数组。

\subsection{代码实现}

\begin{lstlisting}
package com.atWSN.sparsearray;

public class SparseArray {
    public static void main(String[] args) {
        //创建一个原始的二维数组 11 * 11
        //0表示没有棋子，1表示黑子，2表示蓝子
        int chessArray1[][] = new int[11][11];
        chessArray1[1][2] = 1;
        chessArray1[2][3] = 2;
        chessArray1[7][8] = 2;
        System.out.println("原始的二维数组：");
        for (int[] row: chessArray1) {
            for (int data : row) {
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }

        //把二维数组转为稀疏数组
        //1.遍历二维数组，得到非零数据的个数
        int sum = 0;
        for (int[] row: chessArray1) {
            for (int data : row) {
                if (data != 0){
                    sum++;
                }
            }
        }
        System.out.println("sum = " + sum);

        //创建对应的稀疏数组
        int sparseArray[][] = new int[sum + 1][3];
        sparseArray[0][0] = 11;
        sparseArray[0][1] = 11;
        sparseArray[0][2] = sum;
        int count = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArray1[i][j] != 0){
                    count++;
                    sparseArray[count][0] = i;
                    sparseArray[count][1] = j;
                    sparseArray[count][2] = chessArray1[i][j];
                }
            }
        }
        //输出稀疏数组
        System.out.println("输出稀疏数组");
        for (int[] row: sparseArray) {
            for (int data:row) {
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }
        //稀疏数组转二维数组
        System.out.println("-------------------------");
        System.out.println("稀疏数组转二维数组:");
        int chessArray2[][] = new int[sparseArray[0][0]][sparseArray[0][1]];
        //遍历稀疏数组，把稀疏数组中存的信息还原回去
        for (int i = 1; i <= sparseArray[0][2]; i++) {
            chessArray2[sparseArray[i][0]][sparseArray[i][1]] = sparseArray[i][2];
        }

        for (int[] row: chessArray2) {
            for (int data : row) {
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }
    }
}

\end{lstlisting}
\section{队列}
\subsection{介绍}

队列是一个有序列表，可以使用数组或链表来实现。

遵循先进先出原则
\subsection{数组模拟队列}
入队操作：\dm{addQueue}

1.尾指针向后移:\dm{rear + 1}，当\dm{front == rear}时，队列为空。

2.若尾指针\dm{rear}小于队列的最大下标\dm{maxSize - 1},则将数组存入\dm{rear}所指的数组元素中，否则无法存入数据.\dm{rear == maxSize - 1}时，队列满。

\begin{lstlisting}
package com.atWSN.queue;

import java.util.Scanner;

public class ArrayQueueDemo {
    public static void main(String[] args) {
        //测试
        ArrayQueue arrayQueue = new ArrayQueue(3);
        char key = ' ';//接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while(loop){
            System.out.println("s(show)：显示队列");
            System.out.println("e(exit)：退出程序");
            System.out.println("a(add)：添加数据到队列");
            System.out.println("g(get)：从队列取出数据");
            System.out.println("h(head)：查看队列头的数据");
            key = scanner.next().charAt(0);
            switch(key){
                case 'a':
                    System.out.println("请输入一个数据：");
                    arrayQueue.addQueue(scanner.nextInt());
                    break;
                case 's':
                    arrayQueue.showQueue();
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    System.out.println("程序退出！");
                    break;
                case 'g':
                    try{
                        int ret =arrayQueue.getQueue();
                        System.out.println("取出的数据是：" + ret);;
                    }catch(Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':
                    try{
                        int ret =arrayQueue.headQueue();
                        System.out.println("头部的数据是：" + ret);;
                    }catch(Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                default:
                    break;
            }
        }
    }
}

//使用数组模拟队列-编写一个ArrayQueue类
class ArrayQueue{
    //表示数组的最大容量
    private int maxSize;
    //指向队首的指针
    private int front;
    //指向队尾的指针
    private int rear;
    private int[] arr;
    public ArrayQueue(int maxSize){
        this.maxSize = maxSize;
        arr = new int[maxSize];
        front = -1;//指向队列头部，指向队列头的前一个位置
        rear = -1;//指向队列尾，指向队列的最后一个数据
    }
    //判断队列是否为满

    public boolean isFull(){
        return rear == maxSize - 1;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    //添加数据到队列
    public void addQueue(int n){
        //判断队列是否满
        if (isFull()){
            System.out.println("队列满！不能加入！");
            return;
        }
        arr[++rear] = n;
    }
    //获取队列的数据，出队列
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列空！不能取数据！");
        }
        return arr[++front];
    }
    public void showQueue(){
        if(isEmpty()){
            System.out.println("队列为空！");
            return;
        }
        System.out.print("[");
        for (int i = front + 1; i <= rear; i++) {
            System.out.print(arr[i]);
            if (i!=rear){
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }

    //显示队列头部的数据，不是取数据
    public int headQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空！");
        }
        return arr[front + 1];
    }
}

\end{lstlisting}

上述队列的问题分析及优化：

1.目前数组使用一次就不能复用了，没有达到复用的效果。

2.将这个数组使用算法，改进成一个环形的队列。（取模）
\subsection{数组模拟环形队列}
思路：

1.\dm{front}变量的含义做一个调整：\dm{front}指向队列的第一个元素。即\dm{arr[front]}是队列的第一个元素。\dm{front}初始值为0
。
2.\dm{rear}变量的含义做一个调整：\dm{rear}指向队列的最后一个元素的后一个位置。因为希望空出一个空间作为约定。\dm{rear}初始值为0

3.队列满时：条件是\dm{(rear + 1)\% maxSize == front}

4.队列空：\dm{rear == front}

5.队列中有效数据的个数：\dm{(rear - front + maxSize) \%maxSize }

\subsection{环形队列的代码实现}

\begin{lstlisting}
class CircleArrayQueue{
    //表示数组的最大容量
    private int maxSize;
    //指向队首的指针
    private int front;
    //指向队尾的指针
    private int rear;
    private int[] arr;
    public CircleArrayQueue(int maxSize){
        this.maxSize = maxSize + 1;//要空出一个空间，所以要+1
        arr = new int[this.maxSize];
        front = 0;//指向队列头部，指向队列第一个元素
        rear = 0;//指向队列尾，指向队列的最后一个数据的下一个位置
    }

    //判断队列是否为满
    public boolean isFull(){
        //数组的一个空间是不存元素的
        //假设front在开头，即下标为0；rear在队列的最后，也就是数组的最后一个位置，下标为maxSize - 1
        //此时队列是满的，有(rear + 1) % maxSize == front
        return (rear + 1) % maxSize  == front;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        //判断队列是否满
        if (isFull()){
            System.out.println("队列满！不能加入！");
            return;
        }
        arr[rear] = n;
        rear = (rear + 1) % maxSize;
    }

    //获取队列的数据，出队列
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列空！不能取数据！");
        }
        //1.先把front对应的值保留到临时变量中
        //2.把front后移
        //3.返回临时变量保存的值
        int ret =  arr[front];
        front = (front + 1) % maxSize;
        return ret;
    }

    public void showQueue(){
        if(isEmpty()){
            System.out.println("队列为空！");
            return;
        }
        System.out.print("[");
        for (int i = front; i < front + getSize(); i++) {
            System.out.print(arr[i % maxSize]);
            if (i!=front + getSize() - 1){
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
    //求出当前队列有效数据的个数


    public int getSize() {
        return (rear + maxSize - front) % maxSize;//rear可能会位于front的前边，此时为负数，所以要加上maxSize
    }

    //显示队列头部的数据，不是取数据
    public int headQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空！");
        }
        return arr[front];
    }
}
\end{lstlisting}

\chapter{链表}
链表：

1.以节点的方式来存储；

2.每个节点包含data域，next域（指向下一个节点）

\section{单链表}

\subsection{代码实现}
\begin{lstlisting}
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        HeroNode heroNode1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode heroNode2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode heroNode3 = new HeroNode(3, "吴用", "智多星");
        HeroNode heroNode4 = new HeroNode(4, "林冲", "豹子头");


        SingleLinkedList singleLinkedList1 = new SingleLinkedList();
//        singleLinkedList1.list();
        singleLinkedList1.addByOrder(heroNode1);
//        singleLinkedList1.list();
        singleLinkedList1.addByOrder(heroNode2);
        singleLinkedList1.addByOrder(heroNode4);
//        singleLinkedList1.list();
        singleLinkedList1.addByOrder(heroNode3);
        singleLinkedList1.list();
        HeroNode newHeroNode = new HeroNode(2, "李逵", "黑旋风");
        singleLinkedList1.update(newHeroNode);
        singleLinkedList1.list();
        singleLinkedList1.delete(heroNode1);
        singleLinkedList1.list();
        singleLinkedList1.delete(heroNode2);
        singleLinkedList1.list();
        singleLinkedList1.delete(heroNode3);
        singleLinkedList1.list();
        singleLinkedList1.delete(heroNode1);
        singleLinkedList1.delete(heroNode4);
        singleLinkedList1.list();
        singleLinkedList1.delete(heroNode1);
        singleLinkedList1.list();
    }
}

//定义SingleLinkedList 管理我们的英雄
class SingleLinkedList{
    //先初始化一个头结点
    private HeroNode head =  new HeroNode();

    //尾插
    public void add(HeroNode heroNode){
        HeroNode curNode = head;
        while(true){
            if (curNode.next == null) {
                break;
            }
            curNode = curNode.next;
        }
        curNode.next = heroNode;
    }

    //方式2：按编号的顺序添加
    //如果编号存在，抛出异常
    public void addByOrder(HeroNode heroNode){
        HeroNode curNode = head;
        boolean flag = false;//标识添加的编号是否存在，默认不存在
        while(true){
            if (curNode.next == null){//说明curNode在链表的最后
                break;
            }
            if(curNode.next.getNum() > heroNode.getNum() ) {//位置找到了，就在curNode的后边
                break;
            }else if (curNode.next.getNum() == heroNode.getNum()){//说明编号存在
                System.out.println("节点" + heroNode.getNum() + "已存在在链表中！");
                System.out.println("添加失败！");
                return;
            }
            curNode = curNode.next;
        }
        heroNode.next = curNode.next;
        curNode.next = heroNode;
    }
    //显示链表
    public void list(){
        if (head.next == null){
            System.out.println("[]");
            return;
        }
        HeroNode curNode = head.next;
        System.out.print("[");
        while (true){
            if (curNode == null){
                break;
            }
            System.out.print(curNode.toString());
            if(curNode.next != null){
                System.out.print(",");
            }
            curNode = curNode.next;
        }
        System.out.println("]");
    }

    //修改链表中节点的信息：根据编号来改变名字和昵称
    public void update(HeroNode heroNode){//根据heraNode的num来修改
        if (head.next == null){
            System.out.println("链表中无节点，无法修改！");
            System.out.println("修改失败！");
            return;
        }
        HeroNode curNode = head.next;
        while (curNode != null){
            if (curNode.getNum() == heroNode.getNum()){
                curNode.setName(heroNode.getName());
                curNode.setNickName(heroNode.getNickName());
                return;
            }
            curNode = curNode.next;
        }
        System.out.println("没有找到相关节点，无法修改！");
        System.out.println("修改失败！");
    }

    //删除节点
    public void delete(HeroNode heroNode){
        if (head.next == null){
            System.out.println("链表中无节点，无法删除！");
            System.out.println("删除失败！");
            return;
        }
        HeroNode curNode = head;
        while (curNode.next != null){
            if (curNode.next.getNum() == heroNode.getNum()){
                curNode.next = curNode.next.next;
                return;
            }
            curNode = curNode.next;
        }
        System.out.println("链表中无该节点，无法删除！");
        System.out.println("删除失败！");
    }
}

//定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode{
    private int num;
    private String name;
    private String nickName;
    public HeroNode next;

    //构造器
    //无参版
    public HeroNode(){

    }
    //有参版
    public HeroNode(int num,String name,String nickName){
        this.num = num;
        this.name = name;
        this.nickName = nickName;
    }

    public int getNum() {
        return this.num;
    }

    public String getName() {
        return name;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "num=" + getNum() +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}
\end{lstlisting}
\subsection{单链表的面试题}
\begin{lstlisting}
import java.util.Random;
import java.util.Scanner;
import java.util.Stack;

public class InterviewTest {
    public static void main(String[] args) {
        Node head = new Node();
        Node cur = head;
        for (int i = 1; i <= 3; i++) {
            cur.next = new Node(i);
            cur = cur.next;
        }
        //求链表的有效节点长度
        //带傀儡节点版
        System.out.println("------------------------------------");
        System.out.println(getLength1(head));
        //不带傀儡节点版
        System.out.println("------------------------------------");
        System.out.println(getLength2(head.next));
        System.out.println("------------------------------------");
//        System.out.println("您要求倒数第几个节点？");
//        Scanner scanner = new Scanner(System.in);
        int num = 1;
        System.out.println("求倒数第" + num +"个节点：方法一（头结点为有效节点的前一个）");
        Node ret = findLastIndexNode1(head,num);
        if (ret != null) {
            System.out.println(ret.num);
        }else{
            System.out.println("ret指向为null");
        }
        System.out.println("------------------------------------");
        System.out.println("求倒数第" + num +"个节点：方法一（头结点为有效节点）");
        Node ret1 = findLastIndexNode2(head.next,num);
        if (ret1 != null) {
            System.out.println(ret1.num);
        }else{
            System.out.println("ret1指向为null");
        }

        System.out.println("------------------------------------");
        System.out.println("求倒数第" + num +"个节点：方法二（头结点下一个为有效节点）快慢指针1");
        Node ret3 = findLastIndexNode3(head,num);
        if (ret3 != null) {
            System.out.println(ret3.num);
        }else{
            System.out.println("ret3指向为null");
        }

        System.out.println("------------------------------------");
        System.out.println("求倒数第" + num +"个节点：方法二（头结点下一个为有效节点）快慢指针2");
        Node ret4 = findLastIndexNode4(head,num);
        if (ret4 != null) {
            System.out.println(ret4.num);
        }else{
            System.out.println("ret4指向为null");
        }

        System.out.println("-----------------------------");
        head = reverse1(head);
        printLinkedList(head.next);
        System.out.println("-----------------------------");
        head = reverse2(head.next);
        printLinkedList(head);
        System.out.println("-----------------------------");
        reversePrint(head);
        System.out.println("-----------------------------");
        System.out.println("合并有序链表");
        Node head1 = new Node();
        Node cur1 = head1;
        Scanner scanner = new Scanner(System.in);
        Random random = new Random();
        System.out.println("请输入head1的长度");
        int i = scanner.nextInt();
        System.out.println("请输入head1的初始值");
        int number = scanner.nextInt();;
        Node tmp = null;
        head1.num = number;

        while (i > 0){
            cur1.next = new Node(cur1.num + random.nextInt(10) + 1);
            cur1 = cur1.next;
            i--;
        }
        Node head2 = new Node();
        cur1 = head2;
        System.out.println("请输入head2的长度");
        i = scanner.nextInt();
        System.out.println("请输入head2的初始值");
        number = scanner.nextInt();;
        head2.num = number;
        while (i > 0){
            cur1.next = new Node(cur1.num + random.nextInt(10) + 1);
            cur1 = cur1.next;
            i--;
        }
        System.out.println("打印链表1：");
        printLinkedList(head1);
        System.out.println("打印链表2：");
        printLinkedList(head2);
        Node mergeNode = mergeLinkedList(head1,head2);
        System.out.println("打印合并后的链表：");
        if (mergeNode != null){
            printLinkedList(mergeNode);
        }else{
            System.out.println("合并的链表为空");
        }
    }
    //1.求单链表中有效节点的个数
    //如果是带头结点的，头结点要去掉

    /**
     *
     * @param head 是链表的头结点（第一个有效节点前的那个节点）
     * @return 返回有效节点的个数
     */
    public static int getLength1(Node head){
        if (head.next == null){
            return 0;
        }
        int sum = 0;
        Node curNode = head.next;
        while (curNode != null){
            sum++;
            curNode = curNode.next;
        }
        return sum;
    }

    /**
     *
     * @param head 是链表第一个有效节点
     * @return 返回有效节点的个数
     */
    public static int getLength2(Node head){
        if (head == null){
            return 0;
        }
        int sum = 0;
        Node curNode = head;
        while (curNode != null){
            sum++;
            curNode = curNode.next;
        }
        return sum;
    }

    //查找单链表的倒数第K个节点

    //方法一：
    //1.写一个方法接收head好项目和K
    //2.先遍历链表得到链表的长度sum
    //3.从链表的头部开始遍历找链表的第sum - k个节点即可
    //4.找到后就依题意返回，这里返回对应节点的引用

    /**
     *
     * @param head 是链表的头结点（第一个有效节点前的那个节点）
     * @return 返回对应节点的引用,没有则返回null
     */
    public static Node findLastIndexNode1(Node head,int k){
        if (head.next == null){
            return null;
        }
        int sum  = getLength1(head);
        if(k <= 0 || k > sum){
            return null;
        }
        Node curNode = head.next;
        for (int i = 0; i < sum - k; i++) {
            curNode = curNode.next;
        }
        return curNode;
    }
    /**
     *
     * @param head 是链表的第一个有效节点
     * @return 返回对应节点的引用,没有则返回null
     */
    public static Node findLastIndexNode2(Node head,int k){
        if (head == null){
            return null;
        }
        int sum  = getLength2(head);
        if(k <= 0 || k > sum){
            return null;
        }
        Node curNode = head;
        for (int i = 0; i < sum - k; i++) {
            curNode = curNode.next;
        }
        return curNode;
    }

    //方法二：使用快慢指针1
    //不求链表的长度
    //快慢指针同时指向第一个有效数据节点，快指针向后移动k - 1步，走到第k个节点。
    //快慢指针同时向后走，直到慢指针走到链表最后一个节点

    /**
     *
     * @param head
     * @param k
     * @return
     */
    public static Node findLastIndexNode3(Node head,int k){
        if (head.next == null){
            return null;
        }
        if(k <= 0){
            return null;
        }
        Node fast = head.next;
        Node slow = head.next;
        for (int i = 0; i < k - 1; i++) {
            if(fast == null){
                return null;
            }
            fast = fast.next;
        }
        if (fast == null){
            return null;
        }
        while(fast.next != null){
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }

    //方法二：使用快慢指针1
    //不求链表的长度
    //快慢指针同时指向头节点（有效数据的前一个节点），快指针移动k步。
    //快慢指针同时向后走，直到快指针指向为null

    /**
     *
     * @param head
     * @param k
     * @return
     */
    public static Node findLastIndexNode4(Node head,int k){
        if (head.next == null){
            return null;
        }
        if(k <= 0){
            return null;
        }
        Node fast = head;
        Node slow = head;
        for (int i = 0; i < k; i++) {
            if(fast == null){
                return null;
            }
            fast = fast.next;
        }
        if (fast == null){
            return null;
        }
        while(fast != null){
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }

    //单链表翻转
    /**
     * 方法一：头插法
     * @author 王松年
     * @param head 的下一个节点是有效节点
     * @return 新的头结点
     */
    public static Node reverse1(Node head){
        if(head.next == null || head.next.next == null){
            return head;
        }
        Node newHead = new Node();
        Node curNode = head.next;
        Node nextNode = curNode.next;
        while (curNode != null){
            nextNode = curNode.next;
            curNode.next = newHead.next;
            newHead.next = curNode;
            curNode = nextNode;
        }
        return newHead;
    }

    /**
     * 方法一：头插法
     * @author 王松年
     * @param head 是有效节点
     * @return 新的头结点
     */
    public static Node reverse2(Node head){
        if(head == null || head.next == null){
            return head;
        }
        Node newHead = new Node();
        Node curNode = head;
        Node nextNode = curNode.next;
        while (curNode != null){
            nextNode = curNode.next;
            curNode.next = newHead.next;
            newHead.next = curNode;
            curNode = nextNode;
        }
        return newHead.next;
    }

    /**
     * 方法二：三指针
     * @author 王松年
     * @param head 是有效节点
     * @return 新的头结点
     */
    public static Node reverse3(Node head){
        if(head == null || head.next == null){
            return head;
        }
        Node preNode = null;
        Node curNode = head;
        Node nextNode = curNode.next;
        while(curNode != null){
            nextNode = curNode.next;
            curNode.next = preNode;
            preNode = curNode;
            curNode = nextNode;
        }
        return preNode;
    }

    //从尾到头打印单链表

    /**
     * head为有效数据
     */
    //注意不要改变原有链表的结构（即不能翻转链表）
    //方法：使用栈
    public static void reversePrint(Node head){
        if (head == null){
            System.out.println("[]");
            return;
        }
        Stack<Integer> stack = new Stack<>();
        while (head != null){
            stack.add(head.num);
            head = head.next;
        }
        System.out.print("[");
        while (!stack.isEmpty()){
            System.out.print(stack.pop());
            if ((stack.size()>=1)){
                System.out.print(",");
            }
        }
        System.out.println("]");
    }

    //合并两个有序的链表，要求合并后的链表依旧有序

    /**
     *
     * @param head1 第一个有效节点
     * @param head2 第一个有效节点
     * @return
     */
    public static Node mergeLinkedList(Node head1,Node head2){
        Node newHead = new Node();
        Node cur1 = head1;
        Node cur2 = head2;
        Node cur = newHead;
        if (head1 == null && head2 == null){
            return null;
        }
        if (cur1 == null){
            return head2;
        }
        if(cur2 == null){
            return head1;
        }
        while(cur1 != null && cur2 != null){
            if (cur1.num <= cur2.num){
                cur.next = cur1;
                cur = cur.next;
                cur1 = cur1.next;
            }else{
                cur.next = cur2;
                cur = cur.next;
                cur2 = cur2.next;
            }
        }
        if (cur1 != null){
            cur.next = cur1;
        }
        if (cur2 != null){
            cur.next = cur2;
        }
        return newHead.next;
    }


    //显示链表:第一个节点为有效节点
    public static void printLinkedList(Node head) {
        System.out.print("[");
        while (head != null){
            System.out.print(head.num);
            if (head.next != null){
                System.out.print(",");
            }
            head = head.next;
        }
        System.out.println("]");
    }
}




class Node{
    public int num;
    public Node next;

    public Node(int num) {
        this.num = num;
    }
    public Node() {
        //TODO
    }
}
\end{lstlisting}
\section{双向链表}
\subsection{特点}
既有\dm{next}（指向下一个节点），也有\dm{pre}（指向前一个节点）

可以自我删除。

遍历：和单链表一致，只不过可以向前查找，也可以向后查找

添加：末尾添加
\\
先找到双向链表的最后一个节点，把新节点的\dm{pre}指向最后一个节点，把最后一个节点的\dm{next}指向新的节点

添加：中间添加，添加到某个节点的后边
\\
把新节点的\dm{pre}指向这个节点，新节点的\dm{next}指向该节点的\dm{next}，把该节点后边那个节点的\dm{pre}指向新节点，该节点的\dm{next}指向新节点

修改：与单向链表一致

删除：中间节点
\\
因为是双向链表，可以直接找到待删除节点。把该节点后边的那个节点的\dm{pre}指向该节点前边的那个节点：\dm{delNode.next.pre = delNode.pre}，把该节点前的节点的\dm{next}指向该节点的下一个节点：\dm{delNode.pre.next = delNode.next}
\subsection{代码实现}

\begin{lstlisting}
public class DoubleLinkedListDemo {
    public static void main(String[] args) {
        System.out.println("--------------------------------------");
        System.out.println("双向链表的测试：");
        HeroNode2 node1 = new HeroNode2(1,"宋江","及时雨");
        HeroNode2 node2 = new HeroNode2(2,"卢俊义","玉麒麟");
        HeroNode2 node3 = new HeroNode2(3,"吴用","智多星");
        HeroNode2 node4 = new HeroNode2(4,"林冲","豹子头");
        DoubleLinkedList doubleLinkedList1 = new DoubleLinkedList();
        //添加
        doubleLinkedList1.add(node1);
        doubleLinkedList1.add(node2);
        //doubleLinkedList1.add(node3);
        doubleLinkedList1.add(node4);
        doubleLinkedList1.list();
//        //修改
//        HeroNode2 newNode = new HeroNode2(2, "公孙胜", "入云龙");
//        doubleLinkedList1.update(newNode);
//        System.out.println("--------------------------------------");
//        System.out.println("双向链表的测试：(修改链表内容)");
//        doubleLinkedList1.list();
//        //删除
//        doubleLinkedList1.delete(node2);
//        doubleLinkedList1.list();
//        doubleLinkedList1.delete(node4);
//        doubleLinkedList1.list();
        //
        System.out.println("--------------------------------------");
        System.out.println("测试：添加相同元素");
        HeroNode2 addNode1 = new HeroNode2(4,"林冲","豹子头");
        doubleLinkedList1.addByOrder(addNode1);
        doubleLinkedList1.list();
        //HeroNode2 addNode1 = new HeroNode2(4,"林冲","豹子头");
        System.out.println("--------------------------------------");
        System.out.println("往中间添加元素：");
        doubleLinkedList1.addByOrder(node3);
        doubleLinkedList1.list();
        System.out.println("--------------------------------------");
        System.out.println("往末尾添加元素：");
        HeroNode2 node5 = new HeroNode2(5,"鲁智深","花和尚");
        doubleLinkedList1.addByOrder(node5);
        doubleLinkedList1.list();
        System.out.println("--------------------------------------");
        System.out.println("往开头添加元素：");
        HeroNode2 node0 = new HeroNode2(0,"0","0");
        doubleLinkedList1.addByOrder(node0);
        doubleLinkedList1.list();
    }
}

//双向链表类
class DoubleLinkedList {
    //初始化
    private HeroNode2 head = new HeroNode2();

    public HeroNode2 getHead() {
        return head;
    }

    //遍历双向链表
    //显示链表
    public void list() {
        if (head.next == null) {
            System.out.println("[]");
            return;
        }
        HeroNode2 curNode = head.next;
        System.out.print("[");
        while (true) {
            if (curNode == null) {
                break;
            }
            System.out.print(curNode.toString());
            if (curNode.next != null) {
                System.out.print(",");
            }
            curNode = curNode.next;
        }
        System.out.println("]");
    }

    //尾插
    public void add(HeroNode2 heroNode) {
        HeroNode2 curNode = head;
        while (curNode.next != null) {
            curNode = curNode.next;
        }
        curNode.next = heroNode;
        heroNode.pre = curNode;
    }

    //方式2：按编号的顺序添加
    //如果编号存在，抛出异常
    public void addByOrder(HeroNode2 heroNode){
        HeroNode2 curNode = head.next;
        while(curNode != null && curNode.getNum() < heroNode.getNum()){
            curNode = curNode.next;
        }
        if(curNode == null){
            add(heroNode);
            return;
        }
        if (curNode.getNum() == heroNode.getNum()){
            System.out.println("链表中已有数据，无法添加。");
            return;
        }
        heroNode.next = curNode;
        heroNode.pre = curNode.pre;
        curNode.pre.next = heroNode;
        curNode.pre = heroNode;
    }

    //修改链表中节点的信息：根据编号来改变名字和昵称
    public void update(HeroNode2 heroNode) {//根据heraNode的num来修改
        if (head.next == null) {
            System.out.println("链表中无节点，无法修改！");
            System.out.println("修改失败！");
            return;
        }
        HeroNode2 curNode = head.next;
        while (curNode != null) {
            if (curNode.getNum() == heroNode.getNum()) {
                curNode.setName(heroNode.getName());
                curNode.setNickName(heroNode.getNickName());
                return;
            }
            curNode = curNode.next;
        }
        System.out.println("没有找到相关节点，无法修改！");
        System.out.println("修改失败！");
    }

    public void delete(HeroNode2 heroNode) {
        if (head.next == null) {
            System.out.println("链表中无节点，无法删除！");
            System.out.println("删除失败！");
            return;
        }
        HeroNode2 curNode = head.next;
        while (curNode != null) {
            if (curNode.getNum() == heroNode.getNum()) {
                curNode.pre.next = curNode.next;
                if (curNode.next != null) {
                    curNode.next.pre = curNode.pre;
                }
                return;
            }
            curNode = curNode.next;
        }
        System.out.println("链表中无该节点，无法删除！");
        System.out.println("删除失败！");
    }
}

class HeroNode2 {
    private int num;
    private String name;
    private String nickName;
    public HeroNode2 pre;
    public HeroNode2 next;


    //构造器
    //无参版
    public HeroNode2() {

    }

    //有参版
    public HeroNode2(int num, String name, String nickName) {
        this.num = num;
        this.name = name;
        this.nickName = nickName;
    }

    public int getNum() {
        return this.num;
    }

    public String getName() {
        return name;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "num=" + getNum() +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}
\end{lstlisting}

\section{单向环形链表}
\subsection{应用场景-约瑟夫问题}

设编号为1-n的n个人围坐一圈，约定编号为k的人开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，知道所有人出列为止，由此产生一个出队编号的序列。

用一个不带头节点的循环列表来处理该问题。

\subsection{代码实现}

构建一个单向环形链表的思路：

1.先创建第一个节点，让\dm{first}指向该节点

2.每创建一个新的节点\dm{newNode}，就把该节点加入到已有的环形链表中。

遍历环形链表：

1.先让辅助指针\dm{curNode}，指向\dm{first}节点

2.通过\dm{while}循环遍历环形链表即可

3.链表剩余一个节点的条件：\dm{curNode.next == first}

\begin{lstlisting}
public class Josephu {
    public static void main(String[] args) {
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.add(125);
        circleSingleLinkedList.list();
        System.out.println(circleSingleLinkedList.size());
        circleSingleLinkedList.josephu(10,20,circleSingleLinkedList.size());
    }
}

//创建环形单向链表
class CircleSingleLinkedList{
    //创建first节点
    private BoyNode first;

    //添加新的节点，构建一个环形链表
    public void add(int nums) {
        if (nums < 1){
            return;
        }
        //使用for循环创建环形链表
        BoyNode curNode = null;
        for (int i = 0; i < nums; i++) {
            BoyNode newNode = new BoyNode(i + 1);
            if (i == 0){
                first = newNode;
                first.next =  first;
                curNode = first;
            }else {
                newNode.next = curNode.next;
                curNode.next = newNode;
                curNode = curNode.next;
            }
        }
    }

    //遍历当前的环形链表
    public void list(){
        if (first == null){
            System.out.println("[]");
            return;
        }
        BoyNode curNode = first;
        System.out.print("[");
        while(curNode.next != first){
            System.out.print(curNode.getNum());
            System.out.print(",");
            curNode = curNode.next;
        }
        System.out.print(curNode.getNum());
        System.out.println("]");
    }

    //节点个数
    public int size(){
        if (first == null){
            return 0;
        }
        int sum = 0;
        BoyNode curNode = first;
        while(true){
            sum++;
            if (curNode.next == first){
                break;
            }
            curNode = curNode.next;
        }
        return sum;
    }

    //约瑟夫问题
    /**
     *
     * @param start 从哪个小孩开始数
     * @param m 每次数几个
     * @param sum 表示最初共有几个小孩
     */
    public void josephu(int start, int m, int sum) {
        if (first == null || start < 1 || start > sum) {
            System.out.println("参数输入有误，请重新输入：");
            return;
        }
        BoyNode preNode = first;
        BoyNode curNode = first;
        while(preNode.next != first){
            preNode = preNode.next;
        }
        //移动到第start个小孩
        for (int i = 0; i < start - 1; i++) {
            first = first.next;
            preNode = preNode.next;
        }
        System.out.print("[");
        while(first.next != first){
            for (int i = 0; i < m - 1; i++) {
                first = first.next;
                preNode = preNode.next;
            }
            System.out.print(first.getNum());
            System.out.print(",");
            preNode.next = first.next;
            first = first.next;
        }
        System.out.print(first.getNum());
        System.out.println("]");
    }

    public BoyNode getFirst() {
        return first;
    }
}
//创建一个节点
class BoyNode{
    private int num;
    public BoyNode next;

    public BoyNode() {
    }
    public BoyNode(int num) {
        this.num = num;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }
}
\end{lstlisting}
\chapter{栈}
\section{栈的知识}
1.栈的英文是stack；

2.栈的元素先进后出

3.出栈：pop

4.入栈：push
\section{栈的应用场景}

1.子程序的调用；

2.处理递归调用

3.表达式的转换（中缀表达式转后缀表达式）与求值（使用后缀表达式求值）

4.二叉树的遍历

5.图形的深度优先搜索算法
\section{代码实现}
\subsection{思路分析}
1.使用数组模拟栈；

2.\dm{top}表示栈顶，初始化为\dm{-1}。

3.入栈：\dm{arr[++top] = num;}

4.出栈：\dm{return arr[top--]}

\subsection{数组实现}
\begin{lstlisting}
import java.util.Random;
import java.util.Scanner;

public class ArrayStackDemo {
    public static void main(String[] args) {
//栈的测试室代码：
        Scanner scanner = new Scanner(System.in);
        System.out.println("栈的测试：");
        System.out.println("请输入栈的规模");
        int capacity = scanner.nextInt();
        ArrayStack arrayStack = new ArrayStack(capacity);
        String key = "";
        boolean loop = true;
        while (loop) {
            System.out.println("------------------------------------------");
            System.out.println("s(Show):显示栈");
            System.out.println("e(Exit):退出栈");
            System.out.println("p(Pop):弹出栈顶元素");
            System.out.println("pu(Push):往栈中加入元素");
            System.out.println("t(TopValue)：查看栈顶元素");
            System.out.println("请输入你的选择：");
            key = scanner.next();
            switch (key) {
                case "t":
                    try {
                        int num = arrayStack.topValue();
                        System.out.println(num);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case "pu":
                    int num = randomNum();
                    System.out.println("要加入栈的元素是：" + num);
                    arrayStack.push(num);
                    break;
                case "p":
                    try {
                        int num1 = arrayStack.pop();
                        System.out.println(num1);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case "s":
                    arrayStack.list();
                    break;
                case "e":
                    scanner.close();
                    loop = false;
                    System.out.println("程序退出");
                    break;
            }
        }
    }

    public static int randomNum() {
        Random random = new Random();
        return random.nextInt(1000) + 1;
    }
}

class ArrayStack {
    private final int capacity;
    private int size;
    private int[] stack;
    private int top = -1;
    private int bottom = -1;

    public ArrayStack(int capacity) {
        this.capacity = capacity;
        stack = new int[capacity];
    }

    //判断栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //判断栈满
    public boolean isFully() {
        return top == capacity - 1;
    }

    //栈的元素
    public int size() {
        return top + 1;
    }

    //入栈
    public void push(int data) {
        if (isFully()) {
            System.out.println("栈满，无法添加！");
            return;
        }
        stack[++top] = data;
    }

    //出栈
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈空，没有元素可以出栈！");
        }
        return stack[top--];
    }

    //遍历栈:从栈顶向栈底显示元素
    public void list() {
        if (isEmpty()) {
            System.out.println("[]");
            return;
        }
        System.out.print("[");
        for (int i = top; i > bottom; i--) {
            System.out.print(stack[i]);
            if (i != 0) {
                System.out.print(",");
            }
        }
        System.out.println("]");
    }

    //显示栈顶元素
    public int topValue() {
        if (isEmpty()) {
            throw new RuntimeException("栈空，没有元素可以出栈！");
        }
        return stack[top];
    }
}
\end{lstlisting}

\subsection{单链表实现}
\begin{lstlisting}
import java.util.Random;
import java.util.Scanner;

public class SingleLinkedListStackDemo {

    public static int randomNum() {
        Random random = new Random();
        return random.nextInt(1000) + 1;
    }

    public static void main(String[] args) {
        //栈的测试代码：
        Scanner scanner = new Scanner(System.in);
        System.out.println("栈的测试：");
        System.out.println("请输入栈的规模");
        int capacity = scanner.nextInt();
        SingleLinkedListStack stack = new SingleLinkedListStack(capacity);
        String key = "";
        boolean loop = true;
        while (loop) {
            System.out.println("------------------------------------------");
            System.out.println("s(Show):显示栈");
            System.out.println("e(Exit):退出栈");
            System.out.println("p(Pop):弹出栈顶元素");
            System.out.println("pu(Push):往栈中加入元素");
            System.out.println("t(TopValue)：查看栈顶元素");
            System.out.println("请输入你的选择：");
            key = scanner.next();
            switch (key) {
                case "t":
                    try {
                        int num = stack.topValue();
                        System.out.println(num);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case "pu":
                    int num = randomNum();
                    System.out.println("要加入栈的元素是：" + num);
                    stack.push(num);
                    break;
                case "p":
                    try {
                        int num1 = stack.pop();
                        System.out.println(num1);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case "s":
                    stack.list();
                    break;
                case "e":
                    scanner.close();
                    loop = false;
                    System.out.println("程序退出");
                    break;
            }
        }
    }

    static class SingleLinkedListStack {
        private Node top;
        private final int capacity;

        public SingleLinkedListStack(int capacity) {
            this.capacity = capacity;
        }

        public boolean isEmpty() {
            return top == null;
        }

        public boolean isFull() {
            return size() == capacity;
        }

        public int size() {
            int sum = 0;
            Node curNode = top;
            while (curNode != null) {
                sum++;
                curNode = curNode.next;
            }
            return sum;
        }

        public void push(int num) {
            if (isFull()) {
                System.out.println("栈满，无法加入！");
                return;
            }
            Node node = new Node(num);
            node.next = top;
            top = node;
        }

        public int pop() {
            if (isEmpty()) {
                throw new RuntimeException("栈空，无法取出元素！");
            }
            int value = top.getNum();
            top = top.next;
            return value;
        }

        public int topValue() {
            return top.getNum();
        }

        public void list() {
            Node curNode = top;
            System.out.print("[");
            while (curNode != null) {
                System.out.print(curNode.getNum());
                if (curNode.next != null) {
                    System.out.print(",");
                }
                curNode = curNode.next;
            }
            System.out.println("]");
        }
    }

    static class Node {
        private int num;
        public Node next;

        public Node(int num) {
            this.num = num;
        }

        public int getNum() {
            return num;
        }
    }
}
\end{lstlisting}
\section{栈实现综合计算器}
数栈：用于存放数字

符号栈：用于存放符号

使用一个指针扫描字符串：

如果是数字就入数栈；

如果是符号：如果符号栈为空，该符号就直接入栈；如果符号栈有操作符，就要进行比较，如果该符号的优先级小于或者等于栈顶的操作符，需要从数栈弹出两个数字，从符号栈弹出一个操作符，进行运算，得到的结果入数栈，让该符号入操作符栈。如果该符号优先级大于符号栈栈顶的操作符，直接入栈。

扫描完毕后，顺序的从符号栈和数栈弹出相应的符号和数进行运算。

最后数栈只有一个数字，就是最终的运算结果。

\subsection{代码实现}
\begin{lstlisting}
public class Calculator {
    public static double cal(double x, double y, char ope) {
        double ret = 0;
        switch (ope) {
            case '/':
                if (y == 0) {
                    throw new RuntimeException("除数为0");
                }
                ret = x / y;
                break;
            case '*':
                ret = x * y;
                break;
            case '-':
                ret = x - y;
                break;
            case '+':
                ret = x + y;
                break;
            case '^':
                ret = Math.pow(x,y);
                break;
        }
        return ret;
    }

    public static int[] readNumber(String str, int index) {
        int ret = 0;
        while (index < str.length() && isNum(str.charAt(index))) {
            int x = str.charAt(index) - '0';
            ret = ret * 10 + x;
            index++;
        }
        return new int[]{ret, index};
    }

    //判断是否为运算符
    public static boolean isNum(char val) {
        return val >= '0' && val <= '9';
    }

    public static int opeNum(char ch) {
        int ret = -1;
        switch (ch) {
            case '+':
                ret = 0;
                break;
            case '-':
                ret = 1;
                break;
            case '*':
                ret = 2;
                break;
            case '/':
                ret = 3;
                break;
            case '^':
                ret = 4;
                break;
            case '!':
                ret = 5;
                break;
            case '(':
                ret = 6;
                break;
            case ')':
                ret = 7;
                break;
            case'\0':
                ret = 8;
                break;
        }
        return ret;
    }

    //
    public static char orderBetween(char ch1, char ch2) {
        int num1 = opeNum(ch1);
        int num2 = opeNum(ch2);
        char pri[][] =  //运算符优先等级[栈顶][当前]
                {       //     |----------当前运算符-----------|
                        //竖的为栈顶运算符
                        //               +    -    *    /    ^    !    (    )
                        /* + */        {'>', '>', '<', '<', '<', '<', '<', '>','>'},
                        /* - */        {'>', '>', '<', '<', '<', '<', '<', '>','>'},
                        /* * */        {'>', '>', '>', '>', '<', '<', '<', '>','>'},
                        /* / */        {'>', '>', '>', '>', '<', '<', '<', '>','>'},
                        /* ^ */        {'>', '>', '>', '>', '>', '<', '<', '>','>'},
                        /* ! */        {'>', '>', '>', '>', '>', '>', ' ', '>','>'},
                        /* ( */        {'<', '<', '<', '<', '<', '<', '<', '=',' '},
                        /* ) */        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',' '},
                        /* \0 */       {'<', '<', '<', '<', '<', '<', '<', ' ','='}
                };
        return pri[num1][num2];
    }

    public static void main(String[] args) {
        String expression = "13+2*(6-2)+5/2";
        ArrayStack<Double> numStack = new ArrayStack<>(100);
        ArrayStack<Character> opeStack = new ArrayStack<>(100);
        int index = 0;
        char ope = '0';
        char ch = ' ';//将每次扫描得到的char保存到ch中
        opeStack.push('\0');
        while (!(opeStack.isEmpty())) {
            if(index < expression.length()){
                ch = expression.charAt(index);
            }else{
                ch = '\0';
            }
            if (isNum(ch)) {
                int[] arr = readNumber(expression, index);
                double x = (double)arr[0];
                numStack.push(x);
                index = arr[1];
            } else {
                if (opeStack.isEmpty()) {
                    opeStack.push(ch);
                    index++;
                } else {
                    switch (orderBetween(opeStack.topValue(), ch)) {
                        case '>':
                            ope = opeStack.pop();
                            if (ope == '!') {
                                double x = numStack.pop();
                                numStack.push((double)fac((int)x));
                            }else{
                                double y = numStack.pop();
                                double x = numStack.pop();
                                double value = cal(x,y,ope);
                                numStack.push(value);
                            }
                            break;
                        case '<':
                            opeStack.push(ch);
                            index++;
                            break;
                        case '=':
                            opeStack.pop();
                            index++;
                            break;
                    }
                }
            }
        }
        System.out.println(numStack.pop());
    }

    private static int fac(int num) {
        if (num == 0 || num == 1){
            return 1;
        }
        return num * fac(num - 1);
    }

    public static void print(ArrayStack arrayStack) {
        arrayStack.list();
    }
}
\end{lstlisting}
\section{栈应用--逆波兰表达式}

前缀表达式又称波兰式，表达式的运算符位于操作数之前。

逆波兰表达式求值：从左至右扫描，遇数入栈，遇到符号则弹出栈顶元素进行计算。

\subsection{逆波兰表达式代码的实现}
\begin{lstlisting}
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
    public static void main(String[] args) {
        String suffixExpression = "30 4 + 5 * 6 -";
        List<String> list = getList(suffixExpression);
        System.out.println(suffixExpression + " = " + cal(list));
    }
    //将逆波兰表达式放入顺序表中
    public static List<String> getList(String str){
        List<String> list = new ArrayList<>();
        int index = 0;
        String str1[] = str.split(" ");
        for (String s:str1) {
            list.add(s);
        }
        return list;
    }
    //完成对逆波兰表达式的运算
    public static int cal(List<String> list){
        Stack<String> stack = new Stack<>();
        for (String ch: list) {
            if (ch.matches("\\d+")){//匹配多位数
                stack.push(ch);
            }else{
                if ("!".equals(ch)){
                    int num = Integer.parseInt(stack.pop());
                    stack.push("" + fac(num));
                }else{
                    int num2 = Integer.parseInt(stack.pop());
                    int num1 = Integer.parseInt(stack.pop());
                    int ret = 0;
                    switch (ch){
                        case "+":
                            ret = num1 + num2;
                            break;
                        case "-":
                            ret = num1 - num2;
                            break;
                        case "*":
                            ret = num1 * num2;
                            break;
                        case "/":
                            ret = num1 / num2;
                            break;
                        case "^":
                            ret = (int)Math.pow((double)num1,(double)num1);
                            break;
                        default:
                            throw new RuntimeException("运算符有误");
                    }
                    stack.push("" + ret);
                }
            }
        }
        return Integer.parseInt(stack.pop());
    }

    private static int fac(int num) {
        if (num == 0 || num == 1){
            return 0;
        }
        return num * fac(num -1);
    }
}
\end{lstlisting}
\subsection{中缀表达式转后缀表达式}
\subsubsection{思路}
1.初始化两个栈\dm{stack1}、\dm{stack2}。

2.从左至右扫描中缀表达式。

3.遇到操作数，压入\dm{stack2}

4.遇到运算符，比较该符号与\dm{stack1}运算符的优先级：
\begin{itemize}
  \item 若\dm{stack1}为空，或栈顶运算符为\dm{(}，将该运算符压入\dm{stack1}。
  \item 若优先级比栈顶的运算符高，也将运算符压入\dm{stack1}。
  \item 否则，将\dm{stack1}栈顶元素弹出压入到\dm{stack2}中，再次跳转到4-1步与\dm{stack1}栈顶运算符相比较。
\end{itemize}

5.遇到括号：
\begin{itemize}
  \item \dm{(}：直接入\dm{stack1}
  \item \dm{)}：依次弹出\dm{stack1}运算符将其压入\dm{stack2}，遇到\dm{(}，将这一对括号丢弃。
\end{itemize}

6.重复2-5步，直到中缀表达式扫描结束。

7.将\dm{stack1}剩余符号全部弹出压入\dm{stack2}。

8.\dm{stack2}从栈顶至栈底则是逆波兰表达式。
\begin{lstlisting}
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

//中缀表达式转后缀表达式
public class ToRPN {
    public static void main(String[] args) {
        String expression = "1+((2+3)*4)-5";
        List<String> list = toList(expression);
        System.out.println(list);
        System.out.println(parsrSuffixExpreesionToRPN(list));
    }

    //中缀表达式转成对应的list
    public static List<String> toList(String str) {
        List<String> list = new ArrayList<>();
        int index = 0;
        StringBuilder stringBuilder = new StringBuilder();
        while (index < str.length()) {
            if (str.charAt(index) == ' ') {
                index++;
            } else if (str.charAt(index) >= '0' && str.charAt(index) <= '9') {
                while (index < str.length() && str.charAt(index) >= '0' && str.charAt(index) <= '9') {
                    stringBuilder.append(str.charAt(index));
                    index++;
                }
                list.add(stringBuilder.toString());
                stringBuilder.delete(0, stringBuilder.length());
            } else {
                list.add("" + str.charAt(index));
                index++;
            }
        }
        return list;
    }

    //中缀表达式转为逆波兰表达式
    public static List<String> parsrSuffixExpreesionToRPN(List<String> list) {
        List<String> rpn = new ArrayList<>();//存储中间结果和
        Stack<String> stack1 = new Stack<>();//符号栈
        for (String str : list) {
            if (str.matches("\\d+")) {
                rpn.add(str);
            } else if ("(".equals(str)) {
                stack1.push(str);
            } else if (")".equals(str)) {
                while (!stack1.peek().equals("(")) {
                    rpn.add(stack1.pop());
                }
                stack1.pop();
            } else {
                //符号栈不为空或者符号栈栈顶不是(或者该符号优先级不大于栈顶符号
                while (!(stack1.size() == 0 || stack1.peek().equals("(")) && !(getValue(str) > getValue(stack1.peek()))) {
                    rpn.add(stack1.pop());
                }
                //否则符号入栈
                stack1.push(str);
            }
        }
        while (!stack1.isEmpty()) {
            rpn.add(stack1.pop());
        }
        return rpn;
    }

    //优先级
    public static int getValue(String str) {
        int add = 1;
        int sub = 1;
        int mul = 2;
        int div = 2;

        int ret = 0;
        switch (str) {
            case "+":
                ret = add;
                break;
            case "-":
                ret = sub;
                break;
            case "*":
                ret = mul;
                break;
            case "/":
                ret = div;
                break;
        }
        return ret;
    }
}
\end{lstlisting}

\chapter{递归}

可以解决的问题：

1.八皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子问题。

2.快速排序、归并排序、二分查找、分治算法等等。

3.将用栈解决的问题

递归遵守的规则：

1.执行一个方法时，就创建一个新的受保护的独立栈空间

2.方法的局部变量是独立的，不会相互影响，如果是引用类型的变量，就会共享该引用类型的数据。

3.递归必须向递归基逼近

4.当一个方法执行完毕，或者遇到\dm{return}，就会返回，谁调用就返回给谁。
\section{迷宫问题}
\begin{lstlisting}
public class Maze {
    public static void main(String[] args) {
        //先创建一个二维数组模拟迷宫
        final int row = 8;
        final int col = 8;
        //迷宫地图
        int[][] map = new int[row][col];
        //使用1来表示迷宫的墙壁
        for (int i = 0; i < col; i++) {
            map[0][i] = 1;
            map[row - 1][i] = 1;
        }
        for (int i = 1; i < row - 1; i++) {
            map[i][0] = 1;
            map[i][col - 1] = 1;
        }
        //地图中的挡板
        map[3][1] = 1;
        map[3][2] = 1;
        map[1][2] = 1;
//        map[2][2] = 1;
        //输出地图
        printMaze(map);

        //使用递归回溯来给小球找路
        System.out.println("----------------------------");
        setWay(map,1,1);
        printMaze(map);
    }
    //打印迷宫地图
    public static void printMaze(int[][] map){
        for (int[] arr: map) {
            for (int i = 0; i < arr.length; i++) {
                System.out.print(arr[i]);
                if (i != arr.length-1){
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
    }
    //小球找路
    //map表示地图
    //出口为地图的右下角，即map[clo - 1 - 1][row - 1 - 1]
    //当map[i][j]为0，表示该点没有走过
    //当map[i][j]为1，表示该点为墙
    //当map[i][j]为2，表示该点走过，且是通路
    //当map[i][j]为3，表示该点走过，但是不是通路
    //走迷宫时，需要确定一个策略：先下再右再上再左。如果该点走不通，再回溯
    /**
     *
     * @param map 表示地图
     * @param i 表示开始位置的横坐标
     * @param j 表示开始位置的横坐标
     * @return 找路结果，找到为true
     */
    public static boolean setWay(int[][] map,int i,int j){
        int x = map.length;
        int y = map[0].length;
        if(map[x - 1 - 1][y - 1 - 1] == 2){//通路已找到
            return true;
        }else{
            if (map[i][j] == 0){//当前的点还没走过
                //按照策略玩
                map[i][j] = 2;//假定该点可以走通
                if(setWay(map,i+1,j)){//向下
                    return true;
                }else if(setWay(map,i,j+1)){//向右
                    return true;
                }else if(setWay(map,i-1,j)){//向上
                    return true;
                }else if(setWay(map,i,j-1)){//向左
                    return true;
                }else{//向四个方向都没走通，说明该点是死路
                    map[i][j] = 3;
                    return false;
                }
            }else{//某点不等于0，可能为1（墙）、2（通路）、3（死路）
                    return false;
            }
        }
    }
}
\end{lstlisting}

\section{八皇后问题}

问题描述：在8*8的棋盘上摆放八颗棋子，任意两颗棋子不能处于同一行、同一列或同一斜线上，问共有多少种摆法。
\subsection{思路分析}
1.第一个皇后先放到第一行第一列。

2.第二个皇后放在第二行第一列，判断是否OK，如果不OK，继续放在第二列、第三列……依次把所有的列放完后，找到一个合适的位置

3.下一个皇后同上边第二步

4.当得到一个正确解时，在退回到上一个栈，就会开始回溯，即将第一个皇后放到第一列的所有正确解全部得到

5.继续第一个皇后放到第二列，继续循环执行1-4步。

\subsection{代码实现}
\begin{lstlisting}
import java.util.Arrays;

public class QueenEight {
    //皇后的个数
    final static int capacity = 8;
    //定义一个一维数组存放皇后的位置
    int[] pos = new int[capacity];
    //解法
    static int count;
    public static void main(String[] args) {
        new QueenEight().check(capacity);
    }
    //将皇后摆放的位置输出
    private  void print(){
        System.out.println(Arrays.toString(pos));
    }

    //放置皇后
    private void check(int n){
        int x = capacity - n;
        if (x == capacity){//共8个皇后，x从0开始的，n等于8说明全部放完了
            System.out.print("第" + (++count) + "种解法：");
            print();
            return;
        }
        //依次放入皇后，并判断是否冲突
        for (int i = 0; i < capacity; i++) {
            //先把当前这个皇后x，放到该行的第1列
            pos[x] = i;
            //放置后判断是否冲突
            if(judge(x)){//不冲突就放下一个皇后
                check(n - 1);
            }
            //冲突就把该皇后放到下一个位置
        }
    }

    //当放第n个皇后，检测是否和前面已经摆放的皇后冲突
    /**
     *
     * @param n 第n个皇后,n从0开始
     * @return 冲突：false，不冲突：true
     */
    private boolean judge(int n){
        for (int i = 0; i < n; i++) {
            //pos[i] == pos[n]表示第n个皇后和第i个皇后位于同一列
            //Math.abs(n - i) == Math.abs(pos[n] - pos[i])表示第n个皇后和第i个皇后位于同一斜线
            if (pos[i] == pos[n] || Math.abs(n - i) == Math.abs(pos[n] - pos[i])){
                return false;
            }
        }
        return true;
    }
}
\end{lstlisting}
\chapter{排序算法}
\section{冒泡排序}
1.一共要进行数据规模- 1次排序
\subsection{代码实现}

\begin{lstlisting}
package com.atWSN.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.Random;
import java.util.Scanner;

public class BubbleSort {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入问题的规模：");
        int num = scanner.nextInt();
        int[] arr = new int[num];
        //初始化数组
        initArr(arr);
        //排序前数组
//        System.out.println("=================");
//        System.out.print("排序前：");
//        print(arr);
        //排序
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间：" + date1Str);
        bubbleSort(arr);
        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间：" + date2Str);
        //排序后数组
//        System.out.println("=================");
//        System.out.print("排序后：");
//        print(arr);
    }

    private static void bubbleSort(int[] arr) {
        boolean flag = true;
        for (int i = 0; i < arr.length - 1; i++) {
            flag = true;
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if(arr[j] > arr[j + 1]){
                    flag = false;
                    int tmp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = tmp;
                }
            }
           // System.out.println(Arrays.toString(arr));
            if (flag){
                break;
            }
        }
    }

    private static void print(int[] arr) {
        System.out.println(Arrays.toString(arr));
    }

    private static void initArr(int[] arr) {
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(2000) - 1000;
        }
    }
}
\end{lstlisting}

\section{选择排序}
从前向后遍历数组，从未排序数组中选择最小的数据与未排序数组中的第一个元素进行交换。

或者从后向前遍历数组，从未排序的数组中选择最大的数据与未排序数组中的最后一个元素进行交换。
\subsection{代码实现}
\begin{lstlisting}
import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;

public class SelectSort {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入问题的规模：");
        int num = scanner.nextInt();
        int[] arr = new int[num];
        //初始化数组
        initArr(arr);
        //排序前数组
        System.out.println("=================");
        System.out.print("排序前：");
        print(arr);
        //排序
        selectSort(arr);
        //排序后数组
        System.out.println("=================");
        System.out.print("排序后：");
        print(arr);
    }

    private static void selectSort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            int min = arr[i];
            int index = i;
            for (int j = i + 1; j < arr.length; j++) {
                if(arr[j] == min){
                    break;
                }else if (arr[j] < min){
                    min = arr[j];
                    index = j;
                }
            }
            if (!(i == index)){
                int tmp = arr[i];
                arr[i] = arr[index];
                arr[index] = tmp;
            }
            System.out.println("第" + (i + 1) +"轮排序");
            print(arr);
        }
    }

    private static void print(int[] arr) {
        System.out.println(Arrays.toString(arr));
    }

    private static void initArr(int[] arr) {
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(10) + 1;
        }
    }
}
\end{lstlisting}
\section{插入排序}
基本思想：把n个待排序的元素看成一个有序表和无序表，开始时有序表只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，从有序中查找到插入的位置，将其插入到有序表的适当位置，使之成为新的有序表。
\subsection{代码实现}
\begin{lstlisting}[title = 未排序数组类]
import java.util.Arrays;
import java.util.Random;

public class unSortArray {
    private final int capacity;
    public int[] arr;

    public unSortArray(int capacity){
        this.capacity = capacity;
        arr = new int[this.capacity];
        Random random = new Random();
        for (int i = 0; i < capacity; i++) {
            arr[i] = random.nextInt(capacity) + 1;
        }
    }
    public void print(){
        System.out.println(Arrays.toString(arr));
    }
}

\end{lstlisting}
\begin{lstlisting}[title = 插入排序]
import java.util.Scanner;

//插入排序
public class InsertSort {
    public static void main(String[] args) {
        System.out.println("请输入数据的规模：");
        int capacity = new Scanner(System.in).nextInt();
        unSortArray unSortArray = new unSortArray(capacity);
        System.out.println("------------------");
        System.out.println("排序前：");
        unSortArray.print();
        //排序
        insertSort(unSortArray.arr);
        System.out.println("------------------");
        System.out.println("排序后：");
        unSortArray.print();
    }
    //插入排序
    private static void insertSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int insertVal = arr[i];
            int index = i;
            for (int j = 0; j < i; j++) {
                if (arr[j] > insertVal){
                    index = j;
                    break;
                }
            }
            if (!(index == i)) {
                for (int j = i; j > index; j--) {
                    arr[j] = arr[j - 1];
                }
                arr[index] = insertVal;
            }
        }
    }
    //版本2
    public static void insertSort1(int[] arr){
        if (arr.length <= 1){
            return;
        }
        for (int i = 1; i < arr.length; i++) {
            int index = i - 1;
            int insertValue = arr[i];
            while(index >= 0 && insertValue < arr[insertValue]){
                arr[index + 1] = arr[index];
                index--;
            }
            if (!(index == i - 1)) {
                arr[index] = insertValue;
            }
        }
    }
}
\end{lstlisting}
\section{希尔排序}

\subsection{代码实现}
先分组再进行选择排序。
\begin{lstlisting}
import java.util.Scanner;

public class ShellSort {
    public static void main(String[] args) {
        System.out.println("请输入问题的规模：");
        int capacity = new Scanner(System.in).nextInt();
        unSortArray unSortArray = new unSortArray(capacity);
        System.out.println("排序前：");
        unSortArray.print();
        //排序
        shellSort2(unSortArray.arr);
        System.out.println("------------------");
        System.out.println("排序后：");
        unSortArray.print();
    }

    private static void shellSort1(int[] arr) {
        if (arr.length < 2){
            return;
        }
        for (int step = arr.length/2; step > 0 ; step /= 2) {
            //遍历各组中所有元素，每组元素有step个
            for (int i = step; i < arr.length; i++) {
                //交换法：从每组的倒数第二个元素开始，与它的后一个元素比较，若大于就交换，每次向前移动
                for (int j = i - step; j >= 0; j -= step) {
                    if (arr[j] > arr[j + step]){
                        int tmp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = tmp;
                    }
                }
            }
        }
    }

    //优化shell排序：移位法
    public static void shellSort2(int[] arr){
        if(arr.length < 2){
            return;
        }
        for (int step = arr.length/2; step > 0; step /= 2) {
            //step表示组数
            //从第step个元素开始，对其所在的组进行插入排序
            for (int i = step; i < arr.length; i++) {
                int j = i - step;
                int value = arr[i];
                while (j >= 0 && arr[j] > value){
                    arr[j + step] = arr[j];
                    j -= step;
                }
                if(!(j == i - step)){
                    arr[j + step] = value;
                }

            }
        }
    }
}
\end{lstlisting}
\section{快速排序}
基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，再按此方法对这两部分进行快速排序，整个排序过程可以递归进行。

关键在于轴点的构造。
\subsection{代码实现}
\begin{lstlisting}
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class QuickSort {
    public static void main(String[] args) {
        System.out.println("请输入数据的规模：");
        int capacity = new Scanner(System.in).nextInt();
        unSortArray unSortArray = new unSortArray(capacity);
//        System.out.println("------------------");
//        System.out.println("排序前：");
//        unSortArray.print();
        //排序\
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间：" + date1Str);
        quickSort(unSortArray.arr,0,unSortArray.arr.length - 1);
        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间：" + date2Str);
//        System.out.println("------------------");
//        System.out.println("排序后：");
//        unSortArray.print();
    }

    public static void quickSort (int[] arr, int lo,int hi){
        if(hi - lo < 1){
            return;
        }
        int mid = partition(arr,lo, hi);//mid位置处的元素已就位，即轴点。
        quickSort(arr,lo,mid - 1);//前缀排序
        quickSort(arr,mid + 1,hi);//后缀排序
    }
    //构造轴点
    private static int partition(int[] arr,int lo, int hi) {
        int left = lo;//左指针
        int right = hi;//右指针
        int value = arr[lo];//轴点的值，一般取区间第一个
        while (left < right) {
            //如果右边的值不小于轴点，右指针左移
            while((left < right) && value <= arr[right]){
                right--;
            }
            //右边的值小于轴点的值，取出该值放入左指针所指的值，同时左指针右移一个单位
            if(left < right){
                arr[left] = arr[right];
                left++;
            }
            //如果左指针指的值不大于轴点值，左指针右移
            while((left < right) && value >= arr[left]){
                left++;
            }
            //左指针的值大于轴点的值，取出该值放入右指针所指的位置，同时右指针左移
            if(left < right){
                arr[right] = arr[left];
                right--;
            }
        }
        //循环退出的条件是左指针右指针重合，
        // 其含义表示该位置左边的值都小于轴点，
        // 该位置右边的值都大于轴点
        //把轴点的值放入该位置，同时返回该位置。
        arr[left] = value;
        return left;
    }
}
\end{lstlisting}
\section{归并排序}
利用归并的思想实现排序的方法，采用经典的分治算法。
\subsection{代码实现}
\begin{lstlisting}
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.Scanner;

public class MergeSort {
    public static void main(String[] args) {
        System.out.println("请输入数据的规模：");
        int capacity = new Scanner(System.in).nextInt();
        unSortArray unSortArray = new unSortArray(capacity);
//        System.out.println("------------------");
//        System.out.println("排序前：");
//        unSortArray.print();
        //排序
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间：" + date1Str);
        mergeSort(unSortArray.arr,0,unSortArray.arr.length - 1);
        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间：" + date2Str);
//        System.out.println("------------------");
//        System.out.println("排序后：");
//        unSortArray.print();
//        int[] arr = {1, 8, 4, 7, 3, 6, 5, 2};
//        mergeSort(arr, 0,  arr.length - 1);
    }

    private static void mergeSort(int[] arr, int left, int right) {

        if (right - left == 0) {
            return;
        }
        int mid = left + ((right - left) >> 1);
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }

    /**
     * @param arr   待排序的数组
     * @param left  左边有序的左边界
     * @param mid   左边有序的右边界，右边有序的左边界的前一个位置
     * @param right 右边有序的右边界
     */
    private static void merge(int[] arr, int left, int mid, int right) {
        int[] tmp = Arrays.copyOfRange(arr, left, mid + 1);
        int lo1 = 0;
        int lo2 = mid + 1;
        int i = left;
        while (lo1 < tmp.length && lo2 <= right) {
            if (tmp[lo1] <= arr[lo2]) {
                arr[i++] = tmp[lo1++];
            } else {
                arr[i++] = arr[lo2++];
            }
        }
        while (i <= right) {
            if (lo1 < tmp.length) {
                arr[i++] = tmp[lo1++];
            }
            if (lo2 <= right) {
                break;
            }
        }
    }
}
\end{lstlisting}
\section{基数排序}
基数排序属于分配式排序，又称桶子法或bin sort。属于稳定排序。

思想：

1.将所有待比较数值统一为同样的长度，数位较短的数前补0，从最低位开始，依次进行依次排序。从最低位排序一直到最高位排序完成以后，数列变成一个有序序列。
\section{代码实现}
\begin{lstlisting}
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class RadixSort {
    public static void main(String[] args) {
        System.out.println("请输入数据的规模：");
        int capacity = new Scanner(System.in).nextInt();
        unSortArray unSortArray = new unSortArray(capacity);
//        System.out.println("------------------");
//        System.out.println("排序前：");
//        unSortArray.print();
        //排序
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间：" + date1Str);
        radixSort(unSortArray.arr);
        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间：" + date2Str);
//        System.out.println("------------------");
//        System.out.println("排序后：");
//        unSortArray.print();
    }
    public static void radixSort(int[] arr){
        //得到数组中最大的数
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max){
                max = arr[i];
            }
        }
        //得到最大位数
        int maxLength = ("" + max).length();
        //定义桶
        int[][] bucket = new int[10][arr.length];
        //记录每个桶中元素的个数
        int[] bucketElementCount = new int[10];
        for (int i = 0,n = 1; i < maxLength; i++ , n*=10) {
            for (int j = 0; j < arr.length; j++) {
                int digitOfElement = arr[j] / n % 10;//找到所在的桶
                //第一个为所在桶的位置
                //第二个为所在桶的指针位置
                bucket[digitOfElement][bucketElementCount[digitOfElement]++] = arr[j];
            }

            //把桶中的数据取出放入原数组
            int index = 0;
            for (int j = 0; j < bucketElementCount.length; j++) {
                if (!(bucketElementCount[j] == 0)){
                    for (int k = 0; k < bucketElementCount[j]; k++) {
                        arr[index++] = bucket[j][k];
                    }
                    //从桶中取出数据后，把该桶元素的个数归0
                    bucketElementCount[j] = 0;
                }
            }
        }
    }
}
\end{lstlisting}

\chapter{查找相关算法}
\section{顺序查找}
\subsection{代码实现}

\begin{lstlisting}
import java.util.Arrays;
import java.util.Scanner;

public class SeqSearch {
    public static void main(String[] args) {
        int[] arr = new Array(10).arr;
        System.out.println(Arrays.toString(arr));
        System.out.println("请输入要查找的数：");
        int num = new Scanner(System.in).nextInt();
        int ret = seqSearch(arr,num);
        if (ret == -1){
            System.out.println("未找到！");
        }else {
            System.out.println("该元素下标为" + ret);
        }

    }
    //找到第一个满足条件的下标
    public static  int seqSearch(int[] arr,int value){
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == value){
                return i;
            }
        }
        return -1;
    }
}
\end{lstlisting}
\section{二分查找}
\subsection{要求}
有序数组。
\subsection{代码实现}
\begin{lstlisting}
import java.util.Arrays;

public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {2,8,10,89,89,89,89,1000,1234};
        int target =  1;
        System.out.println(binarySearch(arr,0,arr.length - 1,target));
        System.out.println(binarySearch1(arr,target));
        System.out.println(Arrays.toString(binarySearch2(arr,target)));
        System.out.println(insert(arr,target));
    }
    //递归版本
    public static int binarySearch(int[] arr,int lo,int hi,int value){
        if (lo > hi){
            return -1;
        }
        int mid = lo + ((hi - lo) >> 1);
        int midValue = arr[mid];
        if(midValue < value){
           return binarySearch(arr,mid + 1,hi,value);
        }else if(value <midValue){
            return binarySearch(arr,lo,mid - 1,value);
        }else{
            return mid;
        }
    }
    //迭代版本
    public static int binarySearch1(int[] arr,int value){
        int lo = 0;
        int hi = arr.length;
        while (lo <= hi){
            int mid = lo + ((hi - lo) >> 1);
            if(value < arr[mid]){
                hi = mid - 1;
            }else if(value > arr[mid]){
                lo = mid + 1;
            }else{
                return mid;
            }
        }
        return -1;
    }

    //寻找插入值
    //如果元素存在，返回该元素最后一个所在的位置
    //如果元素不存在，返回其插入位置的前一个位置
    public static  int insert(int[] arr,int target){
        int lo = 0;
        int hi = arr.length;
        while (lo <= hi){
            int mid = lo + ((hi - lo) >> 1);
            if(target < arr[mid]){
                hi = mid - 1;
            }else if(target > arr[mid]){
                lo = mid + 1;
            }else{
                return findLast(arr,target);
            }
        }
        return lo - 1;
    }

    //找到数组中所有的目标值元素，返回其范围
    //没有则返回[-1,-1]
    public static int[] binarySearch2(int[] arr,int target){
        return new int[]{findFirst(arr,target),findLast(arr,target)};
    }

    private static int findLast(int[] arr, int target) {
        int lo = 0;
        int hi = arr.length;
        while (lo <= hi){
            int mid = lo + ((hi - lo) >> 1);
            if(target < arr[mid]){
                hi = mid - 1;
            }else if(target > arr[mid]){
                lo = mid + 1;
            }else{
                if(mid == arr.length - 1 || arr[mid + 1] != target){
                    return mid;
                }else{
                    lo = mid + 1;
                }
            }
        }
        return -1;
    }

    private static int findFirst(int[] arr, int target) {
        int lo = 0;
        int hi = arr.length;
        while (lo <= hi){
            int mid = lo + ((hi - lo) >> 1);
            if(target < arr[mid]){
                hi = mid - 1;
            }else if(target > arr[mid]){
                lo = mid + 1;
            }else{
                if(mid == 0 || arr[mid - 1] != target){
                    return mid;
                }else{
                    hi = mid - 1;
                }
            }
        }
        return -1;
    }
}
\end{lstlisting}
\section{插值查找算法}
插值查找算法的\dm{mid}公式：
\begin{equation*}
mid = low + \frac{key - a[low]}{a[high] - a[low]}(high - low)
\end{equation*}

\subsection{注意事项}
1.对于数据量大，关键字分布比较均匀的查找表来说，采用插值查找速度较快。

2.关键字分布不均匀的情况下，该方法不一定比折半查找要好。

\subsection{代码实现}
\begin{lstlisting}
public class InsertSearch {
    static int count;
    public static void main(String[] args) {
        int[] arr = new int[1000];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i + 1;
        }
        int ret = insertSearch(arr,7);
        System.out.println(ret);
        System.out.println(count);
    }

    public static int insertSearch(int[] arr,int target){
        if (target < arr[0] || target > arr[arr.length - 1]){
            return -1;
        }
        int lo = 0;
        int hi = arr.length - 1;
        while(lo <= hi){
            int mid  = lo + (hi - lo)*(target - arr[lo])/(arr[hi] - arr[lo]);
            count++;
            if(target < arr[mid]){
                hi = mid - 1;
            }else if(arr[mid] < target){
                lo = mid + 1;
            }else{
                return mid;
            }
        }
        return -1;
    }
}
\end{lstlisting}
\section{斐波那契（黄金分割）查找算法}
\begin{equation*}
mid = lo + F(k - 1) - 1
\end{equation*}

顺序表的长度不一定刚好等于F(k) - 1，所以需要将原来的顺序表长度增加至F(k) - 1。这里k值只要能使得F(k) - 1，恰好大于或等于顺序表的长度即可。
\begin{lstlisting}
while(F(k) - 1 < arr.length){
    k++;
}
\end{lstlisting}

\subsection{代码实现}
\begin{lstlisting}
import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;

public class FibSearch {
    public static void main(String[] args) {
//        int[] arr = {1,8,10,89,1000,1234,1235};
        int num = new Random().nextInt(100)+ 10;
        int[] arr = new int[num];
        for (int i = 0; i < num; i++) {
            arr[i] = new Random().nextInt(100)+ 10;
        }
        radixSort(arr);
        System.out.println(Arrays.toString(arr));
        System.out.println("请输入要查找的数：");
        int target = new Scanner(System.in).nextInt();
        int ret = fibSearch(arr,target);
        System.out.println(ret);
    }

    //mid = low + fib(k - 1) - 1;
    public static int fibSearch(int[] arr,int target){
        int lo = 0;
        int hi = arr.length - 1;
        int len = arr.length;
        int k = 0;//表示斐波那契数列分割数值下标
        int mid = 0;
        int[] fib = fib(arr.length);//获取斐波那契数列
        //获取斐波那契数列分割数值的下标
        while (fib[k] - 1 < arr.length){
            k++;
        }
        //如果数组长度小于斐波那契数列数 - 1的值，把数组扩容至斐波那契数列数 - 1
        if (!(fib[k] - 1 == arr.length)){
            int[] arrTmp = Arrays.copyOf(arr,fib[k] - 1);
            for (int i = arr.length; i < fib[k] - 1; i++) {
                //扩容部分的数为原数组最后一个元素
                arrTmp[i] = arr[arr.length - 1];
            }
            arr = arrTmp;
        }
        while (lo <= hi) {
            //数组长度为fib(k) - 1
            //mid把数组分为左边是fib(k - 1) - 1
            //右边长度是fib(k - 2) - 1
            //fib(k) - 1 = fib(k - 1) - 1 + fib(k - 2) - 1 + 1
            mid = lo + fib[k - 1] - 1;

            if (target < arr[mid]) {
                hi = mid - 1;
                k--;
            } else if(arr[mid] < target) {
                lo = mid + 1;
                k -= 2;
            } else{
                if(mid >= len){
                    return len - 1;
                }
                return mid;
            }
        }
        return -1;
    }

    public static int[] fib(int n){
        int[] arr = new int[n];
        if (n == 1){
            arr[0] = 1;
            return arr;
        }
        arr[0] = 1;
        if (n == 2){
            arr[1] = 1;
            return arr;
        }
        arr[1] = 1;
        for (int i = 2; i < n; i++) {
            arr[i] = arr[i - 1] + arr[i - 2];
        }
        return arr;
    }
}
\end{lstlisting}
\chapter{哈希表（散列表）hash}
一个上机题：

某公司，当员工来报道时，要求将该员工的信息加入（id，姓名），当输入该员工的id时，要求查找到该员工所有信息。

要求：不使用数据库，速度越快越好（可以使用哈希表）

添加时，保证按照id从低到高的顺序插入。
\subsection{散列函数}
决定值对应哪个桶

哈希表是一个链表数组，即数组中的每个元素都是一个链表。该链表的引用指向的是有效节点。

\section{代码实现}
\begin{lstlisting}
import java.util.Scanner;

public class HashTableDemo {
    public static void main(String[] args) {
        // 测试
        // 创建一个hash表
        HashTable hashTable = new HashTable(7);

        boolean flag = true;
        while (flag){
            System.out.println("----------------------------------------");
            System.out.println("a(add)：添加雇员！");
            System.out.println("l(list)：显示雇员！");
            System.out.println("f(find)：查找雇员！");
            System.out.println("d(del)：删除雇员");
            System.out.println("r(remove)：清空全部信息！");
            System.out.println("e(exit)：退出程序！");
            System.out.println("请输入选择：");
            String select = new Scanner(System.in).next();
            switch (select){
                case "e":
                    System.out.println("程序退出！");
                    flag = false;
                    break;
                case "a":
                    System.out.println("请输入员工id：");
                    int id = new Scanner(System.in).nextInt();
                    System.out.println("请输入员工姓名：");
                    String name = new Scanner(System.in).next();
                    Employee employee = new Employee(id,name);
                    hashTable.add(employee);
                    break;
                case "l":
                    hashTable.list();
                    break;
                case "f":
                    System.out.println("请输入要查找的雇员ID：");
                    int findId = new Scanner(System.in).nextInt();
                    Employee findEmployee = hashTable.findEmployeeById(findId);
                    if (findEmployee == null){
                        System.out.println("未找到该id对应的员工");
                    }else{
                        System.out.println(findEmployee);
                    }
                    break;
                case "d":
                    System.out.println("请输入要删除的雇员ID：");
                    int delId = new Scanner(System.in).nextInt();
                    hashTable.delEmployeeById(delId);
                    break;
                case "r":
                    hashTable.removeAll();
                    break;
                default:
                    System.out.println("输入错误，请重新输入：");
                    break;
            }
        }
    }
}
//一个雇员
class Employee{
    private int id;
    private String name;
    public Employee next;
    public Employee(){

    }
    public Employee(int id,String name){
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return "(id:" + id +
                ", name=" + name + ")";
    }
}

//创建employeeLinkedList，表示一条链表
class EmployLinkedList{
    private Employee head;

    //添加雇员到链表
    //添加雇员时，id总是增长的
    //所以把雇员添加在链表的末尾
    public void add(Employee employee){
        if (head == null){
            head = employee;
            return;
        }
        Employee preEmployee = head;
        while(preEmployee.next != null){
            preEmployee = preEmployee.next;
        }
        preEmployee.next = employee;
    }

    //删除雇员
    public void delEmployeeById(int id){
        Employee preEmployee = new Employee();
        Employee tmpEmployee;
        preEmployee.next = head;
        tmpEmployee = preEmployee;
        while(preEmployee.next != null){
            if (preEmployee.next.getId() == id){
                System.out.println("要删除的员工为：");
                System.out.println(preEmployee.next);
                preEmployee.next =  preEmployee.next.next;
                head = tmpEmployee.next;
                System.out.println("系统提示：删除成功");
                return;
            }
            preEmployee = preEmployee.next;
        }
        System.out.println("该雇员不在此表中，无法删除！");
        System.out.println("系统提示：删除失败");
    }

    public Employee getHead() {
        return head;
    }

    public void setHead(Employee head) {
        this.head = head;
    }

    //遍历链表的信息
    public void list(){
        if (head == null){
            System.out.print("[]");
            return;
        }

        Employee curEmployee = head;
        System.out.print("[");
        while (curEmployee != null){
            System.out.print(curEmployee.toString());
            if (curEmployee.next != null){
                System.out.print(",");
            }
            curEmployee = curEmployee.next;
        }
        System.out.print("]");
    }

    //查找某个员工
    public Employee findEmployeeById(int id){
        Employee curEmployee = head;

        while (curEmployee != null && curEmployee.getId() != id){
            curEmployee = curEmployee.next;
        }
        if (curEmployee != null){
            return curEmployee;
        }
        return curEmployee;
    }
}

//创建哈希表
class HashTable{
    private final int capacity;
    EmployLinkedList[] employLinkedLists;
    //构造方法
    public HashTable(int capacity){
        this.capacity = capacity;
        employLinkedLists = new EmployLinkedList[this.capacity];
        //此时该数组的每个元素都是null;要进行初始化
        for (int i = 0; i < capacity; i++) {
            employLinkedLists[i] = new EmployLinkedList();
        }
    }
    public void add(Employee employee){
        //根据员工的id，得到该员工应当添加到哪条链表
        employLinkedLists[hash(employee.getId())].add(employee);

    }

    public void list(){
        System.out.print("{");
        for (int i = 0; i < capacity; i++) {
            employLinkedLists[i].list();
            if (i != capacity - 1){
                System.out.print(",");
            }
        }
        System.out.println("}");
    }

    public Employee  findEmployeeById(int id){
        return employLinkedLists[hash(id)].findEmployeeById(id);
    }

    public void delEmployeeById(int id){
        employLinkedLists[hash(id)].delEmployeeById(id);
    }

    public void removeAll(){
        System.out.println("系统提示：清空所有信息，此操作不可撤销，是否真的要删除？（Y:删除，N：取消）");
        String  str = new Scanner(System.in).next();
        if ("Y".equalsIgnoreCase(str)){
            System.out.println("请再次确认是否要清空所有信息：（Y:确认，N：取消）");
            str = new Scanner(System.in).next();
            if (!("Y".equalsIgnoreCase(str))){
                return;
            }
            for (int i = 0; i < capacity; i++) {
                employLinkedLists[i].setHead(null);
            }
            System.out.println("系统提示：全部员工信息已删除！");
        }else{
            return;
        }

    }

    //编写散列函数：使用取模法来完成
    public int hash(int id){
        return id % this.capacity;
    }

}
\end{lstlisting}

\chapter{树}
\section{常用术语}
节点：

根节点：没有父节点的节点

子节点：

叶子结点：没有孩子的节点

节点的权：

路径：从根节点找到该节点的路线

层：

子树：

树的高度：
\subsection{二叉树}
每个节点最多只能有两个孩子。

满二叉树：所有叶子节点都在最后一层。节点总数为$2^n - 1$，$n$为层数。

完全二叉树：所有叶子结点都在最后一层或倒数第二层，且最后一层的叶子节点在左边连续，倒数第二层的叶子结点在右边连续。

一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。
\end{document} 