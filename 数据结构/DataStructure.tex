\documentclass[a4paper]{report}
\usepackage[space,fancyhdr,fntef]{ctexcap}
\usepackage{array}
\usepackage{fontspec}
\fontspec{宋体}
\setmainfont{Times New Roman}
%\fontsize{50pt}{50pt}\selectfont
\renewcommand{\rmdefault}{ptm}
\usepackage[namelimits,sumlimits,nointlimits]{amsmath}
\usepackage[text={169mm,250mm},bottom=20mm,top=25mm,left=25mm,right=15mm,centering]{geometry}
\usepackage{color}
\usepackage{CJKfntef}%下划线宏包160页
\usepackage{xcolor}
\usepackage{arydshln}%234页，虚线表格宏包
\pagestyle{fancy} \fancyhf{}
\fancyhead[OC]{\color{gray}\rightmark}

\fancyhead[EC]{\color{gray}\leftmark}
\fancyfoot[C]{\color{gray}\thepage}
\renewcommand{\headrule}{\color{gray}\hrule width\headwidth}
%\renewcommand{\footrulewidth}{0.4pt}%改为0pt即可去掉页脚上面的横线
%\usepackage{parskip}
%\usepackage{indentfirst}
\usepackage{graphicx}%插图宏包，参见手册318页
\definecolor{dkgreen}{RGB}{106,135,89}
\definecolor{dkblue}{RGB}{103,150,163}
\definecolor{wgray}{RGB}{248,248,248}
\definecolor{WGRAY}{RGB}{248,248,248}
\usepackage{listings}
\lstset{language=Java,
backgroundcolor=\color{wgray},
rulesepcolor=\color{red!20!green!20!blue!20},%代码块边框为淡青色
%lablestep=1,
%lablesep=5pt,
%lablestyle=\tiny,
%tablesize=4,
%captionpos=b,
basicstyle=\ttfamily\small,
keywordstyle=\color{orange},
commentstyle=\color{gray},
stringstyle=\color{dkgreen},
numberstyle=\tiny,
numbersep=8pt,
frame=single,%topline.bottomline,lines,single,leftline
identifierstyle=\color{dkblue},
numbers=left,
stepnumber=1,
xleftmargin=2em,xrightmargin=2em, aboveskip=1em,
breaklines=true
}
\usepackage[xetex,colorlinks]{hyperref}%394页  \href{网址}{文本}
\hypersetup{urlcolor=blue}
%\linebreak[2]%换行，152页
\usepackage{fancybox}%盒子宏包55页
\setcounter{secnumdepth}{4}
\CTEXoptions[contentsname={目\hspace{15pt}录}]
\CTEXsetup[beforeskip={-40pt},afterskip={20pt plus 2pt minus 2pt}]{chapter}

%目录设置
\usepackage{titletoc}
\usepackage[toc]{multitoc}
\titlecontents{chapter}[4em]{\addvspace{2.3mm}\bf}{\contentslabel{4.0em}}{}{\titlerule*[5pt]{$\cdot$}\contentspage}
\titlecontents{section}[4em]{}{\contentslabel{2.5em}}{}{\titlerule*[5pt]{$\cdot$}\contentspage}
\titlecontents{subsection}[7.2em]{}{\contentslabel{3.3em}}{}{\titlerule*[5pt]{$\cdot$}\contentspage}
\usepackage{fancyvrb}%75页抄录宏包
\begin{document}
\flushbottom%版心底部对齐
\newcommand{\dm}[1]{\colorbox{wgray}{\lstinline`#1`}}
\newcommand{\myroman}[1]{\uppercase\expandafter{\romannumeral#1}}
\newcounter{num}[section] \renewcommand{\thenum}{\arabic{num}.} \newcommand{\num}{\refstepcounter{num}\text{\thenum}}

\newenvironment{tips}{\kaishu\zihao{-6}\color{blue}{\noindent\rule[-3pt]{\textwidth}{0.5pt}\par \em \noindent {\zihao{-5} \textcolor[rgb]{1.00,0.00,0.00}{Tips}}}\par}{\\ \rule[1mm]{\textwidth}{0.5pt}\par}

\newenvironment{zhengming}{\kaishu\zihao{-5}\color{blue}{\noindent\em 证明：}\par}{\hfill $\diamondsuit$\par}

\tableofcontents
\pagenumbering{Roman}%设置目录页码
\clearpage
\pagenumbering{arabic}%设置正文页码
\chapter{内容介绍和授课方式}
\section{数据结构和算法内容介绍}
\subsection{经典算法面试题}
1.字符串匹配问题：KMP算法

2.汉诺塔移动问题：分治思想。

3.八皇后问题：回溯算法、分治算法。

4.马踏棋盘：深度优化遍历算法（DFS）+贪心算法

\chapter{稀疏sparsearray数组和队列}
\section{稀疏数组}
\subsection{应用场景}

编写的五子棋程序中，有存盘退出和续上盘的功能

该二维数组很多值为默认值0，记录了很多没有意义的数据，使用稀疏数组。

\subsection{稀疏数组的处理方法}

（1）第一行记录数组一共有几行几列，有多少个不同的值

（2）把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。

\subsection{二维数组转稀疏数组}

1.遍历原始数组，得到有效数据的个数\dm{sum}.

2.根据\dm{sum}就可以创建稀疏数组\dm{sparseArr}，其规模为\dm{int[sum + 1][3]}

3.稀疏数组的第一行存入原始数组的行数、列数、有效数据个数。

4.将二维数组的有效数据存入到稀疏数组其余行中。

\subsection{稀疏数组转二维数组}
1.先读取稀疏数组的首行，根据该数据创建原始数组。

2.在读取稀疏数组后几行的数据，并赋给原始的二维数组。

\subsection{代码实现}

\begin{lstlisting}
package com.atWSN.sparsearray;

public class SparseArray {
    public static void main(String[] args) {
        //创建一个原始的二维数组 11 * 11
        //0表示没有棋子，1表示黑子，2表示蓝子
        int chessArray1[][] = new int[11][11];
        chessArray1[1][2] = 1;
        chessArray1[2][3] = 2;
        chessArray1[7][8] = 2;
        System.out.println("原始的二维数组：");
        for (int[] row: chessArray1) {
            for (int data : row) {
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }

        //把二维数组转为稀疏数组
        //1.遍历二维数组，得到非零数据的个数
        int sum = 0;
        for (int[] row: chessArray1) {
            for (int data : row) {
                if (data != 0){
                    sum++;
                }
            }
        }
        System.out.println("sum = " + sum);

        //创建对应的稀疏数组
        int sparseArray[][] = new int[sum + 1][3];
        sparseArray[0][0] = 11;
        sparseArray[0][1] = 11;
        sparseArray[0][2] = sum;
        int count = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArray1[i][j] != 0){
                    count++;
                    sparseArray[count][0] = i;
                    sparseArray[count][1] = j;
                    sparseArray[count][2] = chessArray1[i][j];
                }
            }
        }
        //输出稀疏数组
        System.out.println("输出稀疏数组");
        for (int[] row: sparseArray) {
            for (int data:row) {
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }
        //稀疏数组转二维数组
        System.out.println("-------------------------");
        System.out.println("稀疏数组转二维数组:");
        int chessArray2[][] = new int[sparseArray[0][0]][sparseArray[0][1]];
        //遍历稀疏数组，把稀疏数组中存的信息还原回去
        for (int i = 1; i <= sparseArray[0][2]; i++) {
            chessArray2[sparseArray[i][0]][sparseArray[i][1]] = sparseArray[i][2];
        }

        for (int[] row: chessArray2) {
            for (int data : row) {
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }
    }
}

\end{lstlisting}
\section{队列}
\subsection{介绍}

队列是一个有序列表，可以使用数组或链表来实现。

遵循先进先出原则
\subsection{数组模拟队列}
入队操作：\dm{addQueue}

1.尾指针向后移:\dm{rear + 1}，当\dm{front == rear}时，队列为空。

2.若尾指针\dm{rear}小于队列的最大下标\dm{maxSize - 1},则将数组存入\dm{rear}所指的数组元素中，否则无法存入数据.\dm{rear == maxSize - 1}时，队列满。

\begin{lstlisting}
package com.atWSN.queue;

import java.util.Scanner;

public class ArrayQueueDemo {
    public static void main(String[] args) {
        //测试
        ArrayQueue arrayQueue = new ArrayQueue(3);
        char key = ' ';//接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while(loop){
            System.out.println("s(show)：显示队列");
            System.out.println("e(exit)：退出程序");
            System.out.println("a(add)：添加数据到队列");
            System.out.println("g(get)：从队列取出数据");
            System.out.println("h(head)：查看队列头的数据");
            key = scanner.next().charAt(0);
            switch(key){
                case 'a':
                    System.out.println("请输入一个数据：");
                    arrayQueue.addQueue(scanner.nextInt());
                    break;
                case 's':
                    arrayQueue.showQueue();
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    System.out.println("程序退出！");
                    break;
                case 'g':
                    try{
                        int ret =arrayQueue.getQueue();
                        System.out.println("取出的数据是：" + ret);;
                    }catch(Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':
                    try{
                        int ret =arrayQueue.headQueue();
                        System.out.println("头部的数据是：" + ret);;
                    }catch(Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                default:
                    break;
            }
        }
    }
}

//使用数组模拟队列-编写一个ArrayQueue类
class ArrayQueue{
    //表示数组的最大容量
    private int maxSize;
    //指向队首的指针
    private int front;
    //指向队尾的指针
    private int rear;
    private int[] arr;
    public ArrayQueue(int maxSize){
        this.maxSize = maxSize;
        arr = new int[maxSize];
        front = -1;//指向队列头部，指向队列头的前一个位置
        rear = -1;//指向队列尾，指向队列的最后一个数据
    }
    //判断队列是否为满

    public boolean isFull(){
        return rear == maxSize - 1;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    //添加数据到队列
    public void addQueue(int n){
        //判断队列是否满
        if (isFull()){
            System.out.println("队列满！不能加入！");
            return;
        }
        arr[++rear] = n;
    }
    //获取队列的数据，出队列
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列空！不能取数据！");
        }
        return arr[++front];
    }
    public void showQueue(){
        if(isEmpty()){
            System.out.println("队列为空！");
            return;
        }
        System.out.print("[");
        for (int i = front + 1; i <= rear; i++) {
            System.out.print(arr[i]);
            if (i!=rear){
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }

    //显示队列头部的数据，不是取数据
    public int headQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空！");
        }
        return arr[front + 1];
    }
}

\end{lstlisting}

上述队列的问题分析及优化：

1.目前数组使用一次就不能复用了，没有达到复用的效果。

2.将这个数组使用算法，改进成一个环形的队列。（取模）
\subsection{数组模拟环形队列}
思路：

1.\dm{front}变量的含义做一个调整：\dm{front}指向队列的第一个元素。即\dm{arr[front]}是队列的第一个元素。\dm{front}初始值为0
。
2.\dm{rear}变量的含义做一个调整：\dm{rear}指向队列的最后一个元素的后一个位置。因为希望空出一个空间作为约定。\dm{rear}初始值为0

3.队列满时：条件是\dm{(rear + 1)\% maxSize == front}

4.队列空：\dm{rear == front}

5.队列中有效数据的个数：\dm{(rear - front + maxSize) \%maxSize }

\subsection{环形队列的代码实现}

\begin{lstlisting}
class CircleArrayQueue{
    //表示数组的最大容量
    private int maxSize;
    //指向队首的指针
    private int front;
    //指向队尾的指针
    private int rear;
    private int[] arr;
    public CircleArrayQueue(int maxSize){
        this.maxSize = maxSize + 1;//要空出一个空间，所以要+1
        arr = new int[this.maxSize];
        front = 0;//指向队列头部，指向队列第一个元素
        rear = 0;//指向队列尾，指向队列的最后一个数据的下一个位置
    }

    //判断队列是否为满
    public boolean isFull(){
        //数组的一个空间是不存元素的
        //假设front在开头，即下标为0；rear在队列的最后，也就是数组的最后一个位置，下标为maxSize - 1
        //此时队列是满的，有(rear + 1) % maxSize == front
        return (rear + 1) % maxSize  == front;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        //判断队列是否满
        if (isFull()){
            System.out.println("队列满！不能加入！");
            return;
        }
        arr[rear] = n;
        rear = (rear + 1) % maxSize;
    }

    //获取队列的数据，出队列
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列空！不能取数据！");
        }
        //1.先把front对应的值保留到临时变量中
        //2.把front后移
        //3.返回临时变量保存的值
        int ret =  arr[front];
        front = (front + 1) % maxSize;
        return ret;
    }

    public void showQueue(){
        if(isEmpty()){
            System.out.println("队列为空！");
            return;
        }
        System.out.print("[");
        for (int i = front; i < front + getSize(); i++) {
            System.out.print(arr[i % maxSize]);
            if (i!=front + getSize() - 1){
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
    //求出当前队列有效数据的个数


    public int getSize() {
        return (rear + maxSize - front) % maxSize;//rear可能会位于front的前边，此时为负数，所以要加上maxSize
    }

    //显示队列头部的数据，不是取数据
    public int headQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空！");
        }
        return arr[front];
    }
}
\end{lstlisting}

\chapter{链表}
链表：

1.以节点的方式来存储；

2.每个节点包含data域，next域（指向下一个节点）

\section{单链表}

\subsection{代码实现}
\begin{lstlisting}
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        HeroNode heroNode1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode heroNode2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode heroNode3 = new HeroNode(3, "吴用", "智多星");
        HeroNode heroNode4 = new HeroNode(4, "林冲", "豹子头");


        SingleLinkedList singleLinkedList1 = new SingleLinkedList();
//        singleLinkedList1.list();
        singleLinkedList1.addByOrder(heroNode1);
//        singleLinkedList1.list();
        singleLinkedList1.addByOrder(heroNode2);
        singleLinkedList1.addByOrder(heroNode4);
//        singleLinkedList1.list();
        singleLinkedList1.addByOrder(heroNode3);
        singleLinkedList1.list();
        HeroNode newHeroNode = new HeroNode(2, "李逵", "黑旋风");
        singleLinkedList1.update(newHeroNode);
        singleLinkedList1.list();
        singleLinkedList1.delete(heroNode1);
        singleLinkedList1.list();
        singleLinkedList1.delete(heroNode2);
        singleLinkedList1.list();
        singleLinkedList1.delete(heroNode3);
        singleLinkedList1.list();
        singleLinkedList1.delete(heroNode1);
        singleLinkedList1.delete(heroNode4);
        singleLinkedList1.list();
        singleLinkedList1.delete(heroNode1);
        singleLinkedList1.list();
    }
}

//定义SingleLinkedList 管理我们的英雄
class SingleLinkedList{
    //先初始化一个头结点
    private HeroNode head =  new HeroNode();

    //尾插
    public void add(HeroNode heroNode){
        HeroNode curNode = head;
        while(true){
            if (curNode.next == null) {
                break;
            }
            curNode = curNode.next;
        }
        curNode.next = heroNode;
    }

    //方式2：按编号的顺序添加
    //如果编号存在，抛出异常
    public void addByOrder(HeroNode heroNode){
        HeroNode curNode = head;
        boolean flag = false;//标识添加的编号是否存在，默认不存在
        while(true){
            if (curNode.next == null){//说明curNode在链表的最后
                break;
            }
            if(curNode.next.getNum() > heroNode.getNum() ) {//位置找到了，就在curNode的后边
                break;
            }else if (curNode.next.getNum() == heroNode.getNum()){//说明编号存在
                System.out.println("节点" + heroNode.getNum() + "已存在在链表中！");
                System.out.println("添加失败！");
                return;
            }
            curNode = curNode.next;
        }
        heroNode.next = curNode.next;
        curNode.next = heroNode;
    }
    //显示链表
    public void list(){
        if (head.next == null){
            System.out.println("[]");
            return;
        }
        HeroNode curNode = head.next;
        System.out.print("[");
        while (true){
            if (curNode == null){
                break;
            }
            System.out.print(curNode.toString());
            if(curNode.next != null){
                System.out.print(",");
            }
            curNode = curNode.next;
        }
        System.out.println("]");
    }

    //修改链表中节点的信息：根据编号来改变名字和昵称
    public void update(HeroNode heroNode){//根据heraNode的num来修改
        if (head.next == null){
            System.out.println("链表中无节点，无法修改！");
            System.out.println("修改失败！");
            return;
        }
        HeroNode curNode = head.next;
        while (curNode != null){
            if (curNode.getNum() == heroNode.getNum()){
                curNode.setName(heroNode.getName());
                curNode.setNickName(heroNode.getNickName());
                return;
            }
            curNode = curNode.next;
        }
        System.out.println("没有找到相关节点，无法修改！");
        System.out.println("修改失败！");
    }

    //删除节点
    public void delete(HeroNode heroNode){
        if (head.next == null){
            System.out.println("链表中无节点，无法删除！");
            System.out.println("删除失败！");
            return;
        }
        HeroNode curNode = head;
        while (curNode.next != null){
            if (curNode.next.getNum() == heroNode.getNum()){
                curNode.next = curNode.next.next;
                return;
            }
            curNode = curNode.next;
        }
        System.out.println("链表中无该节点，无法删除！");
        System.out.println("删除失败！");
    }
}

//定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode{
    private int num;
    private String name;
    private String nickName;
    public HeroNode next;

    //构造器
    //无参版
    public HeroNode(){

    }
    //有参版
    public HeroNode(int num,String name,String nickName){
        this.num = num;
        this.name = name;
        this.nickName = nickName;
    }

    public int getNum() {
        return this.num;
    }

    public String getName() {
        return name;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "num=" + getNum() +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}
\end{lstlisting}
\subsection{单链表的面试题}
\begin{lstlisting}
import java.util.Random;
import java.util.Scanner;
import java.util.Stack;

public class InterviewTest {
    public static void main(String[] args) {
        Node head = new Node();
        Node cur = head;
        for (int i = 1; i <= 3; i++) {
            cur.next = new Node(i);
            cur = cur.next;
        }
        //求链表的有效节点长度
        //带傀儡节点版
        System.out.println("------------------------------------");
        System.out.println(getLength1(head));
        //不带傀儡节点版
        System.out.println("------------------------------------");
        System.out.println(getLength2(head.next));
        System.out.println("------------------------------------");
//        System.out.println("您要求倒数第几个节点？");
//        Scanner scanner = new Scanner(System.in);
        int num = 1;
        System.out.println("求倒数第" + num +"个节点：方法一（头结点为有效节点的前一个）");
        Node ret = findLastIndexNode1(head,num);
        if (ret != null) {
            System.out.println(ret.num);
        }else{
            System.out.println("ret指向为null");
        }
        System.out.println("------------------------------------");
        System.out.println("求倒数第" + num +"个节点：方法一（头结点为有效节点）");
        Node ret1 = findLastIndexNode2(head.next,num);
        if (ret1 != null) {
            System.out.println(ret1.num);
        }else{
            System.out.println("ret1指向为null");
        }

        System.out.println("------------------------------------");
        System.out.println("求倒数第" + num +"个节点：方法二（头结点下一个为有效节点）快慢指针1");
        Node ret3 = findLastIndexNode3(head,num);
        if (ret3 != null) {
            System.out.println(ret3.num);
        }else{
            System.out.println("ret3指向为null");
        }

        System.out.println("------------------------------------");
        System.out.println("求倒数第" + num +"个节点：方法二（头结点下一个为有效节点）快慢指针2");
        Node ret4 = findLastIndexNode4(head,num);
        if (ret4 != null) {
            System.out.println(ret4.num);
        }else{
            System.out.println("ret4指向为null");
        }

        System.out.println("-----------------------------");
        head = reverse1(head);
        printLinkedList(head.next);
        System.out.println("-----------------------------");
        head = reverse2(head.next);
        printLinkedList(head);
        System.out.println("-----------------------------");
        reversePrint(head);
        System.out.println("-----------------------------");
        System.out.println("合并有序链表");
        Node head1 = new Node();
        Node cur1 = head1;
        Scanner scanner = new Scanner(System.in);
        Random random = new Random();
        System.out.println("请输入head1的长度");
        int i = scanner.nextInt();
        System.out.println("请输入head1的初始值");
        int number = scanner.nextInt();;
        Node tmp = null;
        head1.num = number;

        while (i > 0){
            cur1.next = new Node(cur1.num + random.nextInt(10) + 1);
            cur1 = cur1.next;
            i--;
        }
        Node head2 = new Node();
        cur1 = head2;
        System.out.println("请输入head2的长度");
        i = scanner.nextInt();
        System.out.println("请输入head2的初始值");
        number = scanner.nextInt();;
        head2.num = number;
        while (i > 0){
            cur1.next = new Node(cur1.num + random.nextInt(10) + 1);
            cur1 = cur1.next;
            i--;
        }
        System.out.println("打印链表1：");
        printLinkedList(head1);
        System.out.println("打印链表2：");
        printLinkedList(head2);
        Node mergeNode = mergeLinkedList(head1,head2);
        System.out.println("打印合并后的链表：");
        if (mergeNode != null){
            printLinkedList(mergeNode);
        }else{
            System.out.println("合并的链表为空");
        }
    }
    //1.求单链表中有效节点的个数
    //如果是带头结点的，头结点要去掉

    /**
     *
     * @param head 是链表的头结点（第一个有效节点前的那个节点）
     * @return 返回有效节点的个数
     */
    public static int getLength1(Node head){
        if (head.next == null){
            return 0;
        }
        int sum = 0;
        Node curNode = head.next;
        while (curNode != null){
            sum++;
            curNode = curNode.next;
        }
        return sum;
    }

    /**
     *
     * @param head 是链表第一个有效节点
     * @return 返回有效节点的个数
     */
    public static int getLength2(Node head){
        if (head == null){
            return 0;
        }
        int sum = 0;
        Node curNode = head;
        while (curNode != null){
            sum++;
            curNode = curNode.next;
        }
        return sum;
    }

    //查找单链表的倒数第K个节点

    //方法一：
    //1.写一个方法接收head好项目和K
    //2.先遍历链表得到链表的长度sum
    //3.从链表的头部开始遍历找链表的第sum - k个节点即可
    //4.找到后就依题意返回，这里返回对应节点的引用

    /**
     *
     * @param head 是链表的头结点（第一个有效节点前的那个节点）
     * @return 返回对应节点的引用,没有则返回null
     */
    public static Node findLastIndexNode1(Node head,int k){
        if (head.next == null){
            return null;
        }
        int sum  = getLength1(head);
        if(k <= 0 || k > sum){
            return null;
        }
        Node curNode = head.next;
        for (int i = 0; i < sum - k; i++) {
            curNode = curNode.next;
        }
        return curNode;
    }
    /**
     *
     * @param head 是链表的第一个有效节点
     * @return 返回对应节点的引用,没有则返回null
     */
    public static Node findLastIndexNode2(Node head,int k){
        if (head == null){
            return null;
        }
        int sum  = getLength2(head);
        if(k <= 0 || k > sum){
            return null;
        }
        Node curNode = head;
        for (int i = 0; i < sum - k; i++) {
            curNode = curNode.next;
        }
        return curNode;
    }

    //方法二：使用快慢指针1
    //不求链表的长度
    //快慢指针同时指向第一个有效数据节点，快指针向后移动k - 1步，走到第k个节点。
    //快慢指针同时向后走，直到慢指针走到链表最后一个节点

    /**
     *
     * @param head
     * @param k
     * @return
     */
    public static Node findLastIndexNode3(Node head,int k){
        if (head.next == null){
            return null;
        }
        if(k <= 0){
            return null;
        }
        Node fast = head.next;
        Node slow = head.next;
        for (int i = 0; i < k - 1; i++) {
            if(fast == null){
                return null;
            }
            fast = fast.next;
        }
        if (fast == null){
            return null;
        }
        while(fast.next != null){
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }

    //方法二：使用快慢指针1
    //不求链表的长度
    //快慢指针同时指向头节点（有效数据的前一个节点），快指针移动k步。
    //快慢指针同时向后走，直到快指针指向为null

    /**
     *
     * @param head
     * @param k
     * @return
     */
    public static Node findLastIndexNode4(Node head,int k){
        if (head.next == null){
            return null;
        }
        if(k <= 0){
            return null;
        }
        Node fast = head;
        Node slow = head;
        for (int i = 0; i < k; i++) {
            if(fast == null){
                return null;
            }
            fast = fast.next;
        }
        if (fast == null){
            return null;
        }
        while(fast != null){
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }

    //单链表翻转
    /**
     * 方法一：头插法
     * @author 王松年
     * @param head 的下一个节点是有效节点
     * @return 新的头结点
     */
    public static Node reverse1(Node head){
        if(head.next == null || head.next.next == null){
            return head;
        }
        Node newHead = new Node();
        Node curNode = head.next;
        Node nextNode = curNode.next;
        while (curNode != null){
            nextNode = curNode.next;
            curNode.next = newHead.next;
            newHead.next = curNode;
            curNode = nextNode;
        }
        return newHead;
    }

    /**
     * 方法一：头插法
     * @author 王松年
     * @param head 是有效节点
     * @return 新的头结点
     */
    public static Node reverse2(Node head){
        if(head == null || head.next == null){
            return head;
        }
        Node newHead = new Node();
        Node curNode = head;
        Node nextNode = curNode.next;
        while (curNode != null){
            nextNode = curNode.next;
            curNode.next = newHead.next;
            newHead.next = curNode;
            curNode = nextNode;
        }
        return newHead.next;
    }

    /**
     * 方法二：三指针
     * @author 王松年
     * @param head 是有效节点
     * @return 新的头结点
     */
    public static Node reverse3(Node head){
        if(head == null || head.next == null){
            return head;
        }
        Node preNode = null;
        Node curNode = head;
        Node nextNode = curNode.next;
        while(curNode != null){
            nextNode = curNode.next;
            curNode.next = preNode;
            preNode = curNode;
            curNode = nextNode;
        }
        return preNode;
    }

    //从尾到头打印单链表

    /**
     * head为有效数据
     */
    //注意不要改变原有链表的结构（即不能翻转链表）
    //方法：使用栈
    public static void reversePrint(Node head){
        if (head == null){
            System.out.println("[]");
            return;
        }
        Stack<Integer> stack = new Stack<>();
        while (head != null){
            stack.add(head.num);
            head = head.next;
        }
        System.out.print("[");
        while (!stack.isEmpty()){
            System.out.print(stack.pop());
            if ((stack.size()>=1)){
                System.out.print(",");
            }
        }
        System.out.println("]");
    }

    //合并两个有序的链表，要求合并后的链表依旧有序

    /**
     *
     * @param head1 第一个有效节点
     * @param head2 第一个有效节点
     * @return
     */
    public static Node mergeLinkedList(Node head1,Node head2){
        Node newHead = new Node();
        Node cur1 = head1;
        Node cur2 = head2;
        Node cur = newHead;
        if (head1 == null && head2 == null){
            return null;
        }
        if (cur1 == null){
            return head2;
        }
        if(cur2 == null){
            return head1;
        }
        while(cur1 != null && cur2 != null){
            if (cur1.num <= cur2.num){
                cur.next = cur1;
                cur = cur.next;
                cur1 = cur1.next;
            }else{
                cur.next = cur2;
                cur = cur.next;
                cur2 = cur2.next;
            }
        }
        if (cur1 != null){
            cur.next = cur1;
        }
        if (cur2 != null){
            cur.next = cur2;
        }
        return newHead.next;
    }


    //显示链表:第一个节点为有效节点
    public static void printLinkedList(Node head) {
        System.out.print("[");
        while (head != null){
            System.out.print(head.num);
            if (head.next != null){
                System.out.print(",");
            }
            head = head.next;
        }
        System.out.println("]");
    }
}




class Node{
    public int num;
    public Node next;

    public Node(int num) {
        this.num = num;
    }
    public Node() {
        //TODO
    }
}
\end{lstlisting}
\section{双向链表}
\subsection{特点}
既有\dm{next}（指向下一个节点），也有\dm{pre}（指向前一个节点）

可以自我删除。

遍历：和单链表一致，只不过可以向前查找，也可以向后查找

添加：末尾添加
\\
先找到双向链表的最后一个节点，把新节点的\dm{pre}指向最后一个节点，把最后一个节点的\dm{next}指向新的节点

添加：中间添加，添加到某个节点的后边
\\
把新节点的\dm{pre}指向这个节点，新节点的\dm{next}指向该节点的\dm{next}，把该节点后边那个节点的\dm{pre}指向新节点，该节点的\dm{next}指向新节点

修改：与单向链表一致

删除：中间节点
\\
因为是双向链表，可以直接找到待删除节点。把该节点后边的那个节点的\dm{pre}指向该节点前边的那个节点：\dm{delNode.next.pre = delNode.pre}，把该节点前的节点的\dm{next}指向该节点的下一个节点：\dm{delNode.pre.next = delNode.next}
\subsection{代码实现}

\begin{lstlisting}
public class DoubleLinkedListDemo {
    public static void main(String[] args) {
        System.out.println("--------------------------------------");
        System.out.println("双向链表的测试：");
        HeroNode2 node1 = new HeroNode2(1,"宋江","及时雨");
        HeroNode2 node2 = new HeroNode2(2,"卢俊义","玉麒麟");
        HeroNode2 node3 = new HeroNode2(3,"吴用","智多星");
        HeroNode2 node4 = new HeroNode2(4,"林冲","豹子头");
        DoubleLinkedList doubleLinkedList1 = new DoubleLinkedList();
        //添加
        doubleLinkedList1.add(node1);
        doubleLinkedList1.add(node2);
        //doubleLinkedList1.add(node3);
        doubleLinkedList1.add(node4);
        doubleLinkedList1.list();
//        //修改
//        HeroNode2 newNode = new HeroNode2(2, "公孙胜", "入云龙");
//        doubleLinkedList1.update(newNode);
//        System.out.println("--------------------------------------");
//        System.out.println("双向链表的测试：(修改链表内容)");
//        doubleLinkedList1.list();
//        //删除
//        doubleLinkedList1.delete(node2);
//        doubleLinkedList1.list();
//        doubleLinkedList1.delete(node4);
//        doubleLinkedList1.list();
        //
        System.out.println("--------------------------------------");
        System.out.println("测试：添加相同元素");
        HeroNode2 addNode1 = new HeroNode2(4,"林冲","豹子头");
        doubleLinkedList1.addByOrder(addNode1);
        doubleLinkedList1.list();
        //HeroNode2 addNode1 = new HeroNode2(4,"林冲","豹子头");
        System.out.println("--------------------------------------");
        System.out.println("往中间添加元素：");
        doubleLinkedList1.addByOrder(node3);
        doubleLinkedList1.list();
        System.out.println("--------------------------------------");
        System.out.println("往末尾添加元素：");
        HeroNode2 node5 = new HeroNode2(5,"鲁智深","花和尚");
        doubleLinkedList1.addByOrder(node5);
        doubleLinkedList1.list();
        System.out.println("--------------------------------------");
        System.out.println("往开头添加元素：");
        HeroNode2 node0 = new HeroNode2(0,"0","0");
        doubleLinkedList1.addByOrder(node0);
        doubleLinkedList1.list();
    }
}

//双向链表类
class DoubleLinkedList {
    //初始化
    private HeroNode2 head = new HeroNode2();

    public HeroNode2 getHead() {
        return head;
    }

    //遍历双向链表
    //显示链表
    public void list() {
        if (head.next == null) {
            System.out.println("[]");
            return;
        }
        HeroNode2 curNode = head.next;
        System.out.print("[");
        while (true) {
            if (curNode == null) {
                break;
            }
            System.out.print(curNode.toString());
            if (curNode.next != null) {
                System.out.print(",");
            }
            curNode = curNode.next;
        }
        System.out.println("]");
    }

    //尾插
    public void add(HeroNode2 heroNode) {
        HeroNode2 curNode = head;
        while (curNode.next != null) {
            curNode = curNode.next;
        }
        curNode.next = heroNode;
        heroNode.pre = curNode;
    }

    //方式2：按编号的顺序添加
    //如果编号存在，抛出异常
    public void addByOrder(HeroNode2 heroNode){
        HeroNode2 curNode = head.next;
        while(curNode != null && curNode.getNum() < heroNode.getNum()){
            curNode = curNode.next;
        }
        if(curNode == null){
            add(heroNode);
            return;
        }
        if (curNode.getNum() == heroNode.getNum()){
            System.out.println("链表中已有数据，无法添加。");
            return;
        }
        heroNode.next = curNode;
        heroNode.pre = curNode.pre;
        curNode.pre.next = heroNode;
        curNode.pre = heroNode;
    }

    //修改链表中节点的信息：根据编号来改变名字和昵称
    public void update(HeroNode2 heroNode) {//根据heraNode的num来修改
        if (head.next == null) {
            System.out.println("链表中无节点，无法修改！");
            System.out.println("修改失败！");
            return;
        }
        HeroNode2 curNode = head.next;
        while (curNode != null) {
            if (curNode.getNum() == heroNode.getNum()) {
                curNode.setName(heroNode.getName());
                curNode.setNickName(heroNode.getNickName());
                return;
            }
            curNode = curNode.next;
        }
        System.out.println("没有找到相关节点，无法修改！");
        System.out.println("修改失败！");
    }

    public void delete(HeroNode2 heroNode) {
        if (head.next == null) {
            System.out.println("链表中无节点，无法删除！");
            System.out.println("删除失败！");
            return;
        }
        HeroNode2 curNode = head.next;
        while (curNode != null) {
            if (curNode.getNum() == heroNode.getNum()) {
                curNode.pre.next = curNode.next;
                if (curNode.next != null) {
                    curNode.next.pre = curNode.pre;
                }
                return;
            }
            curNode = curNode.next;
        }
        System.out.println("链表中无该节点，无法删除！");
        System.out.println("删除失败！");
    }
}

class HeroNode2 {
    private int num;
    private String name;
    private String nickName;
    public HeroNode2 pre;
    public HeroNode2 next;


    //构造器
    //无参版
    public HeroNode2() {

    }

    //有参版
    public HeroNode2(int num, String name, String nickName) {
        this.num = num;
        this.name = name;
        this.nickName = nickName;
    }

    public int getNum() {
        return this.num;
    }

    public String getName() {
        return name;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "num=" + getNum() +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}
\end{lstlisting}

\section{单向环形链表}
\subsection{应用场景-约瑟夫问题}

设编号为1-n的n个人围坐一圈，约定编号为k的人开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，知道所有人出列为止，由此产生一个出队编号的序列。

用一个不带头节点的循环列表来处理该问题。

\subsection{代码实现}

构建一个单向环形链表的思路：

1.先创建第一个节点，让\dm{first}指向该节点

2.每创建一个新的节点\dm{newNode}，就把该节点加入到已有的环形链表中。

遍历环形链表：

1.先让辅助指针\dm{curNode}，指向\dm{first}节点

2.通过\dm{while}循环遍历环形链表即可

3.链表剩余一个节点的条件：\dm{curNode.next == first}

\begin{lstlisting}
public class Josephu {
    public static void main(String[] args) {
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.add(125);
        circleSingleLinkedList.list();
        System.out.println(circleSingleLinkedList.size());
        circleSingleLinkedList.josephu(10,20,circleSingleLinkedList.size());
    }
}

//创建环形单向链表
class CircleSingleLinkedList{
    //创建first节点
    private BoyNode first;

    //添加新的节点，构建一个环形链表
    public void add(int nums) {
        if (nums < 1){
            return;
        }
        //使用for循环创建环形链表
        BoyNode curNode = null;
        for (int i = 0; i < nums; i++) {
            BoyNode newNode = new BoyNode(i + 1);
            if (i == 0){
                first = newNode;
                first.next =  first;
                curNode = first;
            }else {
                newNode.next = curNode.next;
                curNode.next = newNode;
                curNode = curNode.next;
            }
        }
    }

    //遍历当前的环形链表
    public void list(){
        if (first == null){
            System.out.println("[]");
            return;
        }
        BoyNode curNode = first;
        System.out.print("[");
        while(curNode.next != first){
            System.out.print(curNode.getNum());
            System.out.print(",");
            curNode = curNode.next;
        }
        System.out.print(curNode.getNum());
        System.out.println("]");
    }

    //节点个数
    public int size(){
        if (first == null){
            return 0;
        }
        int sum = 0;
        BoyNode curNode = first;
        while(true){
            sum++;
            if (curNode.next == first){
                break;
            }
            curNode = curNode.next;
        }
        return sum;
    }

    //约瑟夫问题
    /**
     *
     * @param start 从哪个小孩开始数
     * @param m 每次数几个
     * @param sum 表示最初共有几个小孩
     */
    public void josephu(int start, int m, int sum) {
        if (first == null || start < 1 || start > sum) {
            System.out.println("参数输入有误，请重新输入：");
            return;
        }
        BoyNode preNode = first;
        BoyNode curNode = first;
        while(preNode.next != first){
            preNode = preNode.next;
        }
        //移动到第start个小孩
        for (int i = 0; i < start - 1; i++) {
            first = first.next;
            preNode = preNode.next;
        }
        System.out.print("[");
        while(first.next != first){
            for (int i = 0; i < m - 1; i++) {
                first = first.next;
                preNode = preNode.next;
            }
            System.out.print(first.getNum());
            System.out.print(",");
            preNode.next = first.next;
            first = first.next;
        }
        System.out.print(first.getNum());
        System.out.println("]");
    }

    public BoyNode getFirst() {
        return first;
    }
}
//创建一个节点
class BoyNode{
    private int num;
    public BoyNode next;

    public BoyNode() {
    }
    public BoyNode(int num) {
        this.num = num;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }
}
\end{lstlisting}
\chapter{栈}
\section{栈的知识}
1.栈的英文是stack；

2.栈的元素先进后出

3.出栈：pop

4.入栈：push
\section{栈的应用场景}

1.子程序的调用；

2.处理递归调用

3.表达式的转换（中缀表达式转后缀表达式）与求值（使用后缀表达式求值）

4.二叉树的遍历

5.图形的深度优先搜索算法
\section{代码实现}
\subsection{思路分析}
1.使用数组模拟栈；

2.\dm{top}表示栈顶，初始化为\dm{-1}。

3.入栈：\dm{arr[++top] = num;}

4.出栈：\dm{return arr[top--]}

\subsection{数组实现}
\begin{lstlisting}
import java.util.Random;
import java.util.Scanner;

public class ArrayStackDemo {
    public static void main(String[] args) {
//栈的测试室代码：
        Scanner scanner = new Scanner(System.in);
        System.out.println("栈的测试：");
        System.out.println("请输入栈的规模");
        int capacity = scanner.nextInt();
        ArrayStack arrayStack = new ArrayStack(capacity);
        String key = "";
        boolean loop = true;
        while (loop) {
            System.out.println("------------------------------------------");
            System.out.println("s(Show):显示栈");
            System.out.println("e(Exit):退出栈");
            System.out.println("p(Pop):弹出栈顶元素");
            System.out.println("pu(Push):往栈中加入元素");
            System.out.println("t(TopValue)：查看栈顶元素");
            System.out.println("请输入你的选择：");
            key = scanner.next();
            switch (key) {
                case "t":
                    try {
                        int num = arrayStack.topValue();
                        System.out.println(num);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case "pu":
                    int num = randomNum();
                    System.out.println("要加入栈的元素是：" + num);
                    arrayStack.push(num);
                    break;
                case "p":
                    try {
                        int num1 = arrayStack.pop();
                        System.out.println(num1);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case "s":
                    arrayStack.list();
                    break;
                case "e":
                    scanner.close();
                    loop = false;
                    System.out.println("程序退出");
                    break;
            }
        }
    }

    public static int randomNum() {
        Random random = new Random();
        return random.nextInt(1000) + 1;
    }
}

class ArrayStack {
    private final int capacity;
    private int size;
    private int[] stack;
    private int top = -1;
    private int bottom = -1;

    public ArrayStack(int capacity) {
        this.capacity = capacity;
        stack = new int[capacity];
    }

    //判断栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //判断栈满
    public boolean isFully() {
        return top == capacity - 1;
    }

    //栈的元素
    public int size() {
        return top + 1;
    }

    //入栈
    public void push(int data) {
        if (isFully()) {
            System.out.println("栈满，无法添加！");
            return;
        }
        stack[++top] = data;
    }

    //出栈
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈空，没有元素可以出栈！");
        }
        return stack[top--];
    }

    //遍历栈:从栈顶向栈底显示元素
    public void list() {
        if (isEmpty()) {
            System.out.println("[]");
            return;
        }
        System.out.print("[");
        for (int i = top; i > bottom; i--) {
            System.out.print(stack[i]);
            if (i != 0) {
                System.out.print(",");
            }
        }
        System.out.println("]");
    }

    //显示栈顶元素
    public int topValue() {
        if (isEmpty()) {
            throw new RuntimeException("栈空，没有元素可以出栈！");
        }
        return stack[top];
    }
}
\end{lstlisting}

\subsection{单链表实现}
\begin{lstlisting}
import java.util.Random;
import java.util.Scanner;

public class SingleLinkedListStackDemo {

    public static int randomNum() {
        Random random = new Random();
        return random.nextInt(1000) + 1;
    }

    public static void main(String[] args) {
        //栈的测试代码：
        Scanner scanner = new Scanner(System.in);
        System.out.println("栈的测试：");
        System.out.println("请输入栈的规模");
        int capacity = scanner.nextInt();
        SingleLinkedListStack stack = new SingleLinkedListStack(capacity);
        String key = "";
        boolean loop = true;
        while (loop) {
            System.out.println("------------------------------------------");
            System.out.println("s(Show):显示栈");
            System.out.println("e(Exit):退出栈");
            System.out.println("p(Pop):弹出栈顶元素");
            System.out.println("pu(Push):往栈中加入元素");
            System.out.println("t(TopValue)：查看栈顶元素");
            System.out.println("请输入你的选择：");
            key = scanner.next();
            switch (key) {
                case "t":
                    try {
                        int num = stack.topValue();
                        System.out.println(num);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case "pu":
                    int num = randomNum();
                    System.out.println("要加入栈的元素是：" + num);
                    stack.push(num);
                    break;
                case "p":
                    try {
                        int num1 = stack.pop();
                        System.out.println(num1);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case "s":
                    stack.list();
                    break;
                case "e":
                    scanner.close();
                    loop = false;
                    System.out.println("程序退出");
                    break;
            }
        }
    }

    static class SingleLinkedListStack {
        private Node top;
        private final int capacity;

        public SingleLinkedListStack(int capacity) {
            this.capacity = capacity;
        }

        public boolean isEmpty() {
            return top == null;
        }

        public boolean isFull() {
            return size() == capacity;
        }

        public int size() {
            int sum = 0;
            Node curNode = top;
            while (curNode != null) {
                sum++;
                curNode = curNode.next;
            }
            return sum;
        }

        public void push(int num) {
            if (isFull()) {
                System.out.println("栈满，无法加入！");
                return;
            }
            Node node = new Node(num);
            node.next = top;
            top = node;
        }

        public int pop() {
            if (isEmpty()) {
                throw new RuntimeException("栈空，无法取出元素！");
            }
            int value = top.getNum();
            top = top.next;
            return value;
        }

        public int topValue() {
            return top.getNum();
        }

        public void list() {
            Node curNode = top;
            System.out.print("[");
            while (curNode != null) {
                System.out.print(curNode.getNum());
                if (curNode.next != null) {
                    System.out.print(",");
                }
                curNode = curNode.next;
            }
            System.out.println("]");
        }
    }

    static class Node {
        private int num;
        public Node next;

        public Node(int num) {
            this.num = num;
        }

        public int getNum() {
            return num;
        }
    }
}
\end{lstlisting}
\section{栈实现综合计算器}
数栈：用于存放数字

符号栈：用于存放符号

使用一个指针扫描字符串：

如果是数字就入数栈；

如果是符号：如果符号栈为空，该符号就直接入栈；如果符号栈有操作符，就要进行比较，如果该符号的优先级小于或者等于栈顶的操作符，需要从数栈弹出两个数字，从符号栈弹出一个操作符，进行运算，得到的结果入数栈，让该符号入操作符栈。如果该符号优先级大于符号栈栈顶的操作符，直接入栈。

扫描完毕后，顺序的从符号栈和数栈弹出相应的符号和数进行运算。

最后数栈只有一个数字，就是最终的运算结果。

\subsection{代码实现}
\begin{lstlisting}
public class Calculator {
    public static double cal(double x, double y, char ope) {
        double ret = 0;
        switch (ope) {
            case '/':
                if (y == 0) {
                    throw new RuntimeException("除数为0");
                }
                ret = x / y;
                break;
            case '*':
                ret = x * y;
                break;
            case '-':
                ret = x - y;
                break;
            case '+':
                ret = x + y;
                break;
            case '^':
                ret = Math.pow(x,y);
                break;
        }
        return ret;
    }

    public static int[] readNumber(String str, int index) {
        int ret = 0;
        while (index < str.length() && isNum(str.charAt(index))) {
            int x = str.charAt(index) - '0';
            ret = ret * 10 + x;
            index++;
        }
        return new int[]{ret, index};
    }

    //判断是否为运算符
    public static boolean isNum(char val) {
        return val >= '0' && val <= '9';
    }

    public static int opeNum(char ch) {
        int ret = -1;
        switch (ch) {
            case '+':
                ret = 0;
                break;
            case '-':
                ret = 1;
                break;
            case '*':
                ret = 2;
                break;
            case '/':
                ret = 3;
                break;
            case '^':
                ret = 4;
                break;
            case '!':
                ret = 5;
                break;
            case '(':
                ret = 6;
                break;
            case ')':
                ret = 7;
                break;
            case'\0':
                ret = 8;
                break;
        }
        return ret;
    }

    //
    public static char orderBetween(char ch1, char ch2) {
        int num1 = opeNum(ch1);
        int num2 = opeNum(ch2);
        char pri[][] =  //运算符优先等级[栈顶][当前]
                {       //     |----------当前运算符-----------|
                        //竖的为栈顶运算符
                        //               +    -    *    /    ^    !    (    )
                        /* + */        {'>', '>', '<', '<', '<', '<', '<', '>','>'},
                        /* - */        {'>', '>', '<', '<', '<', '<', '<', '>','>'},
                        /* * */        {'>', '>', '>', '>', '<', '<', '<', '>','>'},
                        /* / */        {'>', '>', '>', '>', '<', '<', '<', '>','>'},
                        /* ^ */        {'>', '>', '>', '>', '>', '<', '<', '>','>'},
                        /* ! */        {'>', '>', '>', '>', '>', '>', ' ', '>','>'},
                        /* ( */        {'<', '<', '<', '<', '<', '<', '<', '=',' '},
                        /* ) */        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',' '},
                        /* \0 */       {'<', '<', '<', '<', '<', '<', '<', ' ','='}
                };
        return pri[num1][num2];
    }

    public static void main(String[] args) {
        String expression = "13+2*(6-2)+5/2";
        ArrayStack<Double> numStack = new ArrayStack<>(100);
        ArrayStack<Character> opeStack = new ArrayStack<>(100);
        int index = 0;
        char ope = '0';
        char ch = ' ';//将每次扫描得到的char保存到ch中
        opeStack.push('\0');
        while (!(opeStack.isEmpty())) {
            if(index < expression.length()){
                ch = expression.charAt(index);
            }else{
                ch = '\0';
            }
            if (isNum(ch)) {
                int[] arr = readNumber(expression, index);
                double x = (double)arr[0];
                numStack.push(x);
                index = arr[1];
            } else {
                if (opeStack.isEmpty()) {
                    opeStack.push(ch);
                    index++;
                } else {
                    switch (orderBetween(opeStack.topValue(), ch)) {
                        case '>':
                            ope = opeStack.pop();
                            if (ope == '!') {
                                double x = numStack.pop();
                                numStack.push((double)fac((int)x));
                            }else{
                                double y = numStack.pop();
                                double x = numStack.pop();
                                double value = cal(x,y,ope);
                                numStack.push(value);
                            }
                            break;
                        case '<':
                            opeStack.push(ch);
                            index++;
                            break;
                        case '=':
                            opeStack.pop();
                            index++;
                            break;
                    }
                }
            }
        }
        System.out.println(numStack.pop());
    }

    private static int fac(int num) {
        if (num == 0 || num == 1){
            return 1;
        }
        return num * fac(num - 1);
    }

    public static void print(ArrayStack arrayStack) {
        arrayStack.list();
    }
}
\end{lstlisting}
\section{栈应用--逆波兰表达式}

前缀表达式又称波兰式，表达式的运算符位于操作数之前。

逆波兰表达式求值：从左至右扫描，遇数入栈，遇到符号则弹出栈顶元素进行计算。

\subsection{逆波兰表达式代码的实现}
\begin{lstlisting}
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
    public static void main(String[] args) {
        String suffixExpression = "30 4 + 5 * 6 -";
        List<String> list = getList(suffixExpression);
        System.out.println(suffixExpression + " = " + cal(list));
    }
    //将逆波兰表达式放入顺序表中
    public static List<String> getList(String str){
        List<String> list = new ArrayList<>();
        int index = 0;
        String str1[] = str.split(" ");
        for (String s:str1) {
            list.add(s);
        }
        return list;
    }
    //完成对逆波兰表达式的运算
    public static int cal(List<String> list){
        Stack<String> stack = new Stack<>();
        for (String ch: list) {
            if (ch.matches("\\d+")){//匹配多位数
                stack.push(ch);
            }else{
                if ("!".equals(ch)){
                    int num = Integer.parseInt(stack.pop());
                    stack.push("" + fac(num));
                }else{
                    int num2 = Integer.parseInt(stack.pop());
                    int num1 = Integer.parseInt(stack.pop());
                    int ret = 0;
                    switch (ch){
                        case "+":
                            ret = num1 + num2;
                            break;
                        case "-":
                            ret = num1 - num2;
                            break;
                        case "*":
                            ret = num1 * num2;
                            break;
                        case "/":
                            ret = num1 / num2;
                            break;
                        case "^":
                            ret = (int)Math.pow((double)num1,(double)num1);
                            break;
                        default:
                            throw new RuntimeException("运算符有误");
                    }
                    stack.push("" + ret);
                }
            }
        }
        return Integer.parseInt(stack.pop());
    }

    private static int fac(int num) {
        if (num == 0 || num == 1){
            return 0;
        }
        return num * fac(num -1);
    }
}
\end{lstlisting}
\subsection{中缀表达式转后缀表达式}
\subsubsection{思路}
1.初始化两个栈\dm{stack1}、\dm{stack2}。

2.从左至右扫描中缀表达式。

3.遇到操作数，压入\dm{stack2}

4.遇到运算符，比较该符号与\dm{stack1}运算符的优先级：
\begin{itemize}
  \item 若\dm{stack1}为空，或栈顶运算符为\dm{(}，将该运算符压入\dm{stack1}。
  \item 若优先级比栈顶的运算符高，也将运算符压入\dm{stack1}。
  \item 否则，将\dm{stack1}栈顶元素弹出压入到\dm{stack2}中，再次跳转到4-1步与\dm{stack1}栈顶运算符相比较。
\end{itemize}

5.遇到括号：
\begin{itemize}
  \item \dm{(}：直接入\dm{stack1}
  \item \dm{)}：依次弹出\dm{stack1}运算符将其压入\dm{stack2}，遇到\dm{(}，将这一对括号丢弃。
\end{itemize}

6.重复2-5步，直到中缀表达式扫描结束。

7.将\dm{stack1}剩余符号全部弹出压入\dm{stack2}。

8.\dm{stack2}从栈顶至栈底则是逆波兰表达式。
\begin{lstlisting}
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

//中缀表达式转后缀表达式
public class ToRPN {
    public static void main(String[] args) {
        String expression = "1+((2+3)*4)-5";
        List<String> list = toList(expression);
        System.out.println(list);
        System.out.println(parsrSuffixExpreesionToRPN(list));
    }

    //中缀表达式转成对应的list
    public static List<String> toList(String str) {
        List<String> list = new ArrayList<>();
        int index = 0;
        StringBuilder stringBuilder = new StringBuilder();
        while (index < str.length()) {
            if (str.charAt(index) == ' ') {
                index++;
            } else if (str.charAt(index) >= '0' && str.charAt(index) <= '9') {
                while (index < str.length() && str.charAt(index) >= '0' && str.charAt(index) <= '9') {
                    stringBuilder.append(str.charAt(index));
                    index++;
                }
                list.add(stringBuilder.toString());
                stringBuilder.delete(0, stringBuilder.length());
            } else {
                list.add("" + str.charAt(index));
                index++;
            }
        }
        return list;
    }

    //中缀表达式转为逆波兰表达式
    public static List<String> parsrSuffixExpreesionToRPN(List<String> list) {
        List<String> rpn = new ArrayList<>();//存储中间结果和
        Stack<String> stack1 = new Stack<>();//符号栈
        for (String str : list) {
            if (str.matches("\\d+")) {
                rpn.add(str);
            } else if ("(".equals(str)) {
                stack1.push(str);
            } else if (")".equals(str)) {
                while (!stack1.peek().equals("(")) {
                    rpn.add(stack1.pop());
                }
                stack1.pop();
            } else {
                //符号栈不为空或者符号栈栈顶不是(或者该符号优先级不大于栈顶符号
                while (!(stack1.size() == 0 || stack1.peek().equals("(")) && !(getValue(str) > getValue(stack1.peek()))) {
                    rpn.add(stack1.pop());
                }
                //否则符号入栈
                stack1.push(str);
            }
        }
        while (!stack1.isEmpty()) {
            rpn.add(stack1.pop());
        }
        return rpn;
    }

    //优先级
    public static int getValue(String str) {
        int add = 1;
        int sub = 1;
        int mul = 2;
        int div = 2;

        int ret = 0;
        switch (str) {
            case "+":
                ret = add;
                break;
            case "-":
                ret = sub;
                break;
            case "*":
                ret = mul;
                break;
            case "/":
                ret = div;
                break;
        }
        return ret;
    }
}
\end{lstlisting}

\chapter{递归}

可以解决的问题：

1.八皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子问题。

2.快速排序、归并排序、二分查找、分治算法等等。

3.将用栈解决的问题

递归遵守的规则：

1.执行一个方法时，就创建一个新的受保护的独立栈空间

2.方法的局部变量是独立的，不会相互影响，如果是引用类型的变量，就会共享该引用类型的数据。

3.递归必须向递归基逼近

4.当一个方法执行完毕，或者遇到\dm{return}，就会返回，谁调用就返回给谁。
\section{迷宫问题}
\begin{lstlisting}
public class Maze {
    public static void main(String[] args) {
        //先创建一个二维数组模拟迷宫
        final int row = 8;
        final int col = 8;
        //迷宫地图
        int[][] map = new int[row][col];
        //使用1来表示迷宫的墙壁
        for (int i = 0; i < col; i++) {
            map[0][i] = 1;
            map[row - 1][i] = 1;
        }
        for (int i = 1; i < row - 1; i++) {
            map[i][0] = 1;
            map[i][col - 1] = 1;
        }
        //地图中的挡板
        map[3][1] = 1;
        map[3][2] = 1;
        map[1][2] = 1;
//        map[2][2] = 1;
        //输出地图
        printMaze(map);

        //使用递归回溯来给小球找路
        System.out.println("----------------------------");
        setWay(map,1,1);
        printMaze(map);
    }
    //打印迷宫地图
    public static void printMaze(int[][] map){
        for (int[] arr: map) {
            for (int i = 0; i < arr.length; i++) {
                System.out.print(arr[i]);
                if (i != arr.length-1){
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
    }
    //小球找路
    //map表示地图
    //出口为地图的右下角，即map[clo - 1 - 1][row - 1 - 1]
    //当map[i][j]为0，表示该点没有走过
    //当map[i][j]为1，表示该点为墙
    //当map[i][j]为2，表示该点走过，且是通路
    //当map[i][j]为3，表示该点走过，但是不是通路
    //走迷宫时，需要确定一个策略：先下再右再上再左。如果该点走不通，再回溯
    /**
     *
     * @param map 表示地图
     * @param i 表示开始位置的横坐标
     * @param j 表示开始位置的横坐标
     * @return 找路结果，找到为true
     */
    public static boolean setWay(int[][] map,int i,int j){
        int x = map.length;
        int y = map[0].length;
        if(map[x - 1 - 1][y - 1 - 1] == 2){//通路已找到
            return true;
        }else{
            if (map[i][j] == 0){//当前的点还没走过
                //按照策略玩
                map[i][j] = 2;//假定该点可以走通
                if(setWay(map,i+1,j)){//向下
                    return true;
                }else if(setWay(map,i,j+1)){//向右
                    return true;
                }else if(setWay(map,i-1,j)){//向上
                    return true;
                }else if(setWay(map,i,j-1)){//向左
                    return true;
                }else{//向四个方向都没走通，说明该点是死路
                    map[i][j] = 3;
                    return false;
                }
            }else{//某点不等于0，可能为1（墙）、2（通路）、3（死路）
                    return false;
            }
        }
    }
}
\end{lstlisting}

\section{八皇后问题}

问题描述：在8*8的棋盘上摆放八颗棋子，任意两颗棋子不能处于同一行、同一列或同一斜线上，问共有多少种摆法。
\subsection{思路分析}
1.第一个皇后先放到第一行第一列。

2.第二个皇后放在第二行第一列，判断是否OK，如果不OK，继续放在第二列、第三列……依次把所有的列放完后，找到一个合适的位置

3.下一个皇后同上边第二步

4.当得到一个正确解时，在退回到上一个栈，就会开始回溯，即将第一个皇后放到第一列的所有正确解全部得到

5.继续第一个皇后放到第二列，继续循环执行1-4步。

\subsection{代码实现}
\begin{lstlisting}
import java.util.Arrays;

public class QueenEight {
    //皇后的个数
    final static int capacity = 8;
    //定义一个一维数组存放皇后的位置
    int[] pos = new int[capacity];
    //解法
    static int count;
    public static void main(String[] args) {
        new QueenEight().check(capacity);
    }
    //将皇后摆放的位置输出
    private  void print(){
        System.out.println(Arrays.toString(pos));
    }

    //放置皇后
    private void check(int n){
        int x = capacity - n;
        if (x == capacity){//共8个皇后，x从0开始的，n等于8说明全部放完了
            System.out.print("第" + (++count) + "种解法：");
            print();
            return;
        }
        //依次放入皇后，并判断是否冲突
        for (int i = 0; i < capacity; i++) {
            //先把当前这个皇后x，放到该行的第1列
            pos[x] = i;
            //放置后判断是否冲突
            if(judge(x)){//不冲突就放下一个皇后
                check(n - 1);
            }
            //冲突就把该皇后放到下一个位置
        }
    }

    //当放第n个皇后，检测是否和前面已经摆放的皇后冲突
    /**
     *
     * @param n 第n个皇后,n从0开始
     * @return 冲突：false，不冲突：true
     */
    private boolean judge(int n){
        for (int i = 0; i < n; i++) {
            //pos[i] == pos[n]表示第n个皇后和第i个皇后位于同一列
            //Math.abs(n - i) == Math.abs(pos[n] - pos[i])表示第n个皇后和第i个皇后位于同一斜线
            if (pos[i] == pos[n] || Math.abs(n - i) == Math.abs(pos[n] - pos[i])){
                return false;
            }
        }
        return true;
    }
}
\end{lstlisting}
\chapter{排序算法}
\section{冒泡排序}
1.一共要进行数据规模- 1次排序
\subsection{代码实现}

\begin{lstlisting}
package com.atWSN.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.Random;
import java.util.Scanner;

public class BubbleSort {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入问题的规模：");
        int num = scanner.nextInt();
        int[] arr = new int[num];
        //初始化数组
        initArr(arr);
        //排序前数组
//        System.out.println("=================");
//        System.out.print("排序前：");
//        print(arr);
        //排序
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间：" + date1Str);
        bubbleSort(arr);
        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间：" + date2Str);
        //排序后数组
//        System.out.println("=================");
//        System.out.print("排序后：");
//        print(arr);
    }

    private static void bubbleSort(int[] arr) {
        boolean flag = true;
        for (int i = 0; i < arr.length - 1; i++) {
            flag = true;
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if(arr[j] > arr[j + 1]){
                    flag = false;
                    int tmp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = tmp;
                }
            }
           // System.out.println(Arrays.toString(arr));
            if (flag){
                break;
            }
        }
    }

    private static void print(int[] arr) {
        System.out.println(Arrays.toString(arr));
    }

    private static void initArr(int[] arr) {
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(2000) - 1000;
        }
    }
}
\end{lstlisting}

\section{选择排序}
从前向后遍历数组，从未排序数组中选择最小的数据与未排序数组中的第一个元素进行交换。

或者从后向前遍历数组，从未排序的数组中选择最大的数据与未排序数组中的最后一个元素进行交换。
\subsection{代码实现}
\begin{lstlisting}
import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;

public class SelectSort {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入问题的规模：");
        int num = scanner.nextInt();
        int[] arr = new int[num];
        //初始化数组
        initArr(arr);
        //排序前数组
        System.out.println("=================");
        System.out.print("排序前：");
        print(arr);
        //排序
        selectSort(arr);
        //排序后数组
        System.out.println("=================");
        System.out.print("排序后：");
        print(arr);
    }

    private static void selectSort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            int min = arr[i];
            int index = i;
            for (int j = i + 1; j < arr.length; j++) {
                if(arr[j] == min){
                    break;
                }else if (arr[j] < min){
                    min = arr[j];
                    index = j;
                }
            }
            if (!(i == index)){
                int tmp = arr[i];
                arr[i] = arr[index];
                arr[index] = tmp;
            }
            System.out.println("第" + (i + 1) +"轮排序");
            print(arr);
        }
    }

    private static void print(int[] arr) {
        System.out.println(Arrays.toString(arr));
    }

    private static void initArr(int[] arr) {
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(10) + 1;
        }
    }
}
\end{lstlisting}
\section{插入排序}
基本思想：把n个待排序的元素看成一个有序表和无序表，开始时有序表只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，从有序中查找到插入的位置，将其插入到有序表的适当位置，使之成为新的有序表。
\subsection{代码实现}
\begin{lstlisting}[title = 未排序数组类]
import java.util.Arrays;
import java.util.Random;

public class unSortArray {
    private final int capacity;
    public int[] arr;

    public unSortArray(int capacity){
        this.capacity = capacity;
        arr = new int[this.capacity];
        Random random = new Random();
        for (int i = 0; i < capacity; i++) {
            arr[i] = random.nextInt(capacity) + 1;
        }
    }
    public void print(){
        System.out.println(Arrays.toString(arr));
    }
}

\end{lstlisting}
\begin{lstlisting}[title = 插入排序]
import java.util.Scanner;

//插入排序
public class InsertSort {
    public static void main(String[] args) {
        System.out.println("请输入数据的规模：");
        int capacity = new Scanner(System.in).nextInt();
        unSortArray unSortArray = new unSortArray(capacity);
        System.out.println("------------------");
        System.out.println("排序前：");
        unSortArray.print();
        //排序
        insertSort(unSortArray.arr);
        System.out.println("------------------");
        System.out.println("排序后：");
        unSortArray.print();
    }
    //插入排序
    private static void insertSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int insertVal = arr[i];
            int index = i;
            for (int j = 0; j < i; j++) {
                if (arr[j] > insertVal){
                    index = j;
                    break;
                }
            }
            if (!(index == i)) {
                for (int j = i; j > index; j--) {
                    arr[j] = arr[j - 1];
                }
                arr[index] = insertVal;
            }
        }
    }
    //版本2
    public static void insertSort1(int[] arr){
        if (arr.length <= 1){
            return;
        }
        for (int i = 1; i < arr.length; i++) {
            int index = i - 1;
            int insertValue = arr[i];
            while(index >= 0 && insertValue < arr[insertValue]){
                arr[index + 1] = arr[index];
                index--;
            }
            if (!(index == i - 1)) {
                arr[index] = insertValue;
            }
        }
    }
}
\end{lstlisting}
\section{希尔排序}

\subsection{代码实现}
先分组再进行选择排序。
\begin{lstlisting}
import java.util.Scanner;

public class ShellSort {
    public static void main(String[] args) {
        System.out.println("请输入问题的规模：");
        int capacity = new Scanner(System.in).nextInt();
        unSortArray unSortArray = new unSortArray(capacity);
        System.out.println("排序前：");
        unSortArray.print();
        //排序
        shellSort2(unSortArray.arr);
        System.out.println("------------------");
        System.out.println("排序后：");
        unSortArray.print();
    }

    private static void shellSort1(int[] arr) {
        if (arr.length < 2){
            return;
        }
        for (int step = arr.length/2; step > 0 ; step /= 2) {
            //遍历各组中所有元素，每组元素有step个
            for (int i = step; i < arr.length; i++) {
                //交换法：从每组的倒数第二个元素开始，与它的后一个元素比较，若大于就交换，每次向前移动
                for (int j = i - step; j >= 0; j -= step) {
                    if (arr[j] > arr[j + step]){
                        int tmp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = tmp;
                    }
                }
            }
        }
    }

    //优化shell排序：移位法
    public static void shellSort2(int[] arr){
        if(arr.length < 2){
            return;
        }
        for (int step = arr.length/2; step > 0; step /= 2) {
            //step表示组数
            //从第step个元素开始，对其所在的组进行插入排序
            for (int i = step; i < arr.length; i++) {
                int j = i - step;
                int value = arr[i];
                while (j >= 0 && arr[j] > value){
                    arr[j + step] = arr[j];
                    j -= step;
                }
                if(!(j == i - step)){
                    arr[j + step] = value;
                }

            }
        }
    }
}
\end{lstlisting}
\section{快速排序}
基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，再按此方法对这两部分进行快速排序，整个排序过程可以递归进行。

关键在于轴点的构造。
\subsection{代码实现}
\begin{lstlisting}
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class QuickSort {
    public static void main(String[] args) {
        System.out.println("请输入数据的规模：");
        int capacity = new Scanner(System.in).nextInt();
        unSortArray unSortArray = new unSortArray(capacity);
//        System.out.println("------------------");
//        System.out.println("排序前：");
//        unSortArray.print();
        //排序\
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间：" + date1Str);
        quickSort(unSortArray.arr,0,unSortArray.arr.length - 1);
        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间：" + date2Str);
//        System.out.println("------------------");
//        System.out.println("排序后：");
//        unSortArray.print();
    }

    public static void quickSort (int[] arr, int lo,int hi){
        if(hi - lo < 1){
            return;
        }
        int mid = partition(arr,lo, hi);//mid位置处的元素已就位，即轴点。
        quickSort(arr,lo,mid - 1);//前缀排序
        quickSort(arr,mid + 1,hi);//后缀排序
    }
    //构造轴点
    private static int partition(int[] arr,int lo, int hi) {
        int left = lo;//左指针
        int right = hi;//右指针
        int value = arr[lo];//轴点的值，一般取区间第一个
        while (left < right) {
            //如果右边的值不小于轴点，右指针左移
            while((left < right) && value <= arr[right]){
                right--;
            }
            //右边的值小于轴点的值，取出该值放入左指针所指的值，同时左指针右移一个单位
            if(left < right){
                arr[left] = arr[right];
                left++;
            }
            //如果左指针指的值不大于轴点值，左指针右移
            while((left < right) && value >= arr[left]){
                left++;
            }
            //左指针的值大于轴点的值，取出该值放入右指针所指的位置，同时右指针左移
            if(left < right){
                arr[right] = arr[left];
                right--;
            }
        }
        //循环退出的条件是左指针右指针重合，
        // 其含义表示该位置左边的值都小于轴点，
        // 该位置右边的值都大于轴点
        //把轴点的值放入该位置，同时返回该位置。
        arr[left] = value;
        return left;
    }
}
\end{lstlisting}
\section{归并排序}
利用归并的思想实现排序的方法，采用经典的分治算法。
\subsection{代码实现}
\begin{lstlisting}
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.Scanner;

public class MergeSort {
    public static void main(String[] args) {
        System.out.println("请输入数据的规模：");
        int capacity = new Scanner(System.in).nextInt();
        unSortArray unSortArray = new unSortArray(capacity);
//        System.out.println("------------------");
//        System.out.println("排序前：");
//        unSortArray.print();
        //排序
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间：" + date1Str);
        mergeSort(unSortArray.arr,0,unSortArray.arr.length - 1);
        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间：" + date2Str);
//        System.out.println("------------------");
//        System.out.println("排序后：");
//        unSortArray.print();
//        int[] arr = {1, 8, 4, 7, 3, 6, 5, 2};
//        mergeSort(arr, 0,  arr.length - 1);
    }

    private static void mergeSort(int[] arr, int left, int right) {

        if (right - left == 0) {
            return;
        }
        int mid = left + ((right - left) >> 1);
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }

    /**
     * @param arr   待排序的数组
     * @param left  左边有序的左边界
     * @param mid   左边有序的右边界，右边有序的左边界的前一个位置
     * @param right 右边有序的右边界
     */
    private static void merge(int[] arr, int left, int mid, int right) {
        int[] tmp = Arrays.copyOfRange(arr, left, mid + 1);
        int lo1 = 0;
        int lo2 = mid + 1;
        int i = left;
        while (lo1 < tmp.length && lo2 <= right) {
            if (tmp[lo1] <= arr[lo2]) {
                arr[i++] = tmp[lo1++];
            } else {
                arr[i++] = arr[lo2++];
            }
        }
        while (i <= right) {
            if (lo1 < tmp.length) {
                arr[i++] = tmp[lo1++];
            }
            if (lo2 <= right) {
                break;
            }
        }
    }
}
\end{lstlisting}
\section{基数排序}
基数排序属于分配式排序，又称桶子法或bin sort。属于稳定排序。

思想：

1.将所有待比较数值统一为同样的长度，数位较短的数前补0，从最低位开始，依次进行依次排序。从最低位排序一直到最高位排序完成以后，数列变成一个有序序列。
\subsection{代码实现}
\begin{lstlisting}
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class RadixSort {
    public static void main(String[] args) {
        System.out.println("请输入数据的规模：");
        int capacity = new Scanner(System.in).nextInt();
        unSortArray unSortArray = new unSortArray(capacity);
//        System.out.println("------------------");
//        System.out.println("排序前：");
//        unSortArray.print();
        //排序
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间：" + date1Str);
        radixSort(unSortArray.arr);
        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间：" + date2Str);
//        System.out.println("------------------");
//        System.out.println("排序后：");
//        unSortArray.print();
    }
    public static void radixSort(int[] arr){
        //得到数组中最大的数
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max){
                max = arr[i];
            }
        }
        //得到最大位数
        int maxLength = ("" + max).length();
        //定义桶
        int[][] bucket = new int[10][arr.length];
        //记录每个桶中元素的个数
        int[] bucketElementCount = new int[10];
        for (int i = 0,n = 1; i < maxLength; i++ , n*=10) {
            for (int j = 0; j < arr.length; j++) {
                int digitOfElement = arr[j] / n % 10;//找到所在的桶
                //第一个为所在桶的位置
                //第二个为所在桶的指针位置
                bucket[digitOfElement][bucketElementCount[digitOfElement]++] = arr[j];
            }

            //把桶中的数据取出放入原数组
            int index = 0;
            for (int j = 0; j < bucketElementCount.length; j++) {
                if (!(bucketElementCount[j] == 0)){
                    for (int k = 0; k < bucketElementCount[j]; k++) {
                        arr[index++] = bucket[j][k];
                    }
                    //从桶中取出数据后，把该桶元素的个数归0
                    bucketElementCount[j] = 0;
                }
            }
        }
    }
}
\end{lstlisting}
\section{堆排序}
\subsection{堆}
堆是具有以下性质的完全二叉树：

每个节点的值都大于等于孩子节点的值，称为大顶堆。

每个节点的值都小于等于左右孩子节点的值称为小顶堆。

\subsection{堆排序的基本思想}
1.将待排序的序列构造成一个大顶堆；

2.此时，整个序列的最大值就是堆顶的根节点。

3.将该节点与末尾元素进行交换，此时末尾就为最大值。

4.剩余节点按照上述步骤进行。

\subsection{批量构造二叉堆}
\begin{lstlisting}
//构建堆

/**
 * @param arr    要构建的数组
 * @param i      要调整的最后一个非叶子节点
 * @param length 要调整的数组长度
 */

public static void adjustHeap(int[] arr, int i, int length) {
//先取出当前元素的值，保存在临时变量中
    int tmp = arr[i];
    //说明
    //1.k = i * 2 + 1是i节点的左子节点，
    for (int j = i * 2 + 1; j < length; j = j * 2 + 1) {
        if (j + 1 < length && arr[j] < arr[j + 1]) {//判断右子节点是否存在
            //右子节点的值大于左子节点，把指针指向右子节点
            j++;
        }
        if (arr[j] > tmp) {//孩子大于该值，就下滤
            arr[i] = arr[j];
            i = j;//让i指向j继续比较
        } else {
            break;
        }
    }
    //for结束后，已经将以i为父节点的树的最大值放在了最顶上
    arr[i] = tmp;
}
\end{lstlisting}
\subsection{代码实现}
\begin{lstlisting}
public class HeapSort {
    public static void main(String[] args) {
        int[] arr = new int[20];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = new Random().nextInt(100) + 1;
        }
        System.out.println(Arrays.toString(arr));
        heapSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void heapSort(int[] arr) {
        //先构建堆
        //从第一个叶子节点开始往前，直到根节点
        for (int j = (arr.length - 1 - 1) / 2; j >= 0; j--) {
            adjustHeap(arr, j, arr.length);
        }

        for (int i = arr.length - 1; i > 0; i--) {
            //上边构建堆后堆顶元素必然是最大，将其与尾元素进行交换
            int tmp = arr[0];
            arr[0] = arr[i];
            arr[i] = tmp;
            //交换后不满足堆序性，重新建堆
            adjustHeap(arr, 0, i);
        }
    }
}
\end{lstlisting}
\chapter{查找相关算法}
\section{顺序查找}
\subsection{代码实现}

\begin{lstlisting}
import java.util.Arrays;
import java.util.Scanner;

public class SeqSearch {
    public static void main(String[] args) {
        int[] arr = new Array(10).arr;
        System.out.println(Arrays.toString(arr));
        System.out.println("请输入要查找的数：");
        int num = new Scanner(System.in).nextInt();
        int ret = seqSearch(arr,num);
        if (ret == -1){
            System.out.println("未找到！");
        }else {
            System.out.println("该元素下标为" + ret);
        }

    }
    //找到第一个满足条件的下标
    public static  int seqSearch(int[] arr,int value){
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == value){
                return i;
            }
        }
        return -1;
    }
}
\end{lstlisting}
\section{二分查找}
\subsection{要求}
有序数组。
\subsection{代码实现}
\begin{lstlisting}
import java.util.Arrays;

public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {2,8,10,89,89,89,89,1000,1234};
        int target =  1;
        System.out.println(binarySearch(arr,0,arr.length - 1,target));
        System.out.println(binarySearch1(arr,target));
        System.out.println(Arrays.toString(binarySearch2(arr,target)));
        System.out.println(insert(arr,target));
    }
    //递归版本
    public static int binarySearch(int[] arr,int lo,int hi,int value){
        if (lo > hi){
            return -1;
        }
        int mid = lo + ((hi - lo) >> 1);
        int midValue = arr[mid];
        if(midValue < value){
           return binarySearch(arr,mid + 1,hi,value);
        }else if(value <midValue){
            return binarySearch(arr,lo,mid - 1,value);
        }else{
            return mid;
        }
    }
    //迭代版本
    public static int binarySearch1(int[] arr,int value){
        int lo = 0;
        int hi = arr.length;
        while (lo <= hi){
            int mid = lo + ((hi - lo) >> 1);
            if(value < arr[mid]){
                hi = mid - 1;
            }else if(value > arr[mid]){
                lo = mid + 1;
            }else{
                return mid;
            }
        }
        return -1;
    }

    //寻找插入值
    //如果元素存在，返回该元素最后一个所在的位置
    //如果元素不存在，返回其插入位置的前一个位置
    public static  int insert(int[] arr,int target){
        int lo = 0;
        int hi = arr.length;
        while (lo <= hi){
            int mid = lo + ((hi - lo) >> 1);
            if(target < arr[mid]){
                hi = mid - 1;
            }else if(target > arr[mid]){
                lo = mid + 1;
            }else{
                return findLast(arr,target);
            }
        }
        return lo - 1;
    }

    //找到数组中所有的目标值元素，返回其范围
    //没有则返回[-1,-1]
    public static int[] binarySearch2(int[] arr,int target){
        return new int[]{findFirst(arr,target),findLast(arr,target)};
    }

    private static int findLast(int[] arr, int target) {
        int lo = 0;
        int hi = arr.length;
        while (lo <= hi){
            int mid = lo + ((hi - lo) >> 1);
            if(target < arr[mid]){
                hi = mid - 1;
            }else if(target > arr[mid]){
                lo = mid + 1;
            }else{
                if(mid == arr.length - 1 || arr[mid + 1] != target){
                    return mid;
                }else{
                    lo = mid + 1;
                }
            }
        }
        return -1;
    }

    private static int findFirst(int[] arr, int target) {
        int lo = 0;
        int hi = arr.length;
        while (lo <= hi){
            int mid = lo + ((hi - lo) >> 1);
            if(target < arr[mid]){
                hi = mid - 1;
            }else if(target > arr[mid]){
                lo = mid + 1;
            }else{
                if(mid == 0 || arr[mid - 1] != target){
                    return mid;
                }else{
                    hi = mid - 1;
                }
            }
        }
        return -1;
    }
}
\end{lstlisting}
\section{插值查找算法}
插值查找算法的\dm{mid}公式：
\begin{equation*}
mid = low + \frac{key - a[low]}{a[high] - a[low]}(high - low)
\end{equation*}

\subsection{注意事项}
1.对于数据量大，关键字分布比较均匀的查找表来说，采用插值查找速度较快。

2.关键字分布不均匀的情况下，该方法不一定比折半查找要好。

\subsection{代码实现}
\begin{lstlisting}
public class InsertSearch {
    static int count;
    public static void main(String[] args) {
        int[] arr = new int[1000];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i + 1;
        }
        int ret = insertSearch(arr,7);
        System.out.println(ret);
        System.out.println(count);
    }

    public static int insertSearch(int[] arr,int target){
        if (target < arr[0] || target > arr[arr.length - 1]){
            return -1;
        }
        int lo = 0;
        int hi = arr.length - 1;
        while(lo <= hi){
            int mid  = lo + (hi - lo)*(target - arr[lo])/(arr[hi] - arr[lo]);
            count++;
            if(target < arr[mid]){
                hi = mid - 1;
            }else if(arr[mid] < target){
                lo = mid + 1;
            }else{
                return mid;
            }
        }
        return -1;
    }
}
\end{lstlisting}
\section{斐波那契（黄金分割）查找算法}
\begin{equation*}
mid = lo + F(k - 1) - 1
\end{equation*}

顺序表的长度不一定刚好等于F(k) - 1，所以需要将原来的顺序表长度增加至F(k) - 1。这里k值只要能使得F(k) - 1，恰好大于或等于顺序表的长度即可。
\begin{lstlisting}
while(F(k) - 1 < arr.length){
    k++;
}
\end{lstlisting}

\subsection{代码实现}
\begin{lstlisting}
import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;

public class FibSearch {
    public static void main(String[] args) {
//        int[] arr = {1,8,10,89,1000,1234,1235};
        int num = new Random().nextInt(100)+ 10;
        int[] arr = new int[num];
        for (int i = 0; i < num; i++) {
            arr[i] = new Random().nextInt(100)+ 10;
        }
        radixSort(arr);
        System.out.println(Arrays.toString(arr));
        System.out.println("请输入要查找的数：");
        int target = new Scanner(System.in).nextInt();
        int ret = fibSearch(arr,target);
        System.out.println(ret);
    }

    //mid = low + fib(k - 1) - 1;
    public static int fibSearch(int[] arr,int target){
        int lo = 0;
        int hi = arr.length - 1;
        int len = arr.length;
        int k = 0;//表示斐波那契数列分割数值下标
        int mid = 0;
        int[] fib = fib(arr.length);//获取斐波那契数列
        //获取斐波那契数列分割数值的下标
        while (fib[k] - 1 < arr.length){
            k++;
        }
        //如果数组长度小于斐波那契数列数 - 1的值，把数组扩容至斐波那契数列数 - 1
        if (!(fib[k] - 1 == arr.length)){
            int[] arrTmp = Arrays.copyOf(arr,fib[k] - 1);
            for (int i = arr.length; i < fib[k] - 1; i++) {
                //扩容部分的数为原数组最后一个元素
                arrTmp[i] = arr[arr.length - 1];
            }
            arr = arrTmp;
        }
        while (lo <= hi) {
            //数组长度为fib(k) - 1
            //mid把数组分为左边是fib(k - 1) - 1
            //右边长度是fib(k - 2) - 1
            //fib(k) - 1 = fib(k - 1) - 1 + fib(k - 2) - 1 + 1
            mid = lo + fib[k - 1] - 1;

            if (target < arr[mid]) {
                hi = mid - 1;
                k--;
            } else if(arr[mid] < target) {
                lo = mid + 1;
                k -= 2;
            } else{
                if(mid >= len){
                    return len - 1;
                }
                return mid;
            }
        }
        return -1;
    }

    public static int[] fib(int n){
        int[] arr = new int[n];
        if (n == 1){
            arr[0] = 1;
            return arr;
        }
        arr[0] = 1;
        if (n == 2){
            arr[1] = 1;
            return arr;
        }
        arr[1] = 1;
        for (int i = 2; i < n; i++) {
            arr[i] = arr[i - 1] + arr[i - 2];
        }
        return arr;
    }
}
\end{lstlisting}
\chapter{哈希表（散列表）hash}
一个上机题：

某公司，当员工来报道时，要求将该员工的信息加入（id，姓名），当输入该员工的id时，要求查找到该员工所有信息。

要求：不使用数据库，速度越快越好（可以使用哈希表）

添加时，保证按照id从低到高的顺序插入。
\subsection{散列函数}
决定值对应哪个桶

哈希表是一个链表数组，即数组中的每个元素都是一个链表。该链表的引用指向的是有效节点。

\section{代码实现}
\begin{lstlisting}
import java.util.Scanner;

public class HashTableDemo {
    public static void main(String[] args) {
        // 测试
        // 创建一个hash表
        HashTable hashTable = new HashTable(7);

        boolean flag = true;
        while (flag){
            System.out.println("----------------------------------------");
            System.out.println("a(add)：添加雇员！");
            System.out.println("l(list)：显示雇员！");
            System.out.println("f(find)：查找雇员！");
            System.out.println("d(del)：删除雇员");
            System.out.println("r(remove)：清空全部信息！");
            System.out.println("e(exit)：退出程序！");
            System.out.println("请输入选择：");
            String select = new Scanner(System.in).next();
            switch (select){
                case "e":
                    System.out.println("程序退出！");
                    flag = false;
                    break;
                case "a":
                    System.out.println("请输入员工id：");
                    int id = new Scanner(System.in).nextInt();
                    System.out.println("请输入员工姓名：");
                    String name = new Scanner(System.in).next();
                    Employee employee = new Employee(id,name);
                    hashTable.add(employee);
                    break;
                case "l":
                    hashTable.list();
                    break;
                case "f":
                    System.out.println("请输入要查找的雇员ID：");
                    int findId = new Scanner(System.in).nextInt();
                    Employee findEmployee = hashTable.findEmployeeById(findId);
                    if (findEmployee == null){
                        System.out.println("未找到该id对应的员工");
                    }else{
                        System.out.println(findEmployee);
                    }
                    break;
                case "d":
                    System.out.println("请输入要删除的雇员ID：");
                    int delId = new Scanner(System.in).nextInt();
                    hashTable.delEmployeeById(delId);
                    break;
                case "r":
                    hashTable.removeAll();
                    break;
                default:
                    System.out.println("输入错误，请重新输入：");
                    break;
            }
        }
    }
}
//一个雇员
class Employee{
    private int id;
    private String name;
    public Employee next;
    public Employee(){

    }
    public Employee(int id,String name){
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return "(id:" + id +
                ", name=" + name + ")";
    }
}

//创建employeeLinkedList，表示一条链表
class EmployLinkedList{
    private Employee head;

    //添加雇员到链表
    //添加雇员时，id总是增长的
    //所以把雇员添加在链表的末尾
    public void add(Employee employee){
        if (head == null){
            head = employee;
            return;
        }
        Employee preEmployee = head;
        while(preEmployee.next != null){
            preEmployee = preEmployee.next;
        }
        preEmployee.next = employee;
    }

    //删除雇员
    public void delEmployeeById(int id){
        Employee preEmployee = new Employee();
        Employee tmpEmployee;
        preEmployee.next = head;
        tmpEmployee = preEmployee;
        while(preEmployee.next != null){
            if (preEmployee.next.getId() == id){
                System.out.println("要删除的员工为：");
                System.out.println(preEmployee.next);
                preEmployee.next =  preEmployee.next.next;
                head = tmpEmployee.next;
                System.out.println("系统提示：删除成功");
                return;
            }
            preEmployee = preEmployee.next;
        }
        System.out.println("该雇员不在此表中，无法删除！");
        System.out.println("系统提示：删除失败");
    }

    public Employee getHead() {
        return head;
    }

    public void setHead(Employee head) {
        this.head = head;
    }

    //遍历链表的信息
    public void list(){
        if (head == null){
            System.out.print("[]");
            return;
        }

        Employee curEmployee = head;
        System.out.print("[");
        while (curEmployee != null){
            System.out.print(curEmployee.toString());
            if (curEmployee.next != null){
                System.out.print(",");
            }
            curEmployee = curEmployee.next;
        }
        System.out.print("]");
    }

    //查找某个员工
    public Employee findEmployeeById(int id){
        Employee curEmployee = head;

        while (curEmployee != null && curEmployee.getId() != id){
            curEmployee = curEmployee.next;
        }
        if (curEmployee != null){
            return curEmployee;
        }
        return curEmployee;
    }
}

//创建哈希表
class HashTable{
    private final int capacity;
    EmployLinkedList[] employLinkedLists;
    //构造方法
    public HashTable(int capacity){
        this.capacity = capacity;
        employLinkedLists = new EmployLinkedList[this.capacity];
        //此时该数组的每个元素都是null;要进行初始化
        for (int i = 0; i < capacity; i++) {
            employLinkedLists[i] = new EmployLinkedList();
        }
    }
    public void add(Employee employee){
        //根据员工的id，得到该员工应当添加到哪条链表
        employLinkedLists[hash(employee.getId())].add(employee);

    }

    public void list(){
        System.out.print("{");
        for (int i = 0; i < capacity; i++) {
            employLinkedLists[i].list();
            if (i != capacity - 1){
                System.out.print(",");
            }
        }
        System.out.println("}");
    }

    public Employee  findEmployeeById(int id){
        return employLinkedLists[hash(id)].findEmployeeById(id);
    }

    public void delEmployeeById(int id){
        employLinkedLists[hash(id)].delEmployeeById(id);
    }

    public void removeAll(){
        System.out.println("系统提示：清空所有信息，此操作不可撤销，是否真的要删除？（Y:删除，N：取消）");
        String  str = new Scanner(System.in).next();
        if ("Y".equalsIgnoreCase(str)){
            System.out.println("请再次确认是否要清空所有信息：（Y:确认，N：取消）");
            str = new Scanner(System.in).next();
            if (!("Y".equalsIgnoreCase(str))){
                return;
            }
            for (int i = 0; i < capacity; i++) {
                employLinkedLists[i].setHead(null);
            }
            System.out.println("系统提示：全部员工信息已删除！");
        }else{
            return;
        }

    }

    //编写散列函数：使用取模法来完成
    public int hash(int id){
        return id % this.capacity;
    }

}
\end{lstlisting}

\chapter{树}
\section{常用术语}
节点：

根节点：没有父节点的节点

子节点：

叶子结点：没有孩子的节点

节点的权：

路径：从根节点找到该节点的路线

层：根节点为第一层，孩子为第二层，孙子为第三层，依次类推。

子树：

树的高度：

路径：一棵树中，从一个节点往下可以达到的孩子或孙子节点之间的通路称为路径。

路径长度：通路中分支数目称为路径长度，若规定根节点层数为1，则从根节点到第L层节点的路径长度为L-1.

节点的权：若将树中节点的赋予一个含有某种含义的数值，称该数值为该节点的权。

节点带权路径长度：从根节点到该节点之间的路径长度与该节点的权的乘积。

树的带权路径长度：树的带权路径长度规定为所有叶子节点的带权路径长度之和，记为WPL（Weighted Path Length）,权值越大的节点离根节点越近的二叉树才是最优二叉树。
\section{二叉树}
每个节点最多只能有两个孩子。

满二叉树：所有叶子节点都在最后一层。节点总数为$2^n - 1$，$n$为层数。

完全二叉树：所有叶子结点都在最后一层或倒数第二层，且最后一层的叶子节点在左边连续，倒数第二层的叶子结点在右边连续。

一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。
\subsection{二叉树的遍历}
\subsubsection{前序遍历}
前序遍历即先遍历父节点，然后左子树，然后右子树。

\subsubsection{中序遍历}
先遍历左子树，再遍历父节点，再遍历右子树。
\subsubsection{后序遍历}
先遍历左子树，再遍历右子树，再遍历父节点。
\subsubsection{代码实现}
\begin{lstlisting}
public class BinaryTreeDemo {
    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();
        TreeNode treeNodeRoot = new TreeNode(1, "宋江");
        TreeNode treeNode1 = new TreeNode(2, "吴用");
        TreeNode treeNode2 = new TreeNode(3, "卢俊义");
        TreeNode treeNode3 = new TreeNode(4, "林冲");
        TreeNode treeNode4 = new TreeNode(5, "关胜");
        binaryTree.setRoot(treeNodeRoot);
        addLeft(treeNodeRoot, treeNode1);
        addRight(treeNodeRoot, treeNode2);
        addRight(treeNode2, treeNode3);
        addLeft(treeNode2, treeNode4);

        System.out.println("-------------------");
        binaryTree.preOrder();
        System.out.println("-------------------");
        binaryTree.infixOrder();
        System.out.println("-------------------");
        binaryTree.postOrder();

    }

    //插入左孩子
    public static void addLeft(TreeNode parentNode, TreeNode leftNode) {
        if (parentNode.leftChild != null) {
            System.out.println("该节点有左孩子，无法插入");
            return;
        }
        parentNode.leftChild = leftNode;
        leftNode.parent = parentNode;
    }

    //插入右孩子
    public static void addRight(TreeNode parentNode, TreeNode rightNode) {
        if (parentNode.rightChild != null) {
            System.out.println("该节点有左孩子，无法插入");
            return;
        }
        parentNode.rightChild = rightNode;
        rightNode.parent = parentNode;
    }
}

class BinaryTree {
    private TreeNode root;

    //前序遍历
    public void preOrder() {
        System.out.println("前序遍历的结果为：");
        if (this.root == null) {
            System.out.println("{}");
            return;
        }
        this.root.preOrder();
    }

    //中序遍历
    public void infixOrder() {
        System.out.println("中序遍历的结果为：");
        if (this.root == null) {
            System.out.println("{}");
            return;
        }
        this.root.infixOrder();
    }

    //后序遍历
    public void postOrder() {
        System.out.println("后序遍历的结果为：");
        if (this.root == null) {
            System.out.println("{}");
            return;
        }
        this.root.postOrder();
    }


    public TreeNode getRoot() {
        return root;
    }

    public void setRoot(TreeNode root) {
        this.root = root;
    }
}

class TreeNode {
    private int num;
    private String name;
    public TreeNode leftChild;
    public TreeNode rightChild;
    public TreeNode parent;

    public TreeNode() {

    }

    public TreeNode(int num, String name) {
        this.num = num;
        this.name = name;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    @Override
    public String toString() {
        return "TreeNode{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }

    //前序遍历的方法,迭代法
    public void preOrder() {
        System.out.println(this);
        if (!(this.leftChild == null)) {
            this.leftChild.preOrder();
        }
        if (!(this.rightChild == null)) {
            this.rightChild.preOrder();
        }
    }

    //中序遍历：递归法
    public void infixOrder() {
        if (!(this.leftChild == null)) {
            this.leftChild.infixOrder();
        }
        System.out.println(this);
        if (!(this.rightChild == null)) {
            this.rightChild.infixOrder();
        }
    }

    //后序遍历
    public void postOrder() {
        if (!(this.leftChild == null)) {
            this.leftChild.postOrder();
        }

        if (!(this.rightChild == null)) {
            this.rightChild.postOrder();
        }
        System.out.println(this);
    }
}
\end{lstlisting}
\subsection{查找指定节点}
要求：编写前序、中序、后序查找方法。

分别使用三中查找方式，查找指定节点。

分析各种查找方式分别比较了多少次。

前序查找思路：
\begin{itemize}
  \item 先判断当前节点的num是否等于要查找的。
  \item 如果相等，返回当前节点。
  \item 不相等，则判断当前左子节点是否为空，如果不为空，则递归前序查找。
  \item 左递归找到目标节点，返回目标节点，找不到就右子树递归查找。
\end{itemize}
\subsubsection{代码实现}
\begin{lstlisting}
public class BinaryTreeDemo {
    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();
        TreeNode treeNodeRoot = new TreeNode(1, "宋江");
        TreeNode treeNode1 = new TreeNode(2, "吴用");
        TreeNode treeNode2 = new TreeNode(3, "卢俊义");
        TreeNode treeNode3 = new TreeNode(4, "林冲");
        TreeNode treeNode4 = new TreeNode(5, "关胜");
        binaryTree.setRoot(treeNodeRoot);
        addLeft(treeNodeRoot, treeNode1);
        addRight(treeNodeRoot, treeNode2);
        addRight(treeNode2, treeNode3);
        addLeft(treeNode2, treeNode4);

        System.out.println("-------------------");
        binaryTree.preOrder();
        System.out.println("-------------------");
        binaryTree.infixOrder();
        System.out.println("-------------------");
        binaryTree.postOrder();
        System.out.println("-------------------");
        int target = 0;
        System.out.println(binaryTree.preOrderSearch(target));;
        System.out.println("-------------------");
        System.out.println(binaryTree.infixOrderSearch(target));;
        System.out.println("-------------------");
        System.out.println(binaryTree.postOrderSearch(target));;

    }

    //插入左孩子
    public static void addLeft(TreeNode parentNode, TreeNode leftNode) {
        if (parentNode.leftChild != null) {
            System.out.println("该节点有左孩子，无法插入");
            return;
        }
        parentNode.leftChild = leftNode;
        leftNode.parent = parentNode;
    }

    //插入右孩子
    public static void addRight(TreeNode parentNode, TreeNode rightNode) {
        if (parentNode.rightChild != null) {
            System.out.println("该节点有左孩子，无法插入");
            return;
        }
        parentNode.rightChild = rightNode;
        rightNode.parent = parentNode;
    }
}

class BinaryTree {
    private TreeNode root;

    //前序遍历
    public void preOrder() {
        System.out.println("前序遍历的结果为：");
        if (this.root == null) {
            System.out.println("{}");
            return;
        }
        this.root.preOrder();
    }

    public TreeNode preOrderSearch(int target) {
        return root.preOrderSearch(target);
    }

    //中序遍历
    public void infixOrder() {
        System.out.println("中序遍历的结果为：");
        if (this.root == null) {
            System.out.println("{}");
            return;
        }
        this.root.infixOrder();
    }

    public TreeNode infixOrderSearch(int target) {
        return root.infixOrderSearch(target);
    }

    //后序遍历
    public void postOrder() {
        System.out.println("后序遍历的结果为：");
        if (this.root == null) {
            System.out.println("{}");
            return;
        }
        this.root.postOrder();
    }

    public TreeNode postOrderSearch(int target) {
        return root.postOrderSearch(target);
    }

    public TreeNode getRoot() {
        return root;
    }

    public void setRoot(TreeNode root) {
        this.root = root;
    }
}

class TreeNode {
    private int num;
    private String name;
    public TreeNode leftChild;
    public TreeNode rightChild;
    public TreeNode parent;

    public TreeNode() {

    }

    public TreeNode(int num, String name) {
        this.num = num;
        this.name = name;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    @Override
    public String toString() {
        return "TreeNode{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }

    //前序遍历的方法,迭代法
    public void preOrder() {
        System.out.println(this);
        if (!(this.leftChild == null)) {
            this.leftChild.preOrder();
        }
        if (!(this.rightChild == null)) {
            this.rightChild.preOrder();
        }
    }

    //前序遍历查找指定节点

    /**
     * @param target 目标编号
     * @return 返回对应节点
     */
    public TreeNode preOrderSearch(int target) {
        if (this == null || this.num == target) {
            return this;
        }
        TreeNode targetNode = null;
        if (!(this.leftChild == null)) {
            targetNode = this.leftChild.preOrderSearch(target);
        }
        if (targetNode != null) {
            return targetNode;
        }
        if (!(this.rightChild == null)) {
            targetNode = this.rightChild.preOrderSearch(target);
        }
        return targetNode;
    }

    //中序遍历：递归法
    public void infixOrder() {
        if (!(this.leftChild == null)) {
            this.leftChild.infixOrder();
        }
        System.out.println(this);
        if (!(this.rightChild == null)) {
            this.rightChild.infixOrder();
        }
    }

    //中序遍历查找
    public TreeNode infixOrderSearch(int target) {
        if (this == null) {
            return this;
        }
        TreeNode targetNode = null;
        if (!(this.leftChild == null)) {
            targetNode = this.leftChild.infixOrderSearch(target);
        }
        if (targetNode != null) {
            return targetNode;
        }
        if (this.num == target) {
            return this;
        }
        if (!(this.rightChild == null)) {
            targetNode = this.rightChild.infixOrderSearch(target);
        }
        return targetNode;
    }

    //后序遍历
    public void postOrder() {
        if (!(this.leftChild == null)) {
            this.leftChild.postOrder();
        }

        if (!(this.rightChild == null)) {
            this.rightChild.postOrder();
        }
        System.out.println(this);
    }

    public TreeNode postOrderSearch(int target) {
        if (this == null) {
            return this;
        }
        TreeNode targetNode = null;
        if (!(this.leftChild == null)) {
            targetNode = this.leftChild.postOrderSearch(target);
        }
        if (!(targetNode == null)) {
            return targetNode;
        }
        if (!(this.rightChild == null)) {
            targetNode = this.rightChild.postOrderSearch(target);
        }
        if (!(targetNode == null)) {
            return targetNode;
        }
        if (this.num == target) {
            return this;
        }
        return targetNode;
    }
}
\end{lstlisting}
\subsection{删除节点}
要求：
\begin{itemize}
  \item 如果删除的是叶子节点，则删除该节点
  \item 如果删除的是非叶子节点，则删除该子树
\end{itemize}

思路：
\begin{itemize}
  \item 对于单向的二叉树，应当判断当前节点的的子节点是否为待删除节点
  \item 如果树是空树，不用删除，如果只有一个root节点，且是目标元素，不用删除，是目标元素，等价于将树置空。
  \item 当前节点左子节点不为空，判断该左子节点是否为要删除的节点如果是，将当前节点的左孩子引用置为null,并且返回。
  \item 否则，如果当前节点的右子节点不为空，判断该右子节点是否为要删除的节点，如果是，将当前节点的右孩子引用置为空，并且返回。
  \item 如果上边两步没有删除节点，则需要向左子树进行递归删除。
  \item 否则就向右子树递归删除。
\end{itemize}
\subsubsection{代码实现}
\begin{lstlisting}
public class BinaryTreeDemo {
    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();
        TreeNode treeNodeRoot = new TreeNode(1, "宋江");
        TreeNode treeNode1 = new TreeNode(2, "吴用");
        TreeNode treeNode2 = new TreeNode(3, "卢俊义");
        TreeNode treeNode3 = new TreeNode(4, "林冲");
        TreeNode treeNode4 = new TreeNode(5, "关胜");
        binaryTree.setRoot(treeNodeRoot);
        addLeft(treeNodeRoot, treeNode1);
        addRight(treeNodeRoot, treeNode2);
        addRight(treeNode2, treeNode3);
        addLeft(treeNode2, treeNode4);

        System.out.println("-------------------");
        System.out.println("删除前：前序遍历");
        binaryTree.preOrder();
        //删除
        int del = 5;
        binaryTree.delNode2(del);
        System.out.println("-------------------");
        System.out.println("删除后：前序遍历");
        binaryTree.preOrder();
    }

    //插入左孩子

    //插入右孩子

}

class BinaryTree {
    private TreeNode root;

    //删除1
    public void delNode1(int del){
        if (root == null){
            System.out.println("系统提示：空树，无法删除！");
            System.out.println("删除失败！");
            return;
        }
        if (root.getNum() == del){
            System.out.println("删除成功！");
            root = null;
            return;
        }
        root.delTreeNode(del);

    }
    //删除2
    public void delNode2(int del){
        TreeNode tmpNode = new TreeNode();
        tmpNode.leftChild = root;
        tmpNode.delTreeNode(del);
        root = tmpNode.leftChild;

    }
    //前序遍历


    //中序遍历

    //后序遍历

}

class TreeNode {
    private int num;
    private String name;
    public TreeNode leftChild;
    public TreeNode rightChild;
    public TreeNode parent;



    //删除节点
    //假设不是空树
    public void delTreeNode(int del){
        if (this.leftChild != null){
            if (this.leftChild.num == del){
                this.leftChild = null;
                return;
            }
        }
        if (this.rightChild != null){
            if (this.rightChild.num == del){
                this.rightChild = null;
                return;
            }
        }
        if (this.leftChild != null) {
            this.leftChild.delTreeNode(del);
        }
        if (this.rightChild != null) {
            this.rightChild.delTreeNode(del);
        }
    }


    //前序遍历的方法,迭代法

    //前序遍历查找指定节点

    //中序遍历：递归法

    //中序遍历查找

    //后序遍历

}
\end{lstlisting}
\section{顺序存储二叉树}
从数据存储来看，数组的存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组。

要求：

\begin{itemize}
\item 以数组的方式来存放数据。
\item 要求遍历数组时，仍然可以以前序、中序、后序遍历的方式完成节点的遍历。
\end{itemize}
\subsection{顺序存储二叉树的特点}
1.该二叉树是完全二叉树。

2.第n个元素的左子节点为$2n+1$，右子节点为$2n + 2$

3.第n个元素的父节点为$\frac{n - 1}{2}$

4.n表示二叉树中的第几个元素（从0开始）
\subsection{代码实现}
\begin{lstlisting}
public class ArrBinaryTreeDemo {
    public static void main(String[] args) {
int[] arr = {1,2,3,4,5,6,7,8};
        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
        int index = 0;
        System.out.println("先序");
        arrBinaryTree.preOrder();
        System.out.println("中序");
        arrBinaryTree.infixOrder();
        System.out.println("后序");
        arrBinaryTree.postOrder();
    }
}
class ArrBinaryTree{
    private int[] arr;

    public ArrBinaryTree(int[] arr){
        this.arr = arr;
    }

    //编写一个方法，完成顺序存储二叉树的遍历
    //先序
    public void preOrder(){
        preOrder(0);
    }
    public void preOrder(int index){
        if (arr == null || arr.length == 0){
            System.out.println("[]");
            return;
        }
        System.out.println(arr[index]);
        int l = 2*index + 1;
        if(l < arr.length){
            preOrder(l);
        }
        int r = 2*index+2;
        if (r < arr.length){
            preOrder(r);
        }
    }
    //中序
    public void infixOrder(){
        infixOrder(0);
    }
    public void infixOrder(int index){
        if (arr == null || arr.length == 0){
            return;
        }
        if (2*index + 1<arr.length){
            infixOrder(2*index+1);
        }
        System.out.println(arr[index]);
        if (2*index + 2<arr.length){
            infixOrder(2*index+2);
        }
    }

    //后序
    public void postOrder(){
        postOrder(0);
    }
    public void postOrder(int index){
        if (arr == null || arr.length == 0){
            return;
        }
        if (2*index + 1<arr.length){
            postOrder(2*index+1);
        }
        if (2*index + 2<arr.length){
            postOrder(2*index+2);
        }
        System.out.println(arr[index]);
    }
}
\end{lstlisting}
\section{线索化二叉树}
\subsection{基本介绍}
1.n个节点的二叉链表（完全二叉树）中含有n+1个空指针域，利用二叉链表的空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针，这种附加的指针称为线索。

2.根据线索性质得不同，线索二叉树可以分为前序线索二叉树、中序线索二叉树、后序线索二叉树。
\subsection{中序线索二叉树}
线索化二叉树后，节点的left和right，有如下两种情况：
\begin{itemize}
  \item left指向的是左子树，也可能指向前驱结点。
  \item right指向的是右子树，也可能指向后继节点。
  \item left为空，则该节点一定是遍历结果的第一个节点。
  \item  right为空，则该节点一定是遍历结果的最后一个节点。
\end{itemize}
\subsection{代码实现}
\begin{lstlisting}
package com.atWSN.tree;

public class ThreadedBinaryTreeDemo {
    public static void main(String[] args) {
        TreeNode1 root = new TreeNode1(1, "tom");
        TreeNode1 node1 = new TreeNode1(3, "jack");
        TreeNode1 node2 = new TreeNode1(6, "smith");
        TreeNode1 node3 = new TreeNode1(8, "marry");
        TreeNode1 node4 = new TreeNode1(10, "king");
        TreeNode1 node5 = new TreeNode1(14, "dim");
        root.leftChild = node1;
        node1.leftChild = node3;
        node1.rightChild = node4;
        root.rightChild = node2;
        node2.leftChild = node5;
        ThreadedBinaryTree treeNode1 = new ThreadedBinaryTree();
        treeNode1.setRoot(root);
        treeNode1.threadedNodes();
        System.out.println(node4.leftChild);
        System.out.println(node4.rightChild);
    }
}

class ThreadedBinaryTree{
    private TreeNode1 root;
    //为了实现线索化，需要一个指向当前节点前驱结点的引用
    //在递归过程中，preNode始终指向该节点的前驱结点
    private TreeNode1 preNode = null;
    //删除1
    public void delNode1(int del){
        if (root == null){
            System.out.println("系统提示：空树，无法删除！");
            System.out.println("删除失败！");
            return;
        }
        if (root.getNum() == del){
            System.out.println("删除成功！");
            root = null;
            return;
        }
        root.delTreeNode(del);

    }
    //删除2
    public void delNode2(int del){
        TreeNode1 tmpNode = new TreeNode1();
        tmpNode.leftChild = root;
        tmpNode.delTreeNode(del);
        root = tmpNode.leftChild;

    }
    //前序遍历
    public void preOrder() {
        System.out.println("前序遍历的结果为：");
        if (this.root == null) {
            System.out.println("{}");
            return;
        }
        this.root.preOrder();
    }

    public TreeNode1 preOrderSearch(int target) {
        return root.preOrderSearch(target);
    }

    //中序遍历
    public void infixOrder() {
        System.out.println("中序遍历的结果为：");
        if (this.root == null) {
            System.out.println("{}");
            return;
        }
        this.root.infixOrder();
    }

    public TreeNode1 infixOrderSearch(int target) {
        return root.infixOrderSearch(target);
    }

    //后序遍历
    public void postOrder() {
        System.out.println("后序遍历的结果为：");
        if (this.root == null) {
            System.out.println("{}");
            return;
        }
        this.root.postOrder();
    }

    public TreeNode1 postOrderSearch(int target) {
        return root.postOrderSearch(target);
    }

    public TreeNode1 getRoot() {
        return root;
    }

    public void setRoot(TreeNode1 root) {
        this.root = root;
    }

    public void threadedNodes(){
        threadedNodes(root);
    }

    //对二叉树进行中序线索化的方法
    public void threadedNodes(TreeNode1 node) {
        //如果当前节点为空，不能进行线索化
        if (node == null) {
            return;
        }
        //先线索化左子树
        threadedNodes(node.leftChild);
        //再线索化当前节点
        //先处理当前节点的前驱节点
        if (node.leftChild == null) {
            //如果当前节点的左孩子为空，就让其左孩子的引用指向其前驱节点
            //将当前节点的leftType改为1
            node.leftChild = preNode;
            node.leftType = 1;
        }
        //处理后继节点，下次处理的
        if (preNode != null && preNode.rightChild == null) {
            preNode.rightChild = node;
            preNode.rightType = 1;
        }
        //每处理一个节点后，让当前节点的前驱节点是下一个节点的前驱结点
        preNode = node;
        //再线索化右子树
        threadedNodes(node.rightChild);
    }
}

//创建节点
class TreeNode1 {

    //leftType == 0 ，表示指向左子树
    //leftType == 1，表示指向前驱结点
    //rightType == 0 ，表示指向右子树
    //rightType == 1，表示指向后继结点
    public int leftType;
    public int rightType;
    private int num;
    private String name;
    public TreeNode1 leftChild;
    public TreeNode1 rightChild;
    public TreeNode1 parent;


    public TreeNode1() {

    }

    public TreeNode1(int num, String name) {
        this.num = num;
        this.name = name;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    @Override
    public String toString() {
        return "TreeNode{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }

    //删除节点
    //假设不是空树
    public void delTreeNode(int del) {
        if (this.leftChild != null) {
            if (this.leftChild.num == del) {
                this.leftChild = null;
                return;
            }
        }
        if (this.rightChild != null) {
            if (this.rightChild.num == del) {
                this.rightChild = null;
                return;
            }
        }
        if (this.leftChild != null) {
            this.leftChild.delTreeNode(del);
        }
        if (this.rightChild != null) {
            this.rightChild.delTreeNode(del);
        }
    }


    //前序遍历的方法,迭代法
    public void preOrder() {
        System.out.println(this);
        if (!(this.leftChild == null)) {
            this.leftChild.preOrder();
        }
        if (!(this.rightChild == null)) {
            this.rightChild.preOrder();
        }
    }

    //前序遍历查找指定节点

    /**
     * @param target 目标编号
     * @return 返回对应节点
     */
    public TreeNode1 preOrderSearch(int target) {
        if (this == null || this.num == target) {
            return this;
        }
        TreeNode1 targetNode = null;
        if (!(this.leftChild == null)) {
            targetNode = this.leftChild.preOrderSearch(target);
        }
        if (targetNode != null) {
            return targetNode;
        }
        if (!(this.rightChild == null)) {
            targetNode = this.rightChild.preOrderSearch(target);
        }
        return targetNode;
    }

    //中序遍历：递归法
    public void infixOrder() {
        if (!(this.leftChild == null)) {
            this.leftChild.infixOrder();
        }
        System.out.println(this);
        if (!(this.rightChild == null)) {
            this.rightChild.infixOrder();
        }
    }

    //中序遍历查找
    public TreeNode1 infixOrderSearch(int target) {
        if (this == null) {
            return this;
        }
        TreeNode1 targetNode = null;
        if (!(this.leftChild == null)) {
            targetNode = this.leftChild.infixOrderSearch(target);
        }
        if (targetNode != null) {
            return targetNode;
        }
        if (this.num == target) {
            return this;
        }
        if (!(this.rightChild == null)) {
            targetNode = this.rightChild.infixOrderSearch(target);
        }
        return targetNode;
    }

    //后序遍历
    public void postOrder() {
        if (!(this.leftChild == null)) {
            this.leftChild.postOrder();
        }

        if (!(this.rightChild == null)) {
            this.rightChild.postOrder();
        }
        System.out.println(this);
    }

    public TreeNode1 postOrderSearch(int target) {
        if (this == null) {
            return this;
        }
        TreeNode1 targetNode = null;
        if (!(this.leftChild == null)) {
            targetNode = this.leftChild.postOrderSearch(target);
        }
        if (!(targetNode == null)) {
            return targetNode;
        }
        if (!(this.rightChild == null)) {
            targetNode = this.rightChild.postOrderSearch(target);
        }
        if (!(targetNode == null)) {
            return targetNode;
        }
        if (this.num == target) {
            return this;
        }
        return targetNode;
    }


}
\end{lstlisting}
\subsection{线索化二叉树的遍历}
线索化二叉树后，二叉树的引用有所改变，不能使用原来的遍历方式来进行遍历。
\subsubsection{代码实现}
\begin{lstlisting}
//线索化二叉树后的遍历
public void threadedList(){
    //定义一个临时变量来存储当前访问的节点
    //遍历是从root开始的
    TreeNode1 tmpNode =root;
    while(tmpNode != null){
        //循环遍历找到第一个leftType为1的节点
        //node随着遍历会变化
        //当leftType为1的时候，该节点是按照线索化处理后的有效节点
        while(tmpNode.leftType == 0){
            tmpNode = tmpNode.leftChild;
        }
        //打印当前节点
        System.out.println(tmpNode);
        //如果当前节点的右指针指向后继节点
        while (tmpNode.rightType == 1){
            tmpNode = tmpNode.rightChild;
            System.out.println(tmpNode);
        }
        //如果当前节点的右指针指向的是树
        //把当前节点替换为它的右孩子
        tmpNode = tmpNode.rightChild;
    }
}
\end{lstlisting}
\chapter{赫夫曼树}
给定n个权值作为n个叶子结点，构造一棵二叉树。若该树的带权路径长度达到最小，称这样的树为最优二叉树，也称赫夫曼树。
\section{赫夫曼树实例}
给定一个数列，要求转成一棵赫夫曼树。

思路分析：

1.从小到大进行排序，将每个数据看成一个节点，每个节点都可以看做是一棵最简单的二叉树。

2.取出根节点权值最小的两颗二叉树。

3.将2中的的两颗二叉树组成一棵新的二叉树，该新的二叉树的根节点的权值是前面两棵二叉树根节点权值的和

4.将新的二叉树，以根节点的权值大小再次排序，不断重复步骤1-4,直到数列中所有的数据都被处理。就得到一棵赫夫曼树。
\section{代码实现}
\begin{lstlisting}
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class HuffmanTreeDemo {
    public static void main(String[] args) {
        int arr[] = {13, 7, 8, 3, 29, 6, 1};
        creatHuffmanTree(arr);
    }

    //创建赫夫曼树的方法
    public static Node creatHuffmanTree(int[] arr) {
        //第一步，为了操作方便，遍历arr
        //将arr的每一个元素构成一个node
        //将Node放入到Arraylist中
        List<Node> arrayList = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
            arrayList.add(new Node(arr[i]));
        }
        while (arrayList.size() > 1) {
            //排序:权值从小到大
            Collections.sort(arrayList);
            //System.out.println(arrayList);
            //取出根节点权值最小的两颗二叉树

            Node left = arrayList.get(0);
            Node right = arrayList.get(1);
            //构建出一棵新的二叉树
            Node root = new Node(left.value + right.value);
            root.left = left;
            root.right = right;
            //从链表移除已构建的两个节点
            arrayList.remove(left);
            arrayList.remove(right);
            //把root添加到链表中
            arrayList.add(root);
        }
        return arrayList.get(0);
    }
}

class Node implements Comparable<Node> {
    int value;//节点的权值
    Node left;
    Node right;

    public Node() {

    }

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        //表示从小到大进行排序
        return this.value - o.value;
    }
}
\end{lstlisting}
\section{赫夫曼编码}
字符编码都不能是其他字符编码的前缀，符合此要求的编码焦作前缀编码，即不能匹配到重复的编码。

思路：
\begin{itemize}
  \item 给定字符串，统计各个字符对应的个数
  \item 按照字符出现的次数构建一棵赫夫曼树，次数作为权值。
  \item 根据赫夫曼树，给各个字符规定编码，向左的路径为0，向右的路径为1.该编码为前缀编码。
  \item 按照赫夫曼编码，把字符串翻译为赫夫曼编码（这里使用的是无损压缩）
  \item 赫夫曼树不唯一，所以编码也不唯一，但最终压缩的长度是唯一的
\end{itemize}
\subsection{数据压缩}
功能：把字符串对应的赫夫曼树创建起来。

思路：

1.构建新的节点：数据（指文本的字符/该字符对应的ASCII码）+权重（该字符总共出现的次数）+left+right。

2.得到字符串对应的\dm{byte[]}数组

3.编写方法：将准备构建赫夫曼树的节点放入\dm{List}中

4.通过3中的\dm{List}创建对应的赫夫曼树。
\begin{lstlisting}
package com.atWSN.huffmantree.huffmancode;

import java.util.*;

public class HuffmanCode {
    public static void main(String[] args) {
        String content = "i like like like java do you like a java";
//        //得到字节数组
//        byte[] contentBytes = content.getBytes();
//
//        System.out.println(Arrays.toString(contentBytes));
//        List<Node> list = getNodes(contentBytes);
//        Collections.sort(list);
//        System.out.println(list);
//        System.out.println("--------------------------------------------------");
//        Node root = huffmanTreeNode(list);
//        root.preOrder();
//
//        Map<Byte, String> huffmanCode = getCodes(root);
//        System.out.println(huffmanCode);
//
//        byte[] zip = zip(contentBytes,huffmanCode);
//        System.out.println(Arrays.toString(zip));
//        System.out.println((float)(contentBytes.length - zip.length)/contentBytes.length * 100);
        byte[] zip = huffmanZip(content);
        System.out.println(Arrays.toString(zip));
    }


    //使用一个方法，将前面的方法封装到一起，便于调用
    //直接处理字符串
    //返回经赫夫曼编码处理后的字节数组
    public static byte[] huffmanZip(String content){
//        //生成字节数组
//        byte[] contentBytes = content.getBytes();
//        //统计各字符的权值并创建字符对应的叶子节点
//        //将叶子节点放入到ArrayList中
//        List<Node > list =getNodes(contentBytes);
//        //生成哈夫曼树
//        Node root = huffmanTreeNode(list);
//        //通过哈夫曼树生成哈夫曼编码表
//        Map<Byte, String> huffmanCode = getCodes(root);
//        //返回经哈夫曼编码处理后的字节数组
//        return zip(contentBytes,huffmanCode);
        //上边全部的代码可以写成下边这个
        return zip(content.getBytes(),getCodes(huffmanTreeNode(getNodes(content.getBytes()))));
    }
    //处理字符串对应的字节数组
    public static byte[] huffmanZip(byte[] bytes){
        List<Node > list =getNodes(bytes);
        Node root = huffmanTreeNode(list);
        Map<Byte, String> huffmanCode = getCodes(root);
        return zip(bytes,huffmanCode);
    }


    /**
     * @param bytes 接收字节数组
     * @return
     */
    public static List<Node> getNodes(byte[] bytes) {
        List<Node> list = new ArrayList<>();
        //遍历bytes，统计每一个byte出现的次数，使用map[key,value]
        HashMap<Byte, Integer> counts = new HashMap<>();
        for (byte b : bytes) {
            Integer count = counts.get(b);
            if (count == null) {//map中没有该数据
                counts.put(b, 1);
            } else {
                counts.put(b, count + 1);
            }
        }
        //构建Node
        //把每一个键值对转成Node对象
        for (Map.Entry<Byte, Integer> entry : counts.entrySet()) {
            list.add(new Node(entry.getKey(), entry.getValue()));
        }
        return list;
    }

    //通过List生成赫夫曼树
    public static Node huffmanTreeNode(List<Node> list) {
        while (list.size() > 1) {
            Collections.sort(list);
            Node leftNode = list.get(0);
            Node rightNode = list.get(1);
            Node root = new Node(leftNode.weight + rightNode.weight);
            root.right = rightNode;
            root.left = leftNode;
            list.add(root);
            list.remove(leftNode);
            list.remove(rightNode);
        }
        return list.get(0);
    }

    //通过赫夫曼树生成赫夫曼编码
    //将赫夫曼编码表放入到map中去Map<Byte,String>形式
    //32->01 97->100
    static Map<Byte, String> huffmanCodes = new HashMap<>();

    /**
     * 功能：将所有传入的node节点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes中
     *
     * @param node          传入的赫夫曼树节点
     * @param code          路径：左子节点是0，右子节点是1
     * @param stringBuilder 用于拼接路径的
     */
    private static void getCodes(Node node, String code, StringBuilder stringBuilder) {
        //
        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
        //将传入的code加入到stringBuilder2中
        stringBuilder2.append(code);
        if (node != null) {//node为空不处理
            //判断当前节点是叶子还是非叶子
            if (node.data == null) {//非叶子节点
                //递归处理

                //向左
                getCodes(node.left, "0", stringBuilder2);
                //向右递归
                getCodes(node.right, "1", stringBuilder2);
            } else {//叶子节点
                //表示找到了某个叶子结点的最后
                huffmanCodes.put(node.data, stringBuilder2.toString());
            }
        }

    }

    //为了调用方便，重载该方法
    private static Map<Byte, String> getCodes(Node root) {
        if (root == null) {
            System.out.println("哈夫曼数为空，无法构建哈夫曼码");
            return null;
        }
        //生成赫夫曼编码表时，需要拼接路径，使用StringBuilder
        StringBuilder stringBuilder = new StringBuilder();
        getCodes(root, "", stringBuilder);
        return huffmanCodes;
    }

    //编写一个方法，将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]

    /**
     * @param bytes        原始字符串对应的byte[]数组
     * @param huffmanCodes 由原始字符串生成的哈夫曼编码表
     * @return 返回的是哈夫曼编码后转成的对应的byte数组
     */
    public static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes) {
        //先利用赫夫曼编码表将原始的byte[]数组转换为赫夫曼编码字符串
        StringBuilder stringBuilder = new StringBuilder();
        for (byte elem : bytes) {
            stringBuilder.append(huffmanCodes.get(elem));
        }
        //这句是调试代码查看二进制码的，实际功能中不要
        //System.out.println(stringBuilder.toString());

        //将字符串转为byte数组
        //首先计算字节数组的长度，即stringBuilder的长度/8
        int len = 0;
        //为了便于统一，字节数组的最后一个用于存放赫夫曼编码后的最后那个字节的位长度
        if (stringBuilder.length() % 8 == 0) {
            len = stringBuilder.length() / 8 + 1;
        } else {
            len = stringBuilder.length() / 8 + 1 + 1;
        }
        int index = 0;//记录放入byte数组的位置
        //创建存储压缩后的byte数组
        byte[] tmp = new byte[len];
        for (int i = 0; i < stringBuilder.length(); i += 8) {
            String strByte;
            if (i + 8 <= stringBuilder.length()) {
                strByte = stringBuilder.substring(i, i + 8);
                if (i + 8 == stringBuilder.length()) {
                    tmp[len - 1] = 8;
                }
            } else {
                strByte = stringBuilder.substring(i);
                tmp[len - 1] =  (byte) (stringBuilder.length() - i);
            }
            //将strByte转为byte数组
            tmp[index++] = (byte) Integer.parseInt(strByte, 2);
        }
        return tmp;
    }
}

class Node implements Comparable<Node> {
    Byte data;//用于存放字符
    int weight;//权值，表示data出现的次数
    Node left;
    Node right;

    public Node() {

    }

    public Node(int weight) {
        this.weight = weight;
    }

    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override
    public int compareTo(Node o) {
        return this.weight - o.weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }

    //前序遍历
    public void preOrder() {
        System.out.println(this);
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }
}
\end{lstlisting}
\subsection{解压缩}
将数据通过赫夫曼编码压缩后，使用赫夫曼编码将压缩后的数据进行解码，重新得到原来的数据。

解码的过程实际就是编码的逆向过程。

\subsubsection{思路}
1.将压缩后的字节数组重新转为二进制码字符串；

2.将该字符串对照赫夫曼编码重新转为字符串
\subsubsection{代码实现}
\begin{lstlisting}
 //解码

    //编写一个方法，完成对压缩数据的解码

    /**
     * @param huffmanCodes 哈夫曼编码表
     * @param huffmanBytes 压缩后得到的数组
     * @return 原字符串对应的字节数组
     */
    public static byte[] decode(Map<Byte, String> huffmanCodes, byte[] huffmanBytes) {
        //1.先得到huffmanBytes对应的二进制字符串
        StringBuilder stringBuilder = new StringBuilder();
        //处理huffmanBytes的前边字节，后两个单独处理
        for (int i = 0; i < huffmanBytes.length - 2; i++) {
            stringBuilder.append(byteToBitString(huffmanBytes[i]));
        }
        //后两个单独处理：哈夫曼编码处理的最后一个字节记录的是最后一个字节的长度
        int l = huffmanBytes[huffmanBytes.length - 1];
        String str  = Integer.toBinaryString((huffmanBytes[huffmanBytes.length - 2]|256));//要和1 0000 0000(十进制为256)的或一下，正数补高位
        stringBuilder.append(str.substring(str.length() - l));
        //把字符串按照指定的赫夫曼编码进行解码
        //把赫夫曼编码表进行调换
        // 例如之前是97->100，即把97对应的字符转为赫夫曼编码100
        //现在要把100转为对应的字符
        //相当于是反向查询
        Map<String, Byte> map = new HashMap<>();
        for (Map.Entry<Byte, String> entry : huffmanCodes.entrySet()) {
            map.put(entry.getValue(), entry.getKey());
        }

        //创建一个集合存放byte
        List<Byte> list = new ArrayList<>();
        for (int i = 0; i < stringBuilder.length(); ) {
            int count = 1;
            boolean flag = true;
            Byte b = null;
            while (flag) {
                //取出一个'0'或'1'
                String key = stringBuilder.substring(i, i + count);
                b = map.get(key);
                if (b != null) {
                    flag = false;
                } else {//b为空，说明没有匹配到
                    count++;
                }

            }
            list.add(b);
            i += count;
        }
        byte[] b = new byte[list.size()];
        int index = 0;
        for (Byte by : list) {
            b[index++] = by;
        }
        return b;
    }


    /**
     * 功能：把压缩后的字节数组中的元素转为二进制字符字符串
     *
     * @param bt   传入的byte
     * @return 是bt对应的二进制字符串，是按补码返回的。
     */
    private static String byteToBitString(byte bt) {
        int tmp = bt;
            //对于正数，还存在补高位
        tmp |= 256;//256的二进制码是1 0000 0000；后八位刚好是0

        String str = Integer.toBinaryString(tmp);
        //int对应的字节是32位，要截取最后八位
            return str.substring(str.length() - 8);
    }
\end{lstlisting}
\subsection{文件的压缩与解压缩}
\begin{lstlisting}
public static void main(String[] args) throws IOException {
//        String srcFile = "E://Desktop//数据结构.pdf";
//        String dstFile = "E://Desktop//KMP算法图压缩后.zip";
//        zipFile(srcFile, dstFile);
//        System.out.println("压缩文件成功");

        String zipFile = "E://Desktop//KMP算法图压缩后.zip";
        String dstFile = "E://Desktop//KMP算法图解压后.png";
unZipFile(zipFile,dstFile);
        System.out.println("解压缩文件成功");
    }

    //编写一个方法，将文件解压缩

    /**
     * @param zipFile 待解压文件
     * @param dstFile 文件解压到的路径
     */
    public static void unZipFile(String zipFile, String dstFile) throws IOException {
        //定义文件输入流
        InputStream is = null;
        //定义一个与文件输入关联的对象输入流
        ObjectInputStream ois = null;
        //定义文件的输出流
        OutputStream os = null;
        try {
            //创建文件输入流
            is = new FileInputStream(zipFile);
            //创建一个和is关联的对象输入流
            ois = new ObjectInputStream(is);
            //读取byte数组（哈夫曼编码处理后的那个数组）
            byte[] huffmanBytes = (byte[]) ois.readObject();
            Map<Byte, String> map = (Map<Byte, String>) ois.readObject();
            //解码
            byte[] bytes = decode(map, huffmanBytes);
            //将bytes写入到目标文件
            os = new FileOutputStream(dstFile);
            os.write(bytes);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        } finally {
            try {
                os.close();
                ois.close();
                is.close();
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }
        }
    }

    //编写方法，将一个文件进行压缩

    /**
     * @param srcFile 被压缩文件的全路径
     * @param dstFile 压缩后的文件存放的目录
     */
    public static void zipFile(String srcFile, String dstFile) {
        //创建输出流
        OutputStream os = null;
        ObjectOutputStream oos = null;
        //创建文件的输入流
        FileInputStream fileInputStream = null;
        try {
            fileInputStream = new FileInputStream(srcFile);
            //创建一个和源文件一样的byte数组
            byte[] b = new byte[fileInputStream.available()];//available()返回源文件的大小
            //读取文件
            fileInputStream.read(b);//把文件的内容读到字节数组中
            //获取到文件对应的赫夫曼编码

            //直接对源文件进行了压缩
            byte[] huffmanZip = huffmanZip(b);
            //创建文件输出流，存放压缩文件
            os = new FileOutputStream(dstFile);
            //创建一个和文件输出流关联的ObjectOutStream
            oos = new ObjectOutputStream(os);
            //把赫夫曼编码后的字节数组写入压缩文件
            oos.writeObject(huffmanZip);
            //以对象流的方式写入赫夫曼编码，为了恢复源文件时使用
            //注意一定要把赫夫曼编码写入压缩文件，否则无法恢复
            oos.writeObject(huffmanCodes);
        } catch (Exception e) {

            System.out.println(e.getMessage());
        } finally {
            try {
                fileInputStream.close();
                oos.close();
                os.close();
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }
        }
    }
\end{lstlisting}
\chapter{二叉排序树}
二叉排序树BST(Binaray Sort Tree)：对于二叉排序树的任何一个非叶子结点，要求左子节点的值小于当前节点的值，右子节点的值大于当前节点的值。

如果有相同的值，可将该值放入左子节点或右子节点。
\section{二叉排序树的创建和遍历}
把一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树。
\section{代码实现}
\begin{lstlisting}
public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7, 3, 2,10, 1,12, 5, 1, 9};
        BinarySortTree binarySortTree = new BinarySortTree();
        for (int num :
                arr) {
            binarySortTree.add(new Node(num));
        }
        binarySortTree.infixOrder();
    }

}

//创建二叉排序树
class BinarySortTree {
    Node root;

    public void add(Node node) {
        if (root == null) {
            root = node;
            return;
        }
        root.add(node);
    }

    public void infixOrder() {
        if (root == null) {
            System.out.println("[]");
            return;
        }
        root.infixOrder();
    }

    public BinarySortTree() {

    }
}

//一个节点
class Node {
    public int num;
    public Node left;
    public Node right;

    public Node() {

    }

    public Node(int num) {
        this.num = num;
    }

    //添加节点的方法
    //递归的形式添加节点
    //必须满足二叉排序树
    public void add(Node node) {
        if (node == null) {
            System.out.println("节点指向为空，无法添加");
            return;
        }
        //传入节点的值和当前子树根节点的值的关系
        if (this.num >= node.num) {
            if (this.left == null) {
                this.left = node;
                return;
            }
            this.left.add(node);
        } else {
            if (this.right == null) {
                this.right = node;
                return;
            }
            this.right.add(node);
        }

    }

    //中序遍历
    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }

        System.out.println(this.num);

        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "num=" + num +
                '}';
    }
}
\end{lstlisting}
\section{二叉排序树节点的删除}
1.删除叶子结点

2.删除非叶子结点：该节点只有一棵子树，该节点有两棵子树。

\subsection{思路}
删除叶子结点：
\begin{itemize}
  \item 找到要删除的节点\dm{targetNode}
  \item 应当找到待删除节点的父节点\dm{parentNode}(还应考虑是否存在父节点)
  \item 确定该节点是父节点的左子节点还是右子节点。
  \item 根据前面的情况来对应删除。
\end{itemize}

删除非叶子结点：只有一颗子树
\begin{itemize}
  \item 找到要删除的节点\dm{targetNode}
  \item 应当找到待删除节点的父节点\dm{parentNode}(还应考虑是否存在父节点)
  \item 确定\dm{targetNode}的子节点是左子节点还是右子节点
  \item 判断\dm{targetNode}是\dm{parentNode}的左子节点还是右子节点
  \item 如果dm{targetNode}是\dm{parentNode}的左子节点：dm{targetNode}的子树是左子树，\dm{parentNode.left = targetNode.left}，如果dm{targetNode}的子树是右子树\dm{parentNode.left = targetNode.right}
  \item 如果dm{targetNode}是\dm{parentNode}的右子节点：dm{targetNode}的子树是左子树，\dm{parentNode.right = targetNode.left}，如果dm{targetNode}的子树是右子树\dm{parentNode.right = targetNode.right}
\end{itemize}

删除非叶子节点：有两棵子树

方式一：
\begin{itemize}
  \item 找到要删除的节点\dm{targetNode}
  \item 应当找到待删除节点的父节点\dm{parentNode}(还应考虑是否存在父节点)
 \item 从\dm{targetNode}的\textcolor[rgb]{1.00,0.00,0.00}{右子树}找到\textcolor[rgb]{1.00,0.00,0.00}{最小}的节点。
 \item 使用临时变量将该最小节点的值保存，\dm{tmp}
 \item 删除最小值
 \item \dm{targetNode = tmp}
\end{itemize}

方式二：
\begin{itemize}
  \item 找到要删除的节点\dm{targetNode}
  \item 应当找到待删除节点的父节点\dm{parentNode}(还应考虑是否存在父节点)
 \item 从\dm{targetNode}的\textcolor[rgb]{1.00,0.00,0.00}{左子树}找到\textcolor[rgb]{1.00,0.00,0.00}{最大}的节点。
 \item 使用临时变量将该最大节点的值保存，\dm{tmp}
 \item 删除最大值
 \item \dm{targetNode = tmp}
\end{itemize}

\subsection{代码实现}
\begin{lstlisting}
public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7, 3, 6, 5, 1, 2};
        BinarySortTree binarySortTree = new BinarySortTree();
        for (int num :
                arr) {
            binarySortTree.add(new Node(num));
        }
        binarySortTree.infixOrder();
        System.out.println("----------------");
        System.out.println("删除节点");
        int del = new Scanner(System.in).nextInt();
        binarySortTree.delNode(del);
        binarySortTree.infixOrder();
    }

}

//创建二叉排序树
class BinarySortTree {
    Node root;

    public void add(Node node) {
        if (root == null) {
            root = node;
            return;
        }
        root.add(node);
    }

    //查找要删除的节点
    public Node search(int target) {
        if (root == null) {
            return null;
        }
        return root.search(target);
    }

    //查找删除节点的父节点
    public Node searchParent(int target) {
        if (root == null || root.num == target) {
            return null;
        }
        return root.searchParent(target);
    }

    //删除节点
    public void delNode(int del) {
        //空树
        if (root == null) {
            System.out.println("树为空，无法删除");
            return;
        }
        Node delNode = search(del);
        Node parentNode = searchParent(del);
        //没有找到节点
        if (delNode == null) {
            System.out.println("未找到节点！");
            return;
        }

        //待删除节点为叶子结点
        if (delNode.left == null && delNode.right == null) {
            //如果该树只有一个节点，且该节点为待删除节点
            //此时该节点的父节点为null
            if (parentNode == null) {
                root = null;
                return;
            }
            if (delNode == parentNode.left) {
                parentNode.left = null;
                return;
            }
            if (delNode == parentNode.right) {
                parentNode.right = null;
                return;
            }
        }
        //待删除节点有两棵子树
        if (delNode.right != null && delNode.left != null) {
            //随机填入该节点左树的最大值或右树的最小值。
            int random = new Random().nextInt(2);
            switch (random) {
                case 0:
                    int min = delRightTreeMin(delNode);
                    delNode.num = min;
                    break;
                case 1:
                    int max = delLeftTreeMin(delNode);
                    delNode.num = max;
                    break;
            }
            return;
        }
        //删除节点只有一个子树
        if (delNode.left == null) {
            if (parentNode == null){
                root = root.right;
                return;
            }
            if (delNode == parentNode.left) {
                parentNode.left = delNode.right;
                return;
            }
            if (delNode == parentNode.right) {
                parentNode.right = delNode.right;
                return;
            }
        }
        if (delNode.right == null) {
            if (parentNode == null){
                root = root.left;
                return;
            }
            if (delNode == parentNode.left) {
                parentNode.left = delNode.left;
                return;
            }
            if (delNode == parentNode.right) {
                parentNode.right = delNode.left;
                return;
            }
        }
    }

    /**
     * 功能：
     * 1.以node为根节点的右子树的最小值
     * 2.同时删除这个最小节点
     *
     * @param node 二叉排序树的根节点
     * @return 以node为根节点的右子树的最小值
     */
    public int delRightTreeMin(Node node) {
        int tmp = 0;
        Node curNode = node;
        if (node.right != null) {
            node = node.right;
        }
        while (node.left != null) {
            node = node.left;
        }
        tmp = node.num;
        delNode(tmp);
        return tmp;
    }

    /**
     * 功能：
     * 1.以node为根节点的左子树的最大值
     * 2.同时删除这个最大节点
     *
     * @param node 二叉排序树的根节点
     * @return 以node为根节点的左子树的最大值
     */
    public int delLeftTreeMin(Node node) {
        int tmp = 0;
        Node curNode = node;
        if (node.left != null) {
            node = node.left;
        }
        while (node.right != null) {
            node = node.right;
        }
        tmp = node.num;
        delNode(tmp);
        return tmp;
    }

    public void infixOrder() {
        if (root == null) {
            System.out.println("[]");
            return;
        }
        root.infixOrder();
    }

    public BinarySortTree() {

    }
}

//一个节点
class Node {
    public int num;
    public Node left;
    public Node right;

    public Node() {

    }

    public Node(int num) {
        this.num = num;
    }

    //添加节点的方法
    //递归的形式添加节点
    //必须满足二叉排序树
    public void add(Node node) {
        if (node == null) {
            System.out.println("节点指向为空，无法添加");
            return;
        }
        //传入节点的值和当前子树根节点的值的关系
        if (this.num >= node.num) {
            if (this.left == null) {
                this.left = node;
                return;
            }
            this.left.add(node);
        } else {
            if (this.right == null) {
                this.right = node;
                return;
            }
            this.right.add(node);
        }

    }

    //传入要删除的节点

    /**
     * @param target 希望删除节点的值
     * @return 找到返回对应的节点，找不到则返回null
     */
    public Node search(int target) {
        if (target == this.num) {//找到
            return this;
        } else if (target < this.num) {
            if (this.left != null) {
                return this.left.search(target);
            }
        } else {
            if (this.right != null) {
                return this.right.search(target);
            }
        }
        return null;
    }
    //要删除节点的父节点

    /**
     * @param target 要找的节点的值
     * @return 目标节点的父节点
     */
    public Node searchParent(int target) {
        if ((this.left != null && this.left.num == target) || (this.right != null && this.right.num == target)) {
            return this;
        }
        //如果查找的值小于当前节点的值，并且当前节点的左子树存在，递归的向左查找
        if (target < this.num && this.left != null) {
            return this.left.searchParent(target);
        }
        //如果查找得值大于当前节点的值，并且当前节点的右子树存在，递归的向右查找
        if (target > this.num && this.right != null) {
            return this.right.searchParent(target);
        }
        return null;
    }

    //中序遍历
    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }

        System.out.println(this.num);

        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "num=" + num +
                '}';
    }
}
\end{lstlisting}

\chapter{平衡二叉树：AVL树}
二叉排序树存在的问题，在某些情况下，二叉排序树会退化为链表，此时的查询速度明显降低（比单链表查询速度还低，因为相比单链表，二叉排序树每次都要判断另一个方向是否为空）。

解决方案：平衡二叉树。
\section{概念}
1.平衡二叉树也叫平衡二叉搜索树，又被称为AVL树，可以保证查询效率较高。平衡二叉树必须满足二叉排序树。

2.特点
\begin{itemize}
  \item 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1.
  \item 并且左右两棵子树也都是一棵平衡二叉树。
  \item 实现方法：红黑树、AVL树、替罪羊树、Treap树、伸展树
\end{itemize}
\section{左旋-zag}
\subsection{思路}
1.创建一个新的节点，该新节点的值为根节点的值

2.新节点的左子树设为当前节点的左子树

3.新节点的右子树设为当前节点右子树的左子树

4.当前节点的值换为其右子节点的值

5.把当前节点的右子树设为右子树的右子树

6.当前节点的左子树设置为新的节点。
\subsection{代码实现}
\begin{lstlisting}
public class AVLTreeDemo {
    public static void main(String[] args) {
        int[] arr = {4, 3, 6, 5, 7, 8};
        AVLTree avlTree = new AVLTree();
        for (int a : arr
        ) {
            avlTree.add(new Node(a));
        }
        avlTree.infixOrder();
        System.out.println(avlTree.root.height());
        System.out.println("--------------------");
        System.out.println(avlTree.root.leftHeight());
        System.out.println(avlTree.root.rightHeight());
    }
}

//创建AVL树
class AVLTree {
    Node root;

    public void add(Node node) {
        if (root == null) {
            root = node;
            return;
        }
        root.add(node);
    }

    //查找要删除的节点
    public Node search(int target) {
        if (root == null) {
            return null;
        }
        return root.search(target);
    }

    //查找删除节点的父节点
    public Node searchParent(int target) {
        if (root == null || root.num == target) {
            return null;
        }
        return root.searchParent(target);
    }

    //删除节点
    public void delNode(int del) {
        //空树
        if (root == null) {
            System.out.println("树为空，无法删除");
            return;
        }
        Node delNode = search(del);
        Node parentNode = searchParent(del);
        //没有找到节点
        if (delNode == null) {
            System.out.println("未找到节点！");
            return;
        }

        //待删除节点为叶子结点
        if (delNode.left == null && delNode.right == null) {
            //如果该树只有一个节点，且该节点为待删除节点
            //此时该节点的父节点为null
            if (parentNode == null) {
                root = null;
                return;
            }
            if (delNode == parentNode.left) {
                parentNode.left = null;
                return;
            }
            if (delNode == parentNode.right) {
                parentNode.right = null;
                return;
            }
        }
        //待删除节点有两棵子树
        if (delNode.right != null && delNode.left != null) {
            //随机填入该节点左树的最大值或右树的最小值。
            int random = new Random().nextInt(2);
            switch (random) {
                case 0:
                    int min = delRightTreeMin(delNode);
                    delNode.num = min;
                    break;
                case 1:
                    int max = delLeftTreeMin(delNode);
                    delNode.num = max;
                    break;
            }
            return;
        }
        //删除节点只有一个子树
        if (delNode.left == null) {
            if (parentNode == null) {
                root = root.right;
                return;
            }
            if (delNode == parentNode.left) {
                parentNode.left = delNode.right;
                return;
            }
            if (delNode == parentNode.right) {
                parentNode.right = delNode.right;
                return;
            }
        }
        if (delNode.right == null) {
            if (parentNode == null) {
                root = root.left;
                return;
            }
            if (delNode == parentNode.left) {
                parentNode.left = delNode.left;
                return;
            }
            if (delNode == parentNode.right) {
                parentNode.right = delNode.left;
                return;
            }
        }
    }

    /**
     * 功能：
     * 1.以node为根节点的右子树的最小值
     * 2.同时删除这个最小节点
     *
     * @param node 二叉排序树的根节点
     * @return 以node为根节点的右子树的最小值
     */
    public int delRightTreeMin(Node node) {
        int tmp = 0;
        Node curNode = node;
        if (node.right != null) {
            node = node.right;
        }
        while (node.left != null) {
            node = node.left;
        }
        tmp = node.num;
        delNode(tmp);
        return tmp;
    }

    /**
     * 功能：
     * 1.以node为根节点的左子树的最大值
     * 2.同时删除这个最大节点
     *
     * @param node 二叉排序树的根节点
     * @return 以node为根节点的左子树的最大值
     */
    public int delLeftTreeMin(Node node) {
        int tmp = 0;
        Node curNode = node;
        if (node.left != null) {
            node = node.left;
        }
        while (node.right != null) {
            node = node.right;
        }
        tmp = node.num;
        delNode(tmp);
        return tmp;
    }

    public void infixOrder() {
        if (root == null) {
            System.out.println("[]");
            return;
        }
        root.infixOrder();
    }

    public AVLTree() {

    }
}

//一个节点
class Node {
    public int num;
    public Node left;
    public Node right;

    public Node() {

    }

    public Node(int num) {
        this.num = num;
    }

    //左旋-zag
    public void zag() {
        Node newNode = new Node(this.num);
        //新节点的左子树为当前节点的左子树
        newNode.left = this.left;

        if (this.right != null) {
            //新节点的右子树为当前节点右子树的左子树
            newNode.right = this.right.left;
            //当前节点的值置为右子节点的值
            this.num = this.right.num;
            //把当前节点的右子树设为当前节点右子树右子树的右子树
            this.right = this.right.right;
        }
        //当前节点的左子树设置为新的节点
        this.left = newNode;

    }

    //右旋-zig
    public void zig() {
        Node newNode = new Node(this.num);
        //新节点的右子树为当前节点的右子树
        newNode.right = this.right;

        if (this.left != null) {
            //新节点的左子树为当前节点左子树的右子树
            newNode.left = this.left.right;
            //当前节点的值置为左子节点的值
            this.num = this.left.num;
            //把当前节点的左子树设为当前节点左子树左子树的右子树
            this.left = this.left.left;
        }
        //当前节点的右子树设置为新的节点
        this.right = newNode;

    }

    public int leftHeight() {
        return left == null ? 0 : left.height();
    }

    public int rightHeight() {
        return right == null ? 0 : right.height();
    }

    /**
     * 功能： 返回以node为根节点的树的高度
     *
     * @return
     */
    public int height() {
        return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1;
    }

    //添加节点的方法
    //递归的形式添加节点
    //必须满足二叉排序树
    public void add(Node node) {
        if (node == null) {
            System.out.println("节点指向为空，无法添加");
            return;
        } else if (this.num >= node.num) {//传入节点的值和当前子树根节点的值的关系
            if (this.left == null) {
                this.left = node;
            } else {
                this.left.add(node);
            }
        } else {
            if (this.right == null) {
                this.right = node;
            } else {
                this.right.add(node);
            }
        }
//当右子树高度高于左子树时：即(rightHeight - leftHeight)>1，要左旋
        if ((this.rightHeight() - this.leftHeight()) > 1) {
            if (this.right != null && this.right.rightHeight() < this.right.leftHeight()) {
                this.right.zig();
            }
            zag();
            return;
        }
        //顺时针旋转
        if ((this.leftHeight() - this.rightHeight()) > 1) {
            if (this.left != null && this.left.right.rightHeight() > this.left.leftHeight()) {
                this.left.zag();
            }
            zig();
        }
    }

    //传入要删除的节点

    /**
     * @param target 希望删除节点的值
     * @return 找到返回对应的节点，找不到则返回null
     */
    public Node search(int target) {
        if (target == this.num) {//找到
            return this;
        } else if (target < this.num) {
            if (this.left != null) {
                return this.left.search(target);
            }
        } else {
            if (this.right != null) {
                return this.right.search(target);
            }
        }
        return null;
    }
    //要删除节点的父节点

    /**
     * @param target 要找的节点的值
     * @return 目标节点的父节点
     */
    public Node searchParent(int target) {
        if ((this.left != null && this.left.num == target) || (this.right != null && this.right.num == target)) {
            return this;
        }
        //如果查找的值小于当前节点的值，并且当前节点的左子树存在，递归的向左查找
        if (target < this.num && this.left != null) {
            return this.left.searchParent(target);
        }
        //如果查找得值大于当前节点的值，并且当前节点的右子树存在，递归的向右查找
        if (target > this.num && this.right != null) {
            return this.right.searchParent(target);
        }
        return null;
    }

    //中序遍历
    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }

        System.out.println(this.num);

        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "num=" + num +
                '}';
    }
}
\end{lstlisting}
\chapter{多路查找树-B树}
\section{B树}
B树某个节点为m，元素不超过m-1，不低于$\left\lceil\dfrac{m}{2}\right\rceil$,B树又称为$\left\lceil\dfrac{m} {2}\right\rceil,m树$。

插入元素时，如果不满足B树规定，则发生分裂：将中间的元素移至父亲，同时该节点分为2个，父亲节点如果上溢，同样操作，直到根节点处。

删除元素时：如果该节点处不满足B树规定的个数，首先从左顾右盼，如果有兄弟，且兄弟的元素个数比B树规定的最小的节点个数还多就从兄弟那里借（注意要满足中序性的要求），如果没有符合条件的兄弟就从父亲那里拿一个跟兄弟拼接。从父亲那里拿一个后如果父亲不满足条件也按上述执行，直到根节点。


B树所有的关键字存放在叶子或非叶子节点中，B+树搜索与B树基本相同，但所有的关键字都处于叶子节点的链表中。非叶子节点相当于是叶子结点的索引

B*树是B+树的变体，在B+树的非根非叶子节点再增加指向兄弟的指针。
\section{2-3树}
1.2-3树的所有叶子节点都在同一层（只要是B树都满足这个条件）

2.有两个子节点的节点叫二节点。二节点要么没有子节点，要么有两个子节点。

3.有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点。

4.2-3树是由二节点和三节点构成的树。


\chapter{图}
处理多对多的结构。
\section{常用概念}
1.顶点：vertex

2.边：edge

3.路径

4.无向图：顶点之间的连接没有方向

5.有向图

6.带权图
\section{图的表示方式}
二维数组（邻接矩阵），链表表示：邻接表。

邻接矩阵需要为每个顶点都分配n个边的空间。实际中有的边不存在，会造成一定的空间损失。

邻接表的实现只关心存在的边，不关心不存在的边，因此没有空间浪费。邻接表通常由链表+数组组成。
\section{图的代码实现}
对于邻接矩阵，1表示直连，0表示不能直接连接。

1.要存储图中各顶点的信息。使用String  ArrayList集合

2.保存矩阵，使用二维数组表示边的关系。
\begin{lstlisting}
import java.util.ArrayList;
import java.util.List;

public class GraphDemo {
    //存储顶点的信息，使用ArrayList
    public List<String> vertexList;
    private int[][] edges;//存储各条边的信息
    private int numEdges;//表示边的条数

    public static void main(String[] args) {
        int n = 5;
        String[] vertexValue = {"A", "B", "C", "D", "E"};
        GraphDemo graph = new GraphDemo(n);
        for (String vertex :
                vertexValue) {
            graph.insertVertex(vertex);
        }
        graph.showGraph();
        //添加边
        graph.insertEdge(0,1,1);
        graph.insertEdge(0,2,1);
        graph.insertEdge(2,1,1);
        graph.insertEdge(3,1,1);
        graph.insertEdge(4,1,1);
        System.out.println("-------------------------------------");
        graph.showGraph();
    }

    //构造器
    public GraphDemo(int n) {
        //初始化矩阵和ArrayList
        vertexList = new ArrayList<>();
        edges = new int[n][n];
    }

    //插入顶点
    public void insertVertex(String vertex) {
        this.vertexList.add(vertex);
    }
    //添加边

    /**
     * @param v1     点1的下标
     * @param v2     点2的下标
     * @param weight 边的权值，0或1
     */
    public void insertEdge(int v1, int v2, int weight) {
        this.edges[v1][v2] = weight;
        this.edges[v2][v1] = weight;
        this.numEdges++;
    }

    //图的常用方法
    //返回节点的个数
    public int getNumOfVertex() {
        return vertexList.size();
    }

    //返回边的数目
    public int getNumOfEdges() {
        return numEdges;
    }

    //返回节点i对应的数据,i指的是在节点顺序表中的下标
    public String getVertexByIndex(int i) {
        return vertexList.get(i);
    }

    //返回v1和v2的权值
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    public void showGraph() {
        System.out.print("   ");
        for (int i = 0; i < vertexList.size(); i++) {
            System.out.print(vertexList.get(i));
            System.out.print(" ");
        }
        System.out.println();
        for (int i = 0; i < vertexList.size(); i++) {
            System.out.print(vertexList.get(i));
            System.out.print(": ");
            for (int j = 0; j < vertexList.size(); j++) {
                System.out.print(edges[i][j]);
                System.out.print(" ");
            }
            System.out.println();
        }

    }
}
\end{lstlisting}
\section{图的遍历}
\subsection{深度优先遍历}
从初始访问节点出发，初始访问节点可能有多个邻接顶点，深度优先遍历的策略就是首先访问第一个邻接顶点，然后在以这个被访问的邻接顶点作为初始节点，访问它的第一个邻接顶点。相当于是每次都在访问完当前节点后首先访问当前节点的第一个邻接顶点。

步骤：

1.访问初始节点v，并标记节点v已访问。

2.查找节点v的第一个邻接节点w。

3.若w存在，则继续执行2，如果w不存在，则回到第一步，将从v的下一个节点继续。

4.若w未被访问，对w进行深度优先遍历递归（即把w当做新的v）。

5.查找节点v的w邻接节点的下一个邻接节点，转到步骤3.
\subsection{代码实现}
\begin{lstlisting}
//类中添加一个boolean数组来标记各节点是否被访问

//节点访问状态
    public boolean visit[];

//在构造器中对该数组进行初始化

//得到第一个邻接节点的下标
    public int getFirstNeighbor(int index) {
        for (int j = 0; j < vertexList.size(); j++) {
            if (edges[index][j] > 0) {
                return j;
            }
        }
        //没有就返回-1
        return -1;
    }
    //根据前一个邻接节点的下标来获取下一个邻接节点

    /**
     * @param v1 当前节点
     * @param v2 当前节点的邻接节点
     * @return 下一个邻接节点
     */
    public int getNextNeighbor(int v1, int v2) {
        for (int i = v2 + 1; i < vertexList.size(); i++) {
            if (edges[v1][i] > 0) {
                return i;
            }
        }
        return -1;
    }

    //深度优先遍历算法

    /**
     * @param index 从第index个节点开始访问
     * @param visit 节点的访问状态
     */
    public void dfs(int index, boolean visit[]) {
        //访问当前节点
        System.out.println(vertexList.get(index));
        //把当前节点访问状态变为已访问
        this.visit[index] = true;
        //获取当前节点的邻接节点
        int w = getFirstNeighbor(index);
        //如果该邻接节点存在
        while (w != -1) {//说明找到了邻接顶点
            //判断该邻接顶点是否被访问
            if (!this.visit[w]) {//没有被访问，就以该节点为新的节点进行搜索
                dfs(w, this.visit);
            } else {//如果w被访问过，就找index的下一个邻接节点
                w = this.getNextNeighbor(index, w);
            }
        }
        //邻接节点不存在,如何访问全部的节点
        //通过重载，对所有的节点进行dfs
        //方法如下
    }

    public void dfs() {
        //遍历所有的节点，进行dfs
        for (int i = 0; i < vertexList.size(); i++) {
            if (!visit[i]) {
                dfs(i, this.visit);
            }
        }
    }
\end{lstlisting}
\section{广度优先遍历BFS(BroadFirst Search)}
类似于分层搜索，广度优先遍历需要使用一个队列以保持访问过的节点的顺序。以便按这个顺序来访问这些节点的邻接节点。

\subsection{算法步骤}
1.访问初始节点v并标记节点已被访问。

2.节点入队列。

3.队列非空时，继续执行，否则算法结束。

4.出队列，取得队头节点u。

5.查找u的第一个邻接节点w。

6.如果节点u的邻接节点w不存在，转入步骤3，否则：
\begin{itemize}
  \item 若节点w尚未被访问，访问节点w同时，标记为已访问
  \item 节点w入队列。
  \item 查找u的继w邻接节点的下一个邻接节点w,转到步骤6。
\end{itemize}
\subsection{代码实现}
\begin{lstlisting}
//广度优先遍历
    //对一个节点进行广度优先遍历
    private void bfs(int index, boolean[] visit) {
        //取出队列的头结点
        int u;
        //u的邻接点的下标w
        int w;
        //队列，用于记录节点的访问顺序
        Queue<Integer> queue = new LinkedList<>();
        //访问当前节点
        System.out.println(vertexList.get(index));
        //更改当前节点的访问状态
        visit[index] = true;
        //当前节点入队
        queue.add(index);
        //队列不为空时，进行访问
        while (!queue.isEmpty()) {
            //取出队首元素进行bfs
            u = queue.poll();
            //得到队首的第一个邻接节点
            w = getFirstNeighbor(u);
            while(w != -1){
                if (!visit[w]) {
                    //当前邻接节点没被访问
                    //则进行访问，同时入队列
                    System.out.println(vertexList.get(w));
                    visit[w] = true;
                    queue.add(w);
                }else{
                    w = getNextNeighbor(u,w);//广度优先
                }
            }
        }
    }

    //遍历所有的节点都进行广度优先搜索
    public void bfs(){
        visit = new boolean[vertexList.size()];
        for (int i = 0; i < vertexList.size(); i++) {
            if (!this.visit[i]){
                bfs(i,this.visit);
            }
        }
    }
\end{lstlisting}
\section{图的全部代码汇总}
\begin{lstlisting}
package com.atWSN.graph;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class GraphDemo {
    //存储顶点的信息，使用ArrayList
    public List<String> vertexList;
    private int[][] edges;//存储各条边的信息
    private int numEdges;//表示边的条数

    //节点访问状态
    public boolean visit[];

    public static void main(String[] args) {
        int n = 5;
        String[] vertexValue = {"A", "B", "C", "D", "E"};
        GraphDemo graph = new GraphDemo(n);
        for (String vertex :
                vertexValue) {
            graph.insertVertex(vertex);
        }
        graph.showGraph();
        //添加边
        graph.insertEdge(0, 1, 1);
        graph.insertEdge(0, 2, 1);
        graph.insertEdge(2, 1, 1);
        graph.insertEdge(3, 1, 1);
        graph.insertEdge(4, 1, 1);
        System.out.println("-------------------------------------");
        graph.showGraph();
        graph.dfs();
        System.out.println("-------------------------------------");
        graph.bfs();
    }

    //构造器
    public GraphDemo(int n) {
        //初始化矩阵和ArrayList
        vertexList = new ArrayList<>();
        edges = new int[n][n];

    }

    //得到第一个邻接节点的下标
    public int getFirstNeighbor(int index) {
        for (int j = 0; j < vertexList.size(); j++) {
            if (edges[index][j] > 0) {
                return j;
            }
        }
        //没有就返回-1
        return -1;
    }
    //根据前一个邻接节点的下标来获取下一个邻接节点

    /**
     * @param v1 当前节点
     * @param v2 当前节点的邻接节点
     * @return 下一个邻接节点
     */
    public int getNextNeighbor(int v1, int v2) {
        for (int i = v2 + 1; i < vertexList.size(); i++) {
            if (edges[v1][i] > 0) {
                return i;
            }
        }
        return -1;
    }

    //深度优先遍历算法

    /**
     * @param index 从第index个节点开始访问
     * @param visit 节点的访问状态
     */
    public void dfs(int index, boolean visit[]) {
        //访问当前节点
        System.out.println(vertexList.get(index));
        //把当前节点访问状态变为已访问
        this.visit[index] = true;
        //获取当前节点的邻接节点
        int w = getFirstNeighbor(index);
        //如果该邻接节点存在
        while (w != -1) {//说明找到了邻接顶点
            //判断该邻接顶点是否被访问
            if (!this.visit[w]) {//没有被访问，就以该节点为新的节点进行搜索
                dfs(w, this.visit);
            } else {//如果w被访问过，就找index的下一个邻接节点
                w = this.getNextNeighbor(index, w);
            }
        }
        //邻接节点不存在,如何访问全部的节点
        //通过重载，对所有的节点进行dfs
        //方法如下
    }

    public void dfs() {
        visit = new boolean[vertexList.size()];
        //遍历所有的节点，进行dfs
        for (int i = 0; i < vertexList.size(); i++) {
            if (!visit[i]) {
                dfs(i, this.visit);
            }
        }
    }

    //广度优先遍历
    //对一个节点进行广度优先遍历
    private void bfs(int index, boolean[] visit) {
        //取出队列的头结点
        int u;
        //u的邻接点的下标w
        int w;
        //队列，用于记录节点的访问顺序
        Queue<Integer> queue = new LinkedList<>();
        //访问当前节点
        System.out.println(vertexList.get(index));
        //更改当前节点的访问状态
        visit[index] = true;
        //当前节点入队
        queue.add(index);
        //队列不为空时，进行访问
        while (!queue.isEmpty()) {
            //取出队首元素进行bfs
            u = queue.poll();
            //得到队首的第一个邻接节点
            w = getFirstNeighbor(u);
            while(w != -1){
                if (!visit[w]) {
                    //当前邻接节点没被访问
                    //则进行访问，同时入队列
                    System.out.println(vertexList.get(w));
                    visit[w] = true;
                    queue.add(w);
                }else{
                    w = getNextNeighbor(u,w);//广度优先
                }
            }
        }
    }

    //遍历所有的节点都进行广度优先搜索
    public void bfs(){
        visit = new boolean[vertexList.size()];
        for (int i = 0; i < vertexList.size(); i++) {
            if (!this.visit[i]){
                bfs(i,this.visit);
            }
        }
    }

    //插入顶点
    public void insertVertex(String vertex) {
        this.vertexList.add(vertex);
    }
    //添加边

    /**
     * @param v1     点1的下标
     * @param v2     点2的下标
     * @param weight 边的权值，0或1
     */
    public void insertEdge(int v1, int v2, int weight) {
        this.edges[v1][v2] = weight;
        this.edges[v2][v1] = weight;
        this.numEdges++;
    }

    //图的常用方法
    //返回节点的个数
    public int getNumOfVertex() {
        return vertexList.size();
    }

    //返回边的数目
    public int getNumOfEdges() {
        return numEdges;
    }

    //返回节点i对应的数据,i指的是在节点顺序表中的下标
    public String getVertexByIndex(int i) {
        return vertexList.get(i);
    }

    //返回v1和v2的权值
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    public void showGraph() {
        System.out.print("   ");
        for (int i = 0; i < vertexList.size(); i++) {
            System.out.print(vertexList.get(i));
            System.out.print(" ");
        }
        System.out.println();
        for (int i = 0; i < vertexList.size(); i++) {
            System.out.print(vertexList.get(i));
            System.out.print(": ");
            for (int j = 0; j < vertexList.size(); j++) {
                System.out.print(edges[i][j]);
                System.out.print(" ");
            }
            System.out.println();
        }

    }
}
\end{lstlisting}

\chapter{常用的算法}
\section{二分查找算法--非递归实现}
只适用于有序数列查找，时间复杂度：O(log n)。

前边学过递归的方式，这里要求非递归的方式完成。
\subsection{代码实现}
\begin{lstlisting}
package com.atWSN.Algorithm;

/**
 * 二分查找的算法
 * <p>
 * 要求：使用迭代的方式来完成
 */
public class BinarySearch {
    public static void main(String[] args) {

    }
    //二分查找的非递归实现

    /**
     * 功能：二分查找
     * 要求：迭代完成
     *
     * @param arr    从arr中查找,有序数组
     * @param target 查找元素target
     * @return 找到返回下标，没找到返回-1
     * @author 王松年
     */
    public static int binarySearch(int[] arr, int target) {
        int lo = 0;
        int hi = arr.length - 1;
        while (lo <= hi){
            int mid = lo + ((hi - lo) >> 1);
            if (arr[mid] == target){
                return mid;
            }else if(target < arr[mid]){
                hi = mid - 1;
            }else{
                lo = mid + 1;
            }
        }
        return -1;
    }

    //二分查找递归版
    public static int binarySearch(int arr[],int target,int lo,int hi){
        if (lo > hi){
            return -1;
        }
        int mid = lo + ((hi - lo)>>1);
        if (arr[mid] == target){
            return mid;
        }else if(target < arr[mid]){
            return binarySearch(arr,target,lo,mid -1);
        }else{
            return binarySearch(arr,target,mid + 1,hi);
        }

    }
}
\end{lstlisting}
\section{分治算法}
分治算法可以求解的经典问题：二分搜索、大整数乘法、棋盘覆盖、归并排序、快速排序、线性时间选择、最接近点对问题、循环赛日程表、汉诺塔。
\subsection{分治算法的步骤}
1.分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。

2.解决：若子问题的规模较小而容易被解决则直接解决，否则递归放入解各个子问题。

3.合并：将各个子问题的解合并得到原问题的解。
\subsection{设计模式}
当问题的规模不超过某一阈值时，问题已容易解出，不必继续分解。（递归基）

\begin{lstlisting}
if p < n0
    then return (ADHOC(P))
//将P分解为较小的子问题P1、P2……
for i = 1 to k
    do yi Divide and Conquer //递归的解决Pi
//合并子问题
MERGE（y1,y2,...）
return T
\end{lstlisting}

\subsection{分治算法案例--汉诺塔}
(应该是减治)

思路分析：

1.只有一个盘：A->C

2.盘数超过一个：\\
可以总是把盘分成两部分:最下面一个盘和上边的那部分盘。

三步完成：把最上面的盘从A移动到B，把最下面的盘从A移动到C，把B的盘移动到C。
\subsubsection{代码实现}
\begin{lstlisting}
/**
 * 分治算法
 * 以求解汉诺塔为例
 */
public class HanoiTower {
    public static void main(String[] args) {
        hanoiTower(10, 'A', 'B', 'C');
    }

    /**
     * 使用分治算法
     *
     * @param n 汉诺塔的盘子数
     * @param a 盘子所在的柱子
     * @param b 辅助柱子
     * @param c 盘子要移动的柱子
     */
    public static void hanoiTower(int n, char a, char b, char c) {
        if (n == 1) {
            //如果只有一个盘，就移动这一个盘
            System.out.println("第1个盘从" + a + "移动到" + c+"上");
            return;
        }
        //把上边的n-1个盘从a移动到b上（借助c盘移动）
        hanoiTower(n - 1, a, c, b);
        //把最下边那个盘从a移动到c上
        System.out.println("第"+n+"个盘从" + a + "移动到" + c + "上");
        //把b上的盘借助a移动到c上
        hanoiTower(n - 1, b, a, c);
    }
}
\end{lstlisting}
\section{动态规划算法}
\subsection{算法介绍}
1.将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法。

2.与分治算法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是相互独立的。（下一个子阶段的求解是建立在上一个子阶段求解的基础上）

3.动态规划可以用填表的方式来逐步推进，得到最优解。
\subsection{经典案例--背包问题}
有一个背包，容量为4磅，现有如下物品：吉他（G）：1磅，价值1500；音响（S）：4磅，价值3000；电脑（L）：3磅，价值2000.

\subsubsection{要求}

1.物品装入背包的总价值最大，且重量不能超过背包的总重。

2.要求装入的物品不能重复。(01背包，还有完全背包，完全背包指的是每种物品都有无限件可用)。

\subsubsection{思路}
对于给定的n个物品，设\dm{v[i] w[i]}分别为第\dm{i}个物品的价值和容量，\dm{C}为背包容量。令\dm{v[i][j]}表示前\dm{i}个物品能够装入到容量为\dm{j}的背包中的最大价值。

动态规划的思想是每次遍历到第\dm{i}个物品，根据\dm{w[i]}和\dm{v[i]}来确定是否需要将该物品放入到背包中。

公式：
\begin{lstlisting}
1.v[i][0] = v[0][i]//表示填入的那张表的第一行第一列是0

2.if w[i] > j, then v[i][j] = v[i - 1][j]//增加一个商品，容量大于当前背包的容量时，就直接使用上一行的结果

3.if w[i] <= j,then v[i][j] = max(v[i-1][j],v[i-1][j-w[j]]+v[i])//增加一个商品，容量小于等于当前背包的容量时，取最大值：v[i-1][j]表示上一行的装入策略。v[i-1][j-w[j]]+v[i]表示把当前商品放入背包的同时，上一行中放入当前背包剩余空间的物品对应的价值。
\end{lstlisting}
\subsubsection{代码实现}
\begin{lstlisting}
package com.atWSN.Dynamic;

/**
 * 使用动态规划求解背包问题
 */
public class KnapsackProblem {
    public static void main(String[] args) {
        int[] weight = {4, 4, 4, 3};//用于保存物品的重量
        int[] value = {3000, 1000, 3000, 2000};//用于保存物品的价值
        final int capacity = 7;//背包的容量
        final int numOfGoods = value.length;

        int[][] valueOfKnapsack = new int[numOfGoods + 1][capacity + 1];

        //为了记录放入商品的情况，定义一个二维数组
        int[][] path = new int[numOfGoods + 1][capacity + 1];
        //初始化第0行
        for (int i = 0; i < capacity; i++) {
            valueOfKnapsack[0][i] = 0;
        }
        //初始化第0列
        for (int i = 0; i < value.length; i++) {
            valueOfKnapsack[i][0] = 0;
        }

        for (int i = 1; i <= value.length; i++) {//表示第i个物品
            for (int j = 1; j <= capacity; j++) {//表示当前背包容量
                if (weight[i - 1] > j) {//当前物品大于背包容量
                    valueOfKnapsack[i][j] = valueOfKnapsack[i - 1][j];
                } else {
                    if (valueOfKnapsack[i - 1][j] > value[i - 1] + valueOfKnapsack[i - 1][j - weight[i - 1]]) {
                        valueOfKnapsack[i][j] =valueOfKnapsack[i - 1][j];
                    } else {
                        valueOfKnapsack[i][j] = value[i - 1] + valueOfKnapsack[i - 1][j - weight[i - 1]];
                        path[i][j] = 1;
                    }
                }
            }
        }
        for (int i = 1; i < valueOfKnapsack.length; i++) {
            for (int j = 1; j < valueOfKnapsack[0].length; j++) {
                System.out.print(valueOfKnapsack[i][j]);
                System.out.print(" ");
            }
            System.out.println();
        }
        System.out.println("背包放入的物品为：");
        int i = path.length - 1;
        int j = path[0].length - 1;
        while (i > 0 && j > 0) {
            if (path[i][j] == 1) {
                System.out.printf("第%d个物品放入背包\n", i);
                j -= weight[i - 1];
            }
            i--;
        }
    }
}
\end{lstlisting}
\section{串匹配算法}
\subsection{暴力匹配算法}
\subsection{KMP算法}
\href{https://blog.csdn.net/weixin_44981174/article/details/113414427?spm=1001.2014.3001.5501}{KMP算法}
\section{贪心算法}
\subsection{算法介绍}
1.进行问题求解时，在每一步选择中都采取最好或者最优的选择，从而希望能够导致结果最好或最优的算法。

2.贪心算法所得到的不一定是最优的结果，但是都是相对接近最优的结果
\subsection{应用场景}
\textcolor[rgb]{1.00,0.00,0.00}{集合覆盖问题}：假设存在需要付费的广播电台，以及广播台信号可以覆盖的地区，如何选择最少的广播台，让所有的地区都可以接受信号。

k1:北京，上海，天津

k2:广州，北京，深圳

k3:成都，上海，杭州

k4:上海，天津

k5:杭州，大连

%\begin{tabular}{|c|c|}
%  \hline
%  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
%  广播台 & 覆盖地区&\\
%  \hline
%\end{tabular}
\subsubsection{思路分析}
1.遍历所有的广播台，找到一个覆盖了最多未覆盖的地区

2.将这个电台加入到一个集合中，想办法把该电台覆盖的地区在下次比较时去掉

3.重复第一步直到覆盖了全部的地区。
\subsubsection{代码实现}
\begin{lstlisting}
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

/**
 * 贪心算法求解集合覆盖问题
 */
public class GreedyAlgorithm {
    public static void main(String[] args) {
        //创建广播电台，放入到map
        HashMap<String, HashSet<String>> broadCasts = new HashMap<>();
        HashSet<String> strings1 = new HashSet<>();
        strings1.add("北京");
        strings1.add("上海");
        strings1.add("天津");
        broadCasts.put("k1", strings1);
        HashSet<String> strings2 = new HashSet<>();
        strings2.add("北京");
        strings2.add("广州");
        strings2.add("深圳");
        broadCasts.put("k2", strings2);
        HashSet<String> strings3 = new HashSet<>();
        strings3.add("成都");
        strings3.add("上海");
        strings3.add("杭州");
        broadCasts.put("k3", strings3);
        HashSet<String> strings4 = new HashSet<>();
//        strings1.add("北京");
        strings4.add("上海");
        strings4.add("天津");
        broadCasts.put("k4", strings4);
        HashSet<String> strings5 = new HashSet<>();
        strings5.add("杭州");
        strings5.add("大连");
//        strings1.add("天津");
        broadCasts.put("k5", strings5);
        //存放所有的地区
        HashSet<String> allAreas = new HashSet<>();
        allAreas.add("北京");
        allAreas.add("上海");
        allAreas.add("天津");
        allAreas.add("广州");
        allAreas.add("深圳");
        allAreas.add("杭州");
        allAreas.add("成都");
        allAreas.add("大连");
        //存放所有的电台集合
        //存放的是最终的电台
        ArrayList<String> selects = new ArrayList<>();
        //定义临时的集合，保存在遍历的过程中，存放遍历过程中电台覆盖的地区与当前没有覆盖地区的交集
        HashSet<String> tmpSet = new HashSet<>();
        //定义maxKey，用于记录在一次遍历过程中，能够覆盖最大未覆盖地区的那个电台
        //如果maxKey不为空，则加入到select中
        String maxKey = null;
        while (!allAreas.isEmpty()) {//不为空，表示还没覆盖完
            maxKey = null;
            tmpSet.clear();
            //遍历broadcasts
            for (String key : broadCasts.keySet()) {
                HashSet<String> areas = broadCasts.get(key);//当前的k能够覆盖的地区
                tmpSet.addAll(areas);//还未被覆盖的地区
                //和未覆盖地区取交集
                tmpSet.retainAll(allAreas);
                if (!tmpSet.isEmpty() && (maxKey == null || tmpSet.size() > broadCasts.get(maxKey).size())) {
                    //后边的那个条件体现了贪心算法
                    //每次都选择最优的
                    maxKey = key;
                }
            }
            if (maxKey != null) {
                selects.add(maxKey);
                //将maxKey指向的那个广播电台覆盖的地区从select清空
                allAreas.removeAll(tmpSet);
            }
        }
    }
}
\end{lstlisting}
\section{最小生成树相关算法}
\subsection{最小生成树}
最小生成树(Minimum Cost Spanning Tree)，简称MST。

1.给定一个带权的无向连通图，如何选取一棵生成树，使树上所有边上权的总和为最小，这叫最小生成树。

2.N个顶点，则一定有N-1条边

3.包含全部的顶点

4.N-1条边全部都在图中。

求最小生成树的算法主要是普利姆算法和克鲁斯卡尔算法。

\subsection{应用场景}
有七个村庄A、B、C、D、E、F、G，现在需要修路把七个村庄连通。各个村庄的距离用边线表示（权）。

A-B：5公里；A-C：7公里；A-G：2公里；B-D：9公里；B-G：3公里；

C-E：8公里；D-F：4公里；E-F：5公里；E-G：4公里；F-G：6公里

问：如何修路保证各个村庄都能联通，并且总的修建公路里程最短？

\subsubsection{思路分析}
尽可能选择少的路线，并且每条路线最小。
\subsection{普利姆算法}
普里姆算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含有n个顶点的连通子图，也就是所谓的极小连通子图。

1.设G=(V,E)是联通网，T=(U,D)是最小生成树，V，U是顶点集合，E,D是边集合。

2.若从顶点u开始构造最小生成树，则从集合v中取出顶点u放入集合U中，标记顶点v的\dm{visited[u] = 1}


3.若集合U中顶点ui与集合V-E中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边(ui,vj)加入集合D中，标记\dm{visited[vi] = 1}

4.重复步骤2，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边
\subsubsection{代码实现}
\begin{lstlisting}
package com.atWSN.Algorithm.Prim;

import java.util.Arrays;

/**
 * 最小生成树问题
 */
public class Prim {
    public static void main(String[] args) {
        char[] data = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int capacity = data.length;
        //邻接矩阵
        int[][] weight =
                {
                        //用0表示不连通
                    //   A  B  C  D  E  F  G
                        {0, 5, 7, 0, 0, 0, 2},
                        {5, 0, 0, 9, 0, 0, 3},
                        {7, 0, 0, 0, 8, 0, 0},
                        {0, 9, 0, 0, 0, 4, 0},
                        {0, 0, 8, 0, 0, 5, 4},
                        {0, 0, 0, 4, 5, 0, 6},
                        {2, 3, 0, 0, 4, 6, 0}
                };
        //创建一个mGraph对象
        MGraph mGraph = new MGraph(capacity);
        MinTree minTree = new MinTree();
        minTree.creatGraph(mGraph,data,weight);
        minTree.showGraph(mGraph);
        int[][] ret =  minTree.prim(mGraph,0);
        System.out.println("最小生成树为：");
        for (int i = 0; i < ret.length; i++) {
            System.out.println(""+data[ret[i][0]] + "<-"+weight[ret[i][0]][ret[i][1]]+"->" +data[ret[i][1]]);
        }
    }
}

//创建最小生成树
class MinTree {
    //创建邻接矩阵

    /**
     * @param mGraph   图的对象
     * @param data     图中各节点的名字
     * @param weight   图中各节点之间的权值
     */
    public void creatGraph(MGraph mGraph, char[] data, int[][] weight) {
        for (int k = 0; k < mGraph.capacity; k++) {
            mGraph.data[k] = data[k];
            for (int i = 0; i < mGraph.capacity; i++) {
                mGraph.weight[k][i] = weight[k][i];
            }
        }
    }

    //显示图的方法:显示图的邻接矩阵
    public void showGraph(MGraph mGraph) {
        System.out.print("   ");
        for (int i = 0; i < mGraph.capacity; i++) {
            System.out.print(mGraph.data[i]);
            System.out.print(" ");
        }
        System.out.println();
        for (int i = 0; i < mGraph.capacity; i++) {
            System.out.print(mGraph.data[i]);
            System.out.print(": ");
            for (int j = 0; j < mGraph.capacity; j++) {
                System.out.print(mGraph.weight[i][j]);
                System.out.print(" ");
            }
            System.out.println();
        }
    }

    //编写prim算法，以生成最小生成树

    /**
     *
     * @param mGraph 要创建最小生成树的那个图
     * @param v 开始生成的顶点
     */
    public int[][] prim(MGraph mGraph,int v){
        //创建一个数组来标记顶点是否被访问
        boolean[] visit = new boolean[mGraph.capacity];
        //将这些顶点初始标记为false
        for (int i = 0; i < mGraph.capacity; i++) {
            visit[i] = false;
        }
        //把当前节点标记为已访问
        visit[v] = true;
        //用于记录两个顶点的下标
        int[][] edge = new int[mGraph.capacity - 1][2];
        int minWeight = 0;
        //找到最大的权值
        for (int i = 0; i < mGraph.capacity; i++) {
            for (int j = i; j < mGraph.capacity; j++) {
                if (mGraph.weight[i][j] > minWeight) {
                    minWeight = mGraph.weight[i][j];
                }
            }
        }
        //记录最大的权值
        int max = minWeight;//

        int h1 = 0;
        int h2 = 0;
        for (int i = 1; i < mGraph.capacity; i++) {//最小生成树有capacity-1条边
            //确定每一次生成的子图，和哪个节点的距离最小
            for (int j = 0; j < mGraph.capacity; j++) {
                //j表示被访问过的节点
                for (int k = 0; k < mGraph.capacity; k++) {
                    //k表示未被访问的节点
                    //寻找访问节点和未访问节点之间的最小权值
                    //mGraph.weight[j][k]：访问节点和未访问节点之间的权值
                    if (visit[j] && !visit[k] && mGraph.weight[j][k] != 0 && mGraph.weight[j][k] < minWeight) {
                        minWeight = mGraph.weight[j][k];
                        //第i条边
                        h1 = j;
                        h2 = k;
                    }
                }
            }
            //把权值最小的那个节点记录到最小生成树里
            edge[i - 1][0] = h1;
            edge[i - 1][1] = h2;
            //将节点标记为已访问
            visit[edge[i - 1][1]] = true;
            minWeight = max;
        }

        return edge;
    }
}

class MGraph {
    final int capacity;//表示图的节点的个数
    char[] data;//用于表示节点的名称
    int[][] weight;//用于存放权值

    public MGraph(int capacity) {
        this.capacity = capacity;
        data = new char[this.capacity];
        weight = new int[this.capacity][this.capacity];
    }
}

\end{lstlisting}
\subsection{克鲁斯卡尔算法}
\subsubsection{公交站问题}
某城市新增7个站点（A，B，C，D，E，F，G），现在需要修路把七个站点连通。各个站点的距离用边线来表示，如何修路保证各个站点都能联通，并且修建的公路总里程最短。

\hphantom{~}\hfill A<-12->B \hfill A<-16->F\hfill A<-14->G\hfill B<-10->C\hfill B<-7->F \hfill C<-3->D \hfill\hphantom{~}

\hphantom{~}\hfill C<-5->E \hfill C<-6->F \hfill D<-4->E\hfill E<-2->F 
 \hfill E<-8->G \hfill F<-9->G \hfill\hphantom{~}

\subsubsection{克鲁斯卡尔(Kruskal)算法介绍}
用来求加权连通图的最小生成树的算法。

基本思想：按权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。

具体做法：首先构造一个只含有n个顶点的森林，然后依权值从小到大从联通网中选择边加入到森林中，并使森林中不产生回路，直到森林变成一棵树为止。
\subsubsection{步骤}
1.将全部边的权值进行升序排序。

2.依次选取最小权值的边及其对应的顶点加入至最小生成树中，注意不要构成回路。

终点：将所有顶点按从小到大的顺序排列好之后，某个顶点的终点就是与它连通的最大顶点。

回路：记录某顶点在最小生成树的终点，每次需要将一条边添加到最小生成树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。
\subsubsection{代码实现}
\begin{lstlisting}
package com.atWSN.Algorithm.Kruskal;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class Kruskal {
    private int edgeCapacity;//边的条数
    private char[] vertexs;//顶点的集合
    final private int vertexCapacity;//记录顶点的个数
    private int[][] matrix;
    private static final int max = Integer.MAX_VALUE;//用此值表示不能连通

    public static void main(String[] args) {
        char[] vertexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int[][] matrix = new int[][]
                {       //0表示自己与自己连通
                        {0, 12, max, max, max, 16, 14},
                        {12, 0, 10, max, max, 7, max},
                        {max, 10, 0, 3, 5, 6, max},
                        {max, max, 3, 0, 4, max, max},
                        {max, max, 5, 4, 0, 2, 8},
                        {16, 7, 6, max, 2, 0, 9},
                        {14, max, max, max, 8, 9, 0}
                };
        //创建Kruskal实例对象
        Kruskal graph = new Kruskal(vertexs, matrix);
        graph.print();
        List<EData> eData = new ArrayList<>();
        eData = graph.getEdges();
        System.out.println(eData);
        System.out.println("-----------------------------------");
        Collections.sort(eData);
        System.out.println(eData);
        List<EData> miniTree = graph.kruskal();
        System.out.println(miniTree);
    }

    public Kruskal(char[] vertexs, int[][] matrix) {
        //初始化顶点的个数
        this.vertexCapacity = vertexs.length;
        //初始化顶点
        this.vertexs = new char[this.vertexCapacity];
        for (int i = 0; i < this.vertexCapacity; i++) {
            this.vertexs[i] = vertexs[i];
        }
        //初始化边
        this.matrix = new int[this.vertexCapacity][this.vertexCapacity];
        for (int i = 0; i < this.vertexCapacity; i++) {
            for (int j = 0; j < this.vertexCapacity; j++) {
                this.matrix[i][j] = matrix[i][j];
            }
        }
        //统计边
        for (int i = 0; i < this.vertexCapacity; i++) {
            for (int j = i; j < this.vertexCapacity; j++) {
                if (this.matrix[i][j] < max) {
                    this.edgeCapacity++;
                }
            }
        }
    }

    //打印邻接矩阵
    public void print() {
        System.out.println("邻接矩阵：");
        System.out.print("   ");

        for (int i = 0; i < this.vertexCapacity; i++) {
            System.out.printf("%3c", this.vertexs[i]);
            System.out.print(" ");
        }
        System.out.println();
        for (int i = 0; i < this.vertexCapacity; i++) {
            System.out.print(this.vertexs[i]);
            System.out.print(": ");
            for (int j = 0; j < this.vertexCapacity; j++) {
                if (matrix[i][j] == max) {
                    System.out.print("inf");
                } else {
                    System.out.printf("%3d", matrix[i][j]);
                }
                System.out.print(" ");
            }
            System.out.println();
        }
    }

    /**
     * @param ch 顶点的值
     * @return 返回该顶点的下标，找不到返回-1
     */
    private int getPosition(char ch) {
        for (int i = 0; i < this.vertexCapacity; i++) {
            if (vertexs[i] == ch) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 功能：获取图中的边，放到EData顺序表中
     * 通过权值数组(邻接矩阵)来遍历
     */
    public List<EData> getEdges() {
        List<EData> getEdges = new ArrayList<>();
        for (int i = 0; i < this.vertexCapacity; i++) {
            for (int j = i + 1; j < this.vertexCapacity; j++) {
                if (this.matrix[i][j] > 0 && this.matrix[i][j] < max) {
                    getEdges.add(new EData(this.vertexs[i], this.vertexs[j], this.matrix[i][j]));
                }
            }
        }
        return getEdges;
    }

    /**
     * 功能：获取下标为i的顶点的终点
     * 用于后面判断两个顶点的终点是否相同
     *
     * @param ends 记录了各个顶点对应的终点是哪个，该数组是在遍历的过程中逐步形成的
     * @param i    传入的顶点对应的下标
     * @return 下标为i的顶点对应的终点的下标
     */
    private int getEnd(int[] ends, int i) {
        while (ends[i] != 0) {
            i = ends[i];
        }
        return i;
    }


    /**
     * Kruskal主算法
     */
    public List<EData> kruskal() {
        //表示最后结果的顺序表的索引
        int index;
        //用于存放某已有最小生成树中的每个顶点在最小生成树中的数组
        int[] ends = new int[this.edgeCapacity];
        //存放最小生成树的集合
        List<EData> miniTree = new ArrayList<>();

        //获取图中所有边的集合
        List<EData> edges = getEdges();
        //按边的权值进行排序
        Collections.sort(edges);
        //遍历所有的边，将权值最小的边添加到生成树时
        //判断是否形成了回路：没有构成回路就加入最小生成树
        for (EData edge :
                edges) {
            //获取该边的两个端点
            int p1 = getPosition(edge.start);
            int p2 = getPosition(edge.end);
            //获取p1这个顶点在已有的最小生成树中对应的终点
            int m1 = getEnd(ends, p1);

            int m2 = getEnd(ends, p2);
            //m1!=m2，说明不构成回路
            if (m1 != m2) {
                ends[m1] = m2;//设置m1在已有最小生成树的终点
                miniTree.add(edge);
            }
        }
        return miniTree;
    }
}

//创建一个边类，用于表示两点和这两点之间的边（权值）
class EData implements Comparable<EData> {
    char start;
    char end;
    int weight;

    public EData(char start, char end, int weight) {
        this.start = start;
        this.end = end;
        this.weight = weight;
    }

    @Override
    public String toString() {
        return this.start + "<-" + this.weight + "->" + this.end;
    }

    @Override
    public int compareTo(EData o) {
        return this.weight - o.weight;
    }
}
\end{lstlisting}
\section{最短路径相关算法}
\subsection{迪杰斯特拉(Dijkstra)算法}
\subsubsection{算法介绍}
迪杰斯特拉(Dijkstra)算法是典型最短路径计算算法，用于计算一个节点到其他节点的最短路径。

它的主要特点是以起始点为中心向外层层扩展（广度优先思想），直到扩展到终点为止。
\subsubsection{算法过程}
设置出发顶点v，顶点集合V，v到V中个顶点的距离构成距离集合Dis，Dis集合记录着v到图中各顶点的距离（到自身的距离为0）

1.从Dis集合中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时v到vi即为最短路径。

2.更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留较小的一个（同时更新顶点的前驱结点为vi，表面是通过vi到达的）

3.重复1、2，直到最短路径顶点为目标顶点即可结束。
\subsubsection{问题描述}
有七个村庄，现有六个邮差，从村庄G出发，需要分别把邮件送到其他村庄。用边线的权表示各村庄之间的距离。

A-B：5公里；A-C：7公里；A-G：2公里；B-D：9公里；B-G：3公里；

C-E：8公里；D-F：4公里；E-F：5公里；E-G：4公里；F-G：6公里

问：如何计算出村庄G到其他各个村庄最短的距离？

如果从其他点出发到各个点的最短的距离又是多少？

\subsubsection{代码实现}
\begin{lstlisting}
package com.atWSN.Algorithm.Dijkstra;

import java.util.Arrays;

public class Dijkstra {
    public static void main(String[] args) {
        char[] data = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
//        int capacity = data.length;
        final int max = 65535;
        //邻接矩阵
        int[][] weight =
                {
                        //用0表示不连通
                        //   A  B  C  D  E  F  G
                        {max, 5, 7, max, max, max, 2},
                        {5, max, max, 9, max, max, 3},
                        {7, max, max, max, 8, max, max},
                        {max, 9, max, max, max, 4, max},
                        {max, max, 8, max, max, 5, 4},
                        {max, max, max, 4, 5, max, 6},
                        {2, 3, max, max, 4, 6, max}
                };
        Graph graph = new Graph(data, weight);
        graph.print();
        graph.dijkstra(6);
    }
}

class Graph {
    private char[] vertex;//存放顶点的数组
    private int[][] weight;//邻接矩阵
    private VisitedVertex visitedVertex;

    public Graph(char[] vertex, int[][] weight) {
        this.vertex = vertex;
        this.weight = weight;
//        this.visitedVertex = new VisitedVertex(vertex.length,);
    }

    public void print() {
        for (int[] w : weight
        ) {
            System.out.println(Arrays.toString(w));
        }
    }

    /**
     * @param index 出发顶点对应的下标
     */
    public void dijkstra(int index) {
        visitedVertex = new VisitedVertex(vertex.length, index);
        update(index);//更新index顶点都周围顶点的距离和前驱
        for (int i = 0; i < vertex.length; i++) {
            index = visitedVertex.updateArr();//选择并返回新的访问顶点
            update(index);
        }
    }

    //更新index下标顶点到周围顶点的距离和周围顶点的前驱结点
    private void update(int index) {
        int len = 0;
        //遍历当前节点对应的邻接矩阵
        //更新顶点的前驱和距离
        for (int i = 0; i < weight[index].length; i++) {
            //len：出发顶点到index顶点的距离+index到顶点i的距离
            len = visitedVertex.getDistance(index) + weight[index][i];
            //如果index没有被访问过并且len小于出发顶点到i顶点的距离
            if (!visitedVertex.in(i) && len < visitedVertex.getDistance(i)) {
                this.visitedVertex.updatePre(i, index);//更新i的前驱节点为index顶点
                visitedVertex.upDateDis(i, len);//更新出发顶点到顶点i的距离
            }
        }
    }
}

class VisitedVertex {
    //记录顶点是否被访问
    public boolean[] already_arr;
    //记录该顶点的前驱顶点的下标（通过哪个节点访问的），动态更新
    public int[] pre_visited;
    //记录出发点到其他所有顶点的距离，动态更新
    public int[] distance;

    //index表示从哪个顶点开始构造
    //capacity表示点的个数
    public VisitedVertex(int capacity, int index) {
        this.already_arr = new boolean[capacity];
        this.already_arr[index] = true;//设置出发顶点被访问过
        this.pre_visited = new int[capacity];
        this.distance = new int[capacity];
        //初始化各数组
        Arrays.fill(this.pre_visited, -1);
        this.pre_visited[index] = index;

        Arrays.fill(this.distance, 65535);
        this.distance[index] = 0;
    }

    /**
     * 判断index是否被访问
     *
     * @param index
     * @return 如果访问过，返回true，否则返回false
     */
    public boolean in(int index) {
        return already_arr[index];
    }

    /**
     * 更新出发顶点到index顶点的距离
     *
     * @param index
     * @param len
     */
    public void upDateDis(int index, int len) {
        this.distance[index] = len;
    }

    /**
     * 更新index顶点的前驱为pre
     *
     * @param pre
     * @param index
     */
    public void updatePre(int index, int pre) {
        pre_visited[index] = pre;
    }

    /**
     * 返回出发顶点到index顶点的距离
     *
     * @param index
     * @return
     */
    public int getDistance(int index) {
        return this.distance[index];
    }

    //选择并返回新的访问节点，比如这里的G访问完后，就是A作为新的访问顶点
    public int updateArr() {
        int min = 65535;
        int index = 0;
        for (int i = 0; i < already_arr.length; i++) {
            if (!already_arr[i] && distance[i] < min) {
                min = distance[i];
                index = i;
            }
        }
        already_arr[index] = true;
        return index;
    }
}
\end{lstlisting}
\subsection{佛洛依德算法}
计算各个顶点之间的最短路径
\subsubsection{代码实现}
\begin{lstlisting}
package com.atWSN.Algorithm.Floyd;

public class Floyd {
    public static void main(String[] args) {
        char[] vertex = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        final int max = 65535;
        //邻接矩阵
        int[][] weight =
                {
                        //用0表示不连通
                        //   A  B  C  D  E  F  G
                        {0, 5, 7, max, max, max, 2},
                        {5, 0, max, 9, max, max, 3},
                        {7, max, 0, max, 8, max, max},
                        {max, 9, max, 0, max, 4, max},
                        {max, max, 8, max, 0, 5, 4},
                        {max, max, max, 4, 5, 0, 6},
                        {2, 3, max, max, 4, 6, 0}
                };
        Graph graph = new Graph(vertex.length, weight, vertex);
        graph.show();
        System.out.println("-----------------------------------");
        graph.floyd();
        graph.show();
    }
}

class Graph {
    private char[] vertex;
    private int[][] dis;//保存从各个顶点出发到其他顶点的距离
    private char[][] pre;//保存到达目标顶点的前驱结点

    public Graph(int capacity, int[][] weight, char[] vertexs) {
        this.vertex = vertexs;
        this.dis = weight;
        this.pre = new char[vertexs.length][vertexs.length];
        for (int i = 0; i < vertexs.length; i++) {
            for (int j = 0; j < vertexs.length; j++) {
                if (i == j) {
                    pre[i][j] = vertex[i];
                } else {
                    pre[i][j] = '-';

                }
            }
        }
    }

    public void show() {
        System.out.print("   ");
        for (int i = 0; i < vertex.length; i++) {
            System.out.printf("%3c",vertex[i]);
            System.out.print(" ");
        }
        System.out.println();
        for (int i = 0; i < dis.length; i++) {
            System.out.print(vertex[i]);
            System.out.print(": ");
            for (int j = 0; j < dis[0].length; j++) {
                if (dis[i][j] == 65535) {
                    System.out.print("  n");
                } else {
                    System.out.printf("%3d",dis[i][j]);
                }
                System.out.print(" ");
            }
            System.out.println();
        }
        System.out.println("-------------------------");
        System.out.print("   ");
        for (int i = 0; i < vertex.length; i++) {
            System.out.print(vertex[i]);
            System.out.print(" ");
        }
        System.out.println();
        for (int i = 0; i < pre.length; i++) {
            System.out.print(vertex[i]);
            System.out.print(": ");
            for (int j = 0; j < pre[0].length; j++) {
                System.out.print(pre[i][j]);
                System.out.print(" ");
            }
            System.out.println();
        }
    }

    public void floyd() {
        int len;
        for (int i = 0; i < vertex.length; i++) {//中间顶点
            for (int j = 0; j < vertex.length; j++) {//起点
                for (int k = 0; k < vertex.length; k++) {//终点
                    len = dis[i][j] + dis[i][k];
                    if (len < dis[j][k]) {
                        pre[j][k] = vertex[i];
                        dis[j][k] = len;
                    }
                }
            }
        }
        for (int i = 0; i < vertex.length; i++) {
            for (int j = 0; j < vertex.length; j++) {
                if (pre[i][j] == '-'){
                    pre[i][j] = vertex[i];
                }
            }
        }
    }
}
\end{lstlisting}
\section{马踏棋盘算法}
骑士周游问题，将马随机放在国际象棋8×8的棋盘上，马按走棋规则进行移动，要求每个方格只能走依次，走遍棋盘上的全部方格。

该问题实际上是图的深度优先搜索的应用。

回溯算法或贪心算法。
\end{document} 